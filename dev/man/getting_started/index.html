<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · DataFrames.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/man/getting_started/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFrames.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../basics/">First Steps with DataFrames.jl</a></li><li><span class="tocitem">User Guide</span><ul><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#安装"><span>安装</span></a></li><li><a class="tocitem" href="#DataFrame-类型"><span><code>DataFrame</code> 类型</span></a></li></ul></li><li><a class="tocitem" href="../working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li><a class="tocitem" href="../joins/">Joins</a></li><li><a class="tocitem" href="../split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../sorting/">Sorting</a></li><li><a class="tocitem" href="../categorical/">Categorical Data</a></li><li><a class="tocitem" href="../missing/">Missing Data</a></li><li><a class="tocitem" href="../querying_frameworks/">Data manipulation frameworks</a></li><li><a class="tocitem" href="../comparisons/">Comparison with Python/R/Stata</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../lib/types/">Types</a></li><li><a class="tocitem" href="../../lib/functions/">Functions</a></li><li><a class="tocitem" href="../../lib/indexing/">Indexing</a></li><li><a class="tocitem" href="../../lib/metadata/">Metadata</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/HaoxuanGuo/DataFrames.jl/blob/main/docs/src/man/getting_started.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="入门指南"><a class="docs-heading-anchor" href="#入门指南">入门指南</a><a id="入门指南-1"></a><a class="docs-heading-anchor-permalink" href="#入门指南" title="Permalink"></a></h1><h2 id="安装"><a class="docs-heading-anchor" href="#安装">安装</a><a id="安装-1"></a><a class="docs-heading-anchor-permalink" href="#安装" title="Permalink"></a></h2><p>DataFrames包通过Julia包系统提供，可以使用以下命令进行安装：</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;DataFrames&quot;)</code></pre><p>在本教程的其余部分，我们假设你已经安装了DataFrames包，并且已经输入了<code>using DataFrames</code>，将所有相关的变量引入到你当前的命名空间。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>默认情况下，DataFrames.jl在Jupyter Notebook中显示数据帧时，行和列的数量分别限制为25和100。你可以通过改变<code>ENV[&quot;DATAFRAMES_COLUMNS&quot;]</code>和<code>ENV[&quot;DATAFRAMES_ROWS&quot;]</code>变量的值来覆盖这种行为，以保持输出的最大列数和行数。如果这些数字等于或小于0，将打印所有的列或行。</p><p>或者，你可能想要在每个Julia会话中，通过某个Jupyter内核文件设置数据帧的最大打印行数为<code>100</code>，最大打印列数为<code>1000</code>（数字<code>100</code>和<code>1000</code>只是例子，可以进行调整）。在这种情况下，向这个Jupyter内核文件的<code>&quot;env&quot;</code>变量中添加一个<code>&quot;DATAFRAME_COLUMNS&quot;: &quot;1000&quot;, &quot;DATAFRAMES_ROWS&quot;: &quot;100&quot;</code>条目。关于Jupyter内核的位置和规范的信息，请查看<a href="https://jupyter-client.readthedocs.io/en/stable/kernels.html">这里</a>。</p><p><a href="https://github.com/ronisbr/PrettyTables.jl">PrettyTables.jl</a>包在Jupyter notebook中渲染<code>DataFrame</code>。用户可以通过向<code>show</code>函数传递关键字参数<code>kwargs...</code>来自定义输出：<code>show(stdout, MIME(&quot;text/html&quot;), df; kwargs...)</code>，其中<code>df</code>是<code>DataFrame</code>。此处可以使用PrettyTables.jl在HTML后端支持的任何参数。因此，例如，如果用户想要在Jupyter中将所有小于0的数字的颜色改为红色，他们可以在<code>using PrettyTables</code>后执行：<code>show(stdout, MIME(&quot;text/html&quot;), df; highlighters = hl_lt(0, HtmlDecoration(color = &quot;red&quot;)))</code>。关于可用选项的更多信息，请查看<a href="https://ronisbr.github.io/PrettyTables.jl/stable/man/usage/">PrettyTables.jl文档</a>。</p></div></div><h2 id="DataFrame-类型"><a class="docs-heading-anchor" href="#DataFrame-类型"><code>DataFrame</code> 类型</a><a id="DataFrame-类型-1"></a><a class="docs-heading-anchor-permalink" href="#DataFrame-类型" title="Permalink"></a></h2><p><code>DataFrame</code>类型的对象表示一个数据表，作为一系列向量，每个向量对应一列或变量。构造<code>DataFrame</code>的最简单方式是使用关键字参数或对传递列向量：</p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames

julia&gt; DataFrame(a=1:4, b=[&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;]) # 关键字参数构造器
4×2 DataFrame
 Row │ a      b
     │ Int64  String
─────┼───────────────
   1 │     1  M
   2 │     2  F
   3 │     3  F
   4 │     4  M</code></pre><p>以下是其他常用的构造数据帧的方法：</p><pre><code class="language-julia-repl hljs">julia&gt; DataFrame((a=[1, 2], b=[3, 4])) # 从命名元组的向量构造Tables.jl表
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      3
   2 │     2      4

julia&gt; DataFrame([(a=1, b=0), (a=2, b=0)]) # 从命名元组的向量构造Tables.jl表
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0

julia&gt; DataFrame(&quot;a&quot; =&gt; 1:2, &quot;b&quot; =&gt; 0) # Pair构造器
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0

julia&gt; DataFrame([:a =&gt; 1:2, :b =&gt; 0]) # Pairs向量构造器
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0

julia&gt; DataFrame(Dict(:a =&gt; 1:2, :b =&gt; 0)) # 字典构造器
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0

julia&gt; DataFrame([[1, 2], [0, 0]], [:a, :b]) # 向量的向量构造器
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0

julia&gt; DataFrame([1 0; 2 0], :auto) # 矩阵构造器
2×2 DataFrame
 Row │ x1     x2
     │ Int64  Int64
─────┼──────────────
   1 │     1      0
   2 │     2      0</code></pre><p>列可以直接（即，不复制）用<code>df.col</code>，<code>df.&quot;col&quot;</code>，<code>df[!, :col]</code>或<code>df[!, &quot;col&quot;]</code>提取（这个规则适用于从数据帧获取数据，而不是向数据帧写入数据）。后两种语法更灵活，因为它们允许传递一个保存列名的变量，而不仅仅是一个字面名。注意，列名可以是符号（写成<code>:col</code>，<code>:var&quot;col&quot;</code>或<code>Symbol(&quot;col&quot;)</code>）或字符串（写成<code>&quot;col&quot;</code>）。在<code>df.&quot;col&quot;</code>和<code>:var&quot;col&quot;</code>的形式中，使用`进行字符串插值不起作用。列也可以通过指定它们的位置的整数索引来提取。</p><p>由于<code>df[!, :col]</code>不会复制，改变这种语法返回的列向量的元素将影响存储在原始<code>df</code>中的值。要获取列的副本，使用<code>df[:, :col]</code>：改变这种语法返回的向量不会改变<code>df</code>。</p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A=1:4, B=[&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;])
4×2 DataFrame
 Row │ A      B
     │ Int64  String
─────┼───────────────
   1 │     1  M
   2 │     2  F
   3 │     3  F
   4 │     4  M

julia&gt; df.A
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; df.&quot;A&quot;
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; df.A === df[!, :A]
true

julia&gt; df.A === df[:, :A]
false

julia&gt; df.A == df[:, :A]
true

julia&gt; df.A === df[!, &quot;A&quot;]
true

julia&gt; df.A === df[:, &quot;A&quot;]
false

julia&gt; df.A == df[:, &quot;A&quot;]
true

julia&gt; df.A === df[!, 1]
true

julia&gt; df.A === df[:, 1]
false

julia&gt; df.A == df[:, 1]
true

julia&gt; firstcolumn = :A
:A

julia&gt; df[!, firstcolumn] === df.A
true

julia&gt; df[:, firstcolumn] === df.A
false

julia&gt; df[:, firstcolumn] == df.A
true</code></pre><p>列名可以使用<code>names</code>函数获取为字符串：</p><pre><code class="language-julia-repl hljs">julia&gt; names(df)
2-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;</code></pre><p>你也可以通过传递一个列选择器条件作为第二个参数来过滤列名。在<a href="../../lib/functions/#Base.names"><code>names</code></a>文档字符串中，你可以找到关于所有可用条件的详细列表。这里我们给出一些选定的例子：</p><pre><code class="language-julia-repl hljs">julia&gt; names(df, r&quot;A&quot;) # 正则表达式选择器
1-element Vector{String}:
 &quot;A&quot;

julia&gt; names(df, Int) # 使用列元素类型的选择器
1-element Vector{String}:
 &quot;A&quot;

julia&gt; names(df, Not(:B)) # 保留除:B以外的所有列的选择器
1-element Vector{String}:
 &quot;A&quot;</code></pre><p>要以<code>Symbol</code>形式获取列名，使用<code>propertynames</code>函数：</p><pre><code class="language-julia-repl hljs">julia&gt; propertynames(df)
2-element Vector{Symbol}:
 :A
 :B</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>DataFrames.jl允许使用<code>Symbol</code>（如<code>:A</code>）和字符串（如<code>&quot;A&quot;</code>）进行所有列索引操作，以便于使用。然而，使用<code>Symbol</code>稍微快一些，通常应该被优先选择，除非通过字符串操作生成它们。</p></div></div><h3 id="按列构造"><a class="docs-heading-anchor" href="#按列构造">按列构造</a><a id="按列构造-1"></a><a class="docs-heading-anchor-permalink" href="#按列构造" title="Permalink"></a></h3><p>也可以从一个空的<code>DataFrame</code>开始，一列一列地添加：</p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame()
0×0 DataFrame

julia&gt; df.A = 1:8
1:8

julia&gt; df[:, :B] = [&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;]
8-element Vector{String}:
 &quot;M&quot;
 &quot;F&quot;
 &quot;F&quot;
 &quot;M&quot;
 &quot;F&quot;
 &quot;M&quot;
 &quot;M&quot;
 &quot;F&quot;

julia&gt; df[!, :C] .= 0
8-element Vector{Int64}:
 0
 0
 0
 0
 0
 0
 0
 0

julia&gt; df
8×3 DataFrame
 Row │ A      B       C
     │ Int64  String  Int64
─────┼──────────────────────
   1 │     1  M           0
   2 │     2  F           0
   3 │     3  F           0
   4 │     4  M           0
   5 │     5  F           0
   6 │     6  M           0
   7 │     7  M           0
   8 │     8  F           0</code></pre><p>我们以这种方式构建的<code>DataFrame</code>有8行和3列。这可以使用<code>size</code>函数进行检查：</p><pre><code class="language-julia-repl hljs">julia&gt; size(df, 1)
8

julia&gt; size(df, 2)
3

julia&gt; size(df)
(8, 3)</code></pre><p>在上述例子中，注意到表达式<code>df[!, :C] .= 0</code>通过广播一个标量来创建了数据框中的新列。</p><p>在设置数据框的列时，<code>df[!, :C]</code>和<code>df.C</code>的语法是等价的，它们会替换（或创建）<code>df</code>中的<code>:C</code>列。这与使用<code>df[:, :C]</code>设置数据框中的列不同，后者如果列已经存在的话，会就地更新列的内容。</p><p>这里有一个例子展示这种差异。让我们尝试将<code>:B</code>列改为二元变量。</p><pre><code class="language-julia-repl hljs">julia&gt; df[:, :B] = df.B .== &quot;F&quot;
ERROR: MethodError: Cannot `convert` an object of type Bool to an object of type String

julia&gt; df[:, :B] .= df.B .== &quot;F&quot;
ERROR: MethodError: Cannot `convert` an object of type Bool to an object of type String</code></pre><p>上述操作没有成功，因为当你使用<code>:</code>作为行选择器时，<code>:B</code>列是就地更新的，它只支持存储字符串。</p><p>另一方面，下面的操作可以：</p><pre><code class="language-julia-repl hljs">julia&gt; df.B = df.B .== &quot;F&quot;
8-element BitVector:
 0
 1
 1
 0
 1
 0
 0
 1

julia&gt; df
8×3 DataFrame
 Row │ A      B      C
     │ Int64  Bool   Int64
─────┼─────────────────────
   1 │     1  false      0
   2 │     2   true      0
   3 │     3   true      0
   4 │     4  false      0
   5 │     5   true      0
   6 │     6  false      0
   7 │     7  false      0
   8 │     8   true      0</code></pre><p>如你所见，因为我们在赋值的右侧使用了<code>df.B</code>，所以<code>:B</code>列被替换了。如果我们使用<code>df[!, :B]</code>或者我们使用广播赋值<code>.=</code>，将会达到同样的效果。</p><p>在手册的<a href="../../lib/indexing/#Indexing">Indexing</a>部分，你可以找到所有关于所有可用索引选项的详细信息。</p><h3 id="逐行构建"><a class="docs-heading-anchor" href="#逐行构建">逐行构建</a><a id="逐行构建-1"></a><a class="docs-heading-anchor-permalink" href="#逐行构建" title="Permalink"></a></h3><p>也可以逐行填充<code>DataFrame</code>。让我们构建一个空的数据框，有两列（注意第一列只能包含整数，第二列只能包含字符串）：</p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A=Int[], B=String[])
0×2 DataFrame
 Row │ A      B
     │ Int64  String
─────┴───────────────</code></pre><p>然后可以添加元组或向量作为行，其中元素的顺序与列的顺序匹配。要在数据框的末尾添加新行，使用<a href="../../lib/functions/#Base.push!"><code>push!</code></a>：</p><pre><code class="language-julia-repl hljs">julia&gt; push!(df, (1, &quot;M&quot;))
1×2 DataFrame
 Row │ A      B
     │ Int64  String
─────┼───────────────
   1 │     1  M

julia&gt; push!(df, [2, &quot;N&quot;])
2×2 DataFrame
 Row │ A      B
     │ Int64  String
─────┼───────────────
   1 │     1  M
   2 │     2  N</code></pre><p>行也可以作为<code>Dict</code>添加，其中字典的键匹配列的名称：</p><pre><code class="language-julia-repl hljs">julia&gt; push!(df, Dict(:B =&gt; &quot;F&quot;, :A =&gt; 3))
3×2 DataFrame
 Row │ A      B
     │ Int64  String
─────┼───────────────
   1 │     1  M
   2 │     2  N
   3 │     3  F</code></pre><p>请注意，逐行构建<code>DataFrame</code>的性能明显低于一次性构建，或者按列构建。对于许多用例，这可能无关紧要，但对于非常大的<code>DataFrame</code>，这可能是一个考虑因素。</p><p>如果你想在数据框的开始处添加行，使用<a href="../../lib/functions/#Base.pushfirst!"><code>pushfirst!</code></a>，要在任意位置插入行，使用<a href="../../lib/functions/#Base.insert!"><code>insert!</code></a>。</p><p>你也可以使用<a href="../../lib/functions/#Base.append!"><code>append!</code></a>和<a href="../../lib/functions/#Base.prepend!"><code>prepend!</code></a>函数将整个表添加到数据框中。</p><h3 id="从另一种表类型构建"><a class="docs-heading-anchor" href="#从另一种表类型构建">从另一种表类型构建</a><a id="从另一种表类型构建-1"></a><a class="docs-heading-anchor-permalink" href="#从另一种表类型构建" title="Permalink"></a></h3><p>DataFrames支持<a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a>接口，用于与表格数据交互。这意味着<code>DataFrame</code>可以作为任何期望Tables.jl接口输入的包的&quot;源&quot;（文件格式包，数据操作包等）。<code>DataFrame</code>也可以是任何Tables.jl接口输入的接收器。一些示例用途是：</p><pre><code class="language-julia hljs">df = DataFrame(a=[1, 2, 3], b=[:a, :b, :c])

# 把 DataFrame 写入 CSV 文件
CSV.write(&quot;dataframe.csv&quot;, df)

# 把 DataFrame 存储在 SQLite 数据库表中
SQLite.load!(df, db, &quot;dataframe_table&quot;)

# 通过 Query.jl 包转换 DataFrame
df = df |&gt; @map({a=_.a + 1, _.b}) |&gt; DataFrame</code></pre><p>支持<a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a>接口的特定常见集合的一个例子是<code>NamedTuple</code>的向量：</p><pre><code class="language-julia-repl hljs">julia&gt; v = [(a=1, b=2), (a=3, b=4)]
2-element Vector{NamedTuple{(:a, :b), Tuple{Int64, Int64}}}:
 (a = 1, b = 2)
 (a = 3, b = 4)

julia&gt; df = DataFrame(v)
2×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      2
   2 │     3      4</code></pre><p>你也可以很容易地把数据框转换回<code>NamedTuple</code>的向量：</p><pre><code class="language-julia-repl hljs">julia&gt; using Tables

julia&gt; Tables.rowtable(df)
2-element Vector{NamedTuple{(:a, :b), Tuple{Int64, Int64}}}:
 (a = 1, b = 2)
 (a = 3, b = 4)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../basics/">« First Steps with DataFrames.jl</a><a class="docs-footer-nextpage" href="../working_with_dataframes/">Working with DataFrames »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 15 December 2023 13:48">Friday 15 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
