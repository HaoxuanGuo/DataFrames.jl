<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Comparison with Python/R/Stata · DataFrames.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFrames.jl/stable/man/comparisons/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataFrames.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../basics/">First Steps with DataFrames.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../working_with_dataframes/">Working with DataFrames</a></li><li><a class="tocitem" href="../importing_and_exporting/">Importing and Exporting Data (I/O)</a></li><li><a class="tocitem" href="../joins/">Joins</a></li><li><a class="tocitem" href="../split_apply_combine/">Split-apply-combine</a></li><li><a class="tocitem" href="../reshaping_and_pivoting/">Reshaping</a></li><li><a class="tocitem" href="../sorting/">Sorting</a></li><li><a class="tocitem" href="../categorical/">Categorical Data</a></li><li><a class="tocitem" href="../missing/">Missing Data</a></li><li><a class="tocitem" href="../querying_frameworks/">Data manipulation frameworks</a></li><li class="is-active"><a class="tocitem" href>Comparison with Python/R/Stata</a><ul class="internal"><li><a class="tocitem" href="#与Python包pandas的比较"><span>与Python包pandas的比较</span></a></li><li><a class="tocitem" href="#与R包dplyr的比较"><span>与R包dplyr的比较</span></a></li><li><a class="tocitem" href="#与-R-包-data.table-的比较"><span>与 R 包 data.table 的比较</span></a></li><li><a class="tocitem" href="#与-Stata（8-版及以上版本）的比较"><span>与 Stata（8 版及以上版本）的比较</span></a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../lib/types/">Types</a></li><li><a class="tocitem" href="../../lib/functions/">Functions</a></li><li><a class="tocitem" href="../../lib/indexing/">Indexing</a></li><li><a class="tocitem" href="../../lib/metadata/">Metadata</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Comparison with Python/R/Stata</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Comparison with Python/R/Stata</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/HaoxuanGuo/DataFrames.jl/blob/main/docs/src/man/comparisons.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="比较"><a class="docs-heading-anchor" href="#比较">比较</a><a id="比较-1"></a><a class="docs-heading-anchor-permalink" href="#比较" title="Permalink"></a></h1><p>本节将DataFrames.jl与Python、R和Stata中的其他数据操作框架进行比较。</p><p>可以使用以下代码创建一个示例数据集：</p><pre><code class="language-julia hljs">using DataFrames
using Statistics

df = DataFrame(grp=repeat(1:2, 3), x=6:-1:1, y=4:9, z=[3:7; missing], id=&#39;a&#39;:&#39;f&#39;)
df2 = DataFrame(grp=[1, 3], w=[10, 11])</code></pre><p>!!! 注意</p><pre><code class="nohighlight hljs">某些操作会改变表格，因此每个操作都假设在原始数据框上进行。</code></pre><p>请注意，在下面的比较中，像 <code>x -&gt; x &gt;= 1</code> 这样的谓词可以更简洁地写为 <code>=&gt;(1)</code>。后一种形式还具有额外的好处，它在每个Julia会话中只编译一次（而 <code>x -&gt; x &gt;= 1</code> 每次引入时都会定义一个新的匿名函数）。</p><h2 id="与Python包pandas的比较"><a class="docs-heading-anchor" href="#与Python包pandas的比较">与Python包pandas的比较</a><a id="与Python包pandas的比较-1"></a><a class="docs-heading-anchor-permalink" href="#与Python包pandas的比较" title="Permalink"></a></h2><p>下表比较了DataFrames.jl的主要函数与Python包pandas（版本1.1.0）的对应函数：</p><pre><code class="language-python hljs">import pandas as pd
import numpy as np

df = pd.DataFrame({&#39;grp&#39;: [1, 2, 1, 2, 1, 2],
                   &#39;x&#39;: range(6, 0, -1),
                   &#39;y&#39;: range(4, 10),
                   &#39;z&#39;: [3, 4, 5, 6, 7, None]},
                   index = list(&#39;abcdef&#39;))
df2 = pd.DataFrame({&#39;grp&#39;: [1, 3], &#39;w&#39;: [10, 11]})</code></pre><p>由于pandas支持多索引，此示例数据框使用 <code>a</code> 到 <code>f</code> 作为行索引，而不是单独的 <code>id</code> 列。</p><h3 id="访问数据"><a class="docs-heading-anchor" href="#访问数据">访问数据</a><a id="访问数据-1"></a><a class="docs-heading-anchor-permalink" href="#访问数据" title="Permalink"></a></h3><table><tr><th style="text-align: left">操作</th><th style="text-align: left">pandas</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">位置索引单元格</td><td style="text-align: left"><code>df.iloc[1, 1]</code></td><td style="text-align: left"><code>df[2, 2]</code></td></tr><tr><td style="text-align: left">位置切片行</td><td style="text-align: left"><code>df.iloc[1:3]</code></td><td style="text-align: left"><code>df[2:3, :]</code></td></tr><tr><td style="text-align: left">位置切片列</td><td style="text-align: left"><code>df.iloc[:, 1:]</code></td><td style="text-align: left"><code>df[:, 2:end]</code></td></tr><tr><td style="text-align: left">标签索引行</td><td style="text-align: left"><code>df.loc[&#39;c&#39;]</code></td><td style="text-align: left"><code>df[findfirst(==(&#39;c&#39;), df.id), :]</code></td></tr><tr><td style="text-align: left">标签索引列</td><td style="text-align: left"><code>df.loc[:, &#39;x&#39;]</code></td><td style="text-align: left"><code>df[:, :x]</code></td></tr><tr><td style="text-align: left">标签切片列</td><td style="text-align: left"><code>df.loc[:, [&#39;x&#39;, &#39;z&#39;]]</code></td><td style="text-align: left"><code>df[:, [:x, :z]]</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df.loc[:, &#39;x&#39;:&#39;z&#39;]</code></td><td style="text-align: left"><code>df[:, Between(:x, :z)]</code></td></tr><tr><td style="text-align: left">混合索引</td><td style="text-align: left"><code>df.loc[&#39;c&#39;][1]</code></td><td style="text-align: left"><code>df[findfirst(==(&#39;c&#39;), df.id), 2]</code></td></tr></table><p>请注意，Julia使用基于1的索引，两端都包含。特殊关键字 <code>end</code> 可用于表示最后一个索引。同样，关键字 <code>begin</code> 可用于表示第一个索引。</p><p>此外，使用 <code>findfirst</code> 函数索引数据框时，返回一个单独的 <code>DataFrameRow</code> 对象。如果 <code>id</code> 不唯一，可以使用 <code>findall</code> 函数或布尔索引。它将返回一个包含所有匹配行的 <code>DataFrame</code> 对象。下面的两行代码是功能上等价的：</p><pre><code class="language-julia hljs">df[findall(==(&#39;c&#39;), df.id), :]
df[df.id .== &#39;c&#39;, :]</code></pre><p>DataFrames.jl的索引始终产生一致和可预测的返回类型。相比之下，pandas的 <code>loc</code> 函数在索引值为 <code>&#39;c&#39;</code> 的索引中只有一个值时返回一个 <code>Series</code> 对象，而在有多个索引值为 <code>&#39;c&#39;</code> 的行时返回一个 <code>DataFrame</code> 对象。</p><h3 id="常见操作"><a class="docs-heading-anchor" href="#常见操作">常见操作</a><a id="常见操作-1"></a><a class="docs-heading-anchor-permalink" href="#常见操作" title="Permalink"></a></h3><table><tr><th style="text-align: left">操作</th><th style="text-align: left">pandas</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">求多个值的平均值</td><td style="text-align: left"><code>df[&#39;z&#39;].mean(skipna = False)</code></td><td style="text-align: left"><code>mean(df.z)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df[&#39;z&#39;].mean()</code></td><td style="text-align: left"><code>mean(skipmissing(df.z))</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df[[&#39;z&#39;]].agg([&#39;mean&#39;])</code></td><td style="text-align: left"><code>combine(df, :z =&gt; mean ∘ skipmissing)</code></td></tr><tr><td style="text-align: left">添加新列</td><td style="text-align: left"><code>df.assign(z1 = df[&#39;z&#39;] + 1)</code></td><td style="text-align: left"><code>transform(df, :z =&gt; (v -&gt; v .+ 1) =&gt; :z1)</code></td></tr><tr><td style="text-align: left">重命名列</td><td style="text-align: left"><code>df.rename(columns = {&#39;x&#39;: &#39;x_new&#39;})</code></td><td style="text-align: left"><code>rename(df, :x =&gt; :x_new)</code></td></tr><tr><td style="text-align: left">选择和转换列</td><td style="text-align: left"><code>df.assign(x_mean = df[&#39;x&#39;].mean())[[&#39;x_mean&#39;, &#39;y&#39;]]</code></td><td style="text-align: left"><code>select(df, :x =&gt; mean, :y)</code></td></tr><tr><td style="text-align: left">排序行</td><td style="text-align: left"><code>df.sort_values(by = &#39;x&#39;)</code></td><td style="text-align: left"><code>sort(df, :x)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df.sort_values(by = [&#39;grp&#39;, &#39;x&#39;], ascending = [True, False])</code></td><td style="text-align: left"><code>sort(df, [:grp, order(:x, rev = true)])</code></td></tr><tr><td style="text-align: left">删除缺失行</td><td style="text-align: left"><code>df.dropna()</code></td><td style="text-align: left"><code>dropmissing(df)</code></td></tr><tr><td style="text-align: left">选择唯一行</td><td style="text-align: left"><code>df.drop_duplicates()</code></td><td style="text-align: left"><code>unique(df)</code></td></tr></table><p>请注意，pandas默认情况下在其分析函数中跳过<code>NaN</code>值。相比之下， Julia函数不会跳过<code>NaN</code>值。如果需要，在处理之前可以过滤掉 <code>NaN</code>值，例如<code>mean(Iterators.filter(!isnan, x))</code>。</p><p>Pandas使用<code>NaN</code>表示缺失数据和浮点数的&quot;not a number&quot;值。 Julia为表示缺失数据定义了一个特殊值<code>missing</code>。DataFrames.jl在默认情况下遵守 Julia中有关传播<code>missing</code>值的一般规则。如果需要， 可以使用<code>skipmissing</code>函数删除缺失数据。 有关更多信息，请参阅<a href="../missing/#缺失数据">缺失数据</a>部分。</p><p>此外，pandas在应用函数后保留原始列名。 DataFrames.jl默认情况下在列名后附加后缀。为了简化起见， 上述示例没有在pandas和DataFrames.jl之间同步列名 （可以向<code>select</code>、<code>transform</code>和<code>combine</code>函数传递<code>renamecols=false</code>关键字参数以保留旧列名）。</p><h3 id="可变操作"><a class="docs-heading-anchor" href="#可变操作">可变操作</a><a id="可变操作-1"></a><a class="docs-heading-anchor-permalink" href="#可变操作" title="Permalink"></a></h3><table><tr><th style="text-align: left">操作</th><th style="text-align: left">pandas</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">添加新列</td><td style="text-align: left"><code>df[&#39;z1&#39;] = df[&#39;z&#39;] + 1</code></td><td style="text-align: left"><code>df.z1 = df.z .+ 1</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>transform!(df, :z =&gt; (x -&gt; x .+ 1) =&gt; :z1)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df.insert(1, &#39;const&#39;, 10)</code></td><td style="text-align: left"><code>insertcols!(df, 2, :const =&gt; 10)</code></td></tr><tr><td style="text-align: left">重命名列</td><td style="text-align: left"><code>df.rename(columns = {&#39;x&#39;: &#39;x_new&#39;}, inplace = True)</code></td><td style="text-align: left"><code>rename!(df, :x =&gt; :x_new)</code></td></tr><tr><td style="text-align: left">排序行</td><td style="text-align: left"><code>df.sort_values(by = &#39;x&#39;, inplace = True)</code></td><td style="text-align: left"><code>sort!(df, :x)</code></td></tr><tr><td style="text-align: left">删除缺失行</td><td style="text-align: left"><code>df.dropna(inplace = True)</code></td><td style="text-align: left"><code>dropmissing!(df)</code></td></tr><tr><td style="text-align: left">选择唯一行</td><td style="text-align: left"><code>df.drop_duplicates(inplace = True)</code></td><td style="text-align: left"><code>unique!(df)</code></td></tr></table><p>一般来说，DataFrames.jl 遵循 Julia 的约定，在函数名中使用 <code>!</code> 表示修改行为。</p><h3 id="分组数据和聚合"><a class="docs-heading-anchor" href="#分组数据和聚合">分组数据和聚合</a><a id="分组数据和聚合-1"></a><a class="docs-heading-anchor-permalink" href="#分组数据和聚合" title="Permalink"></a></h3><p>DataFrames.jl 提供了 <code>groupby</code> 函数来对每个组进行操作。<code>groupby</code> 的结果是一个 <code>GroupedDataFrame</code> 对象，可以使用 <code>combine</code>、<code>transform</code> 或 <code>select</code> 函数对其进行处理。下表列举了一些常见的分组和聚合用法。</p><table><tr><th style="text-align: left">操作</th><th style="text-align: left">pandas</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">按组聚合</td><td style="text-align: left"><code>df.groupby(&#39;grp&#39;)[&#39;x&#39;].mean()</code></td><td style="text-align: left"><code>combine(groupby(df, :grp), :x =&gt; mean)</code></td></tr><tr><td style="text-align: left">聚合后重命名列</td><td style="text-align: left"><code>df.groupby(&#39;grp&#39;)[&#39;x&#39;].mean().rename(&quot;my_mean&quot;)</code></td><td style="text-align: left"><code>combine(groupby(df, :grp), :x =&gt; mean =&gt; :my_mean)</code></td></tr><tr><td style="text-align: left">添加聚合数据作为列</td><td style="text-align: left"><code>df.join(df.groupby(&#39;grp&#39;)[&#39;x&#39;].mean(), on=&#39;grp&#39;, rsuffix=&#39;_mean&#39;)</code></td><td style="text-align: left"><code>transform(groupby(df, :grp), :x =&gt; mean)</code></td></tr><tr><td style="text-align: left">...并选择输出列</td><td style="text-align: left"><code>df.join(df.groupby(&#39;grp&#39;)[&#39;x&#39;].mean(), on=&#39;grp&#39;, rsuffix=&#39;_mean&#39;)[[&#39;grp&#39;, &#39;x_mean&#39;]]</code></td><td style="text-align: left"><code>select(groupby(df, :grp), :id, :x =&gt; mean)</code></td></tr></table><p>请注意，pandas 对于一维结果返回一个 <code>Series</code> 对象，除非之后调用 <code>reset_index</code>。 相应的 DataFrames.jl 示例返回一个等价的 <code>DataFrame</code> 对象。 考虑第一个示例：</p><pre><code class="language-python hljs">&gt;&gt;&gt; df.groupby(&#39;grp&#39;)[&#39;x&#39;].mean()
grp
1    4
2    3
Name: x, dtype: int64</code></pre><p>在 DataFrames.jl 中，它看起来是这样的：</p><pre><code class="language-julia hljs">julia&gt; combine(groupby(df, :grp), :x =&gt; mean)
2×2 DataFrame
 Row │ grp    x_mean
     │ Int64  Float64
─────┼────────────────
   1 │     1      4.0
   2 │     2      3.0</code></pre><p>在 DataFrames.jl 中，<code>GroupedDataFrame</code> 对象支持高效的键查找。因此，当需要重复执行查找时，它的性能表现良好。</p><h3 id="更高级的命令"><a class="docs-heading-anchor" href="#更高级的命令">更高级的命令</a><a id="更高级的命令-1"></a><a class="docs-heading-anchor-permalink" href="#更高级的命令" title="Permalink"></a></h3><p>本节包括更复杂的示例。</p><table><tr><th style="text-align: left">操作</th><th style="text-align: left">pandas</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">复杂函数</td><td style="text-align: left"><code>df[[&#39;z&#39;]].agg(lambda v: np.mean(np.cos(v)))</code></td><td style="text-align: left"><code>combine(df, :z =&gt; v -&gt; mean(cos, skipmissing(v)))</code></td></tr><tr><td style="text-align: left">聚合多列数据</td><td style="text-align: left"><code>df.agg({&#39;x&#39;: max, &#39;y&#39;: min})</code></td><td style="text-align: left"><code>combine(df, :x =&gt; maximum, :y =&gt; minimum)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df[[&#39;x&#39;, &#39;y&#39;]].mean()</code></td><td style="text-align: left"><code>combine(df, [:x, :y] .=&gt; mean)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df.filter(regex=(&quot;^x&quot;)).mean()</code></td><td style="text-align: left"><code>combine(df, names(df, r&quot;^x&quot;) .=&gt; mean)</code></td></tr><tr><td style="text-align: left">应用函数于多个变量</td><td style="text-align: left"><code>df.assign(x_y_cor = np.corrcoef(df.x, df.y)[0, 1])</code></td><td style="text-align: left"><code>transform(df, [:x, :y] =&gt; cor)</code></td></tr><tr><td style="text-align: left">逐行操作</td><td style="text-align: left"><code>df.assign(x_y_min = df.apply(lambda v: min(v.x, v.y), axis=1))</code></td><td style="text-align: left"><code>transform(df, [:x, :y] =&gt; ByRow(min))</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df.assign(x_y_argmax = df.apply(lambda v: df.columns[v.argmax()], axis=1))</code></td><td style="text-align: left"><code>transform(df, AsTable([:x, :y]) =&gt; ByRow(argmax))</code></td></tr><tr><td style="text-align: left">以DataFrame作为输入</td><td style="text-align: left"><code>df.groupby(&#39;grp&#39;).head(2)</code></td><td style="text-align: left"><code>combine(d -&gt; first(d, 2), groupby(df, :grp))</code></td></tr><tr><td style="text-align: left">以DataFrame作为输出</td><td style="text-align: left"><code>df[[&#39;x&#39;]].agg(lambda x: [min(x), max(x)])</code></td><td style="text-align: left"><code>combine(df, :x =&gt; (x -&gt; (x=[minimum(x), maximum(x)],)) =&gt; AsTable)</code></td></tr></table><p>请注意，pandas在<code>groupby</code>之后保留相同的行顺序，而DataFrames.jl在<code>combine</code>操作之后按提供的键进行分组， 但<code>select</code>和<code>transform</code>保留原始的行顺序。</p><h3 id="连接数据框"><a class="docs-heading-anchor" href="#连接数据框">连接数据框</a><a id="连接数据框-1"></a><a class="docs-heading-anchor-permalink" href="#连接数据框" title="Permalink"></a></h3><p>DataFrames.jl支持类似关系数据库的连接操作。</p><table><tr><th style="text-align: left">操作</th><th style="text-align: left">pandas</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">内连接</td><td style="text-align: left"><code>pd.merge(df, df2, how = &#39;inner&#39;, on = &#39;grp&#39;)</code></td><td style="text-align: left"><code>innerjoin(df, df2, on = :grp)</code></td></tr><tr><td style="text-align: left">外连接</td><td style="text-align: left"><code>pd.merge(df, df2, how = &#39;outer&#39;, on = &#39;grp&#39;)</code></td><td style="text-align: left"><code>outerjoin(df, df2, on = :grp)</code></td></tr><tr><td style="text-align: left">左连接</td><td style="text-align: left"><code>pd.merge(df, df2, how = &#39;left&#39;, on = &#39;grp&#39;)</code></td><td style="text-align: left"><code>leftjoin(df, df2, on = :grp)</code></td></tr><tr><td style="text-align: left">右连接</td><td style="text-align: left"><code>pd.merge(df, df2, how = &#39;right&#39;, on = &#39;grp&#39;)</code></td><td style="text-align: left"><code>rightjoin(df, df2, on = :grp)</code></td></tr><tr><td style="text-align: left">半连接 (过滤)</td><td style="text-align: left"><code>df[df.grp.isin(df2.grp)]</code></td><td style="text-align: left"><code>semijoin(df, df2, on = :grp)</code></td></tr><tr><td style="text-align: left">反连接 (过滤)</td><td style="text-align: left"><code>df[~df.grp.isin(df2.grp)]</code></td><td style="text-align: left"><code>antijoin(df, df2, on = :grp)</code></td></tr></table><p>对于多列连接，pandas和DataFrames.jl都接受一个数组作为<code>on</code>关键字参数。</p><p>在半连接和反连接的情况下，pandas中的<code>isin</code>函数仍然可以使用，只要连接键以元组的形式<a href="https://stackoverflow.com/questions/63660610/how-to-perform-semi-join-with-multiple-columns-in-pandas">组合起来</a>。 在DataFrames.jl中，只需在<code>on</code>关键字参数中指定连接键的数组即可正常工作。</p><h2 id="与R包dplyr的比较"><a class="docs-heading-anchor" href="#与R包dplyr的比较">与R包dplyr的比较</a><a id="与R包dplyr的比较-1"></a><a class="docs-heading-anchor-permalink" href="#与R包dplyr的比较" title="Permalink"></a></h2><p>下表比较了DataFrames.jl的主要函数与R包dplyr（版本1）的对应关系：</p><pre><code class="language-R hljs">df &lt;- tibble(grp = rep(1:2, 3), x = 6:1, y = 4:9,
             z = c(3:7, NA), id = letters[1:6])</code></pre><table><tr><th style="text-align: left">操作</th><th style="text-align: left">dplyr</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">多值归约</td><td style="text-align: left"><code>summarize(df, mean(x))</code></td><td style="text-align: left"><code>combine(df, :x =&gt; mean)</code></td></tr><tr><td style="text-align: left">添加新列</td><td style="text-align: left"><code>mutate(df, x_mean = mean(x))</code></td><td style="text-align: left"><code>transform(df, :x =&gt; mean =&gt; :x_mean)</code></td></tr><tr><td style="text-align: left">重命名列</td><td style="text-align: left"><code>rename(df, x_new = x)</code></td><td style="text-align: left"><code>rename(df, :x =&gt; :x_new)</code></td></tr><tr><td style="text-align: left">选择列</td><td style="text-align: left"><code>select(df, x, y)</code></td><td style="text-align: left"><code>select(df, :x, :y)</code></td></tr><tr><td style="text-align: left">选择并转换列</td><td style="text-align: left"><code>transmute(df, mean(x), y)</code></td><td style="text-align: left"><code>select(df, :x =&gt; mean, :y)</code></td></tr><tr><td style="text-align: left">选择行</td><td style="text-align: left"><code>filter(df, x &gt;= 1)</code></td><td style="text-align: left"><code>subset(df, :x =&gt; ByRow(x -&gt; x &gt;= 1))</code></td></tr><tr><td style="text-align: left">排序行</td><td style="text-align: left"><code>arrange(df, x)</code></td><td style="text-align: left"><code>sort(df, :x)</code></td></tr></table><p>与dplyr类似，这些函数中的一些可以应用于分组的数据框，此时它们按组进行操作：</p><table><tr><th style="text-align: left">操作</th><th style="text-align: left">dplyr</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">多值归约</td><td style="text-align: left"><code>summarize(group_by(df, grp), mean(x))</code></td><td style="text-align: left"><code>combine(groupby(df, :grp), :x =&gt; mean)</code></td></tr><tr><td style="text-align: left">添加新列</td><td style="text-align: left"><code>mutate(group_by(df, grp), mean(x))</code></td><td style="text-align: left"><code>transform(groupby(df, :grp), :x =&gt; mean)</code></td></tr><tr><td style="text-align: left">选择并转换列</td><td style="text-align: left"><code>transmute(group_by(df, grp), mean(x), y)</code></td><td style="text-align: left"><code>select(groupby(df, :grp), :x =&gt; mean, :y)</code></td></tr></table><p>下表比较了更高级的命令：</p><table><tr><th style="text-align: left">操作</th><th style="text-align: left">dplyr</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">复杂函数</td><td style="text-align: left"><code>summarize(df, mean(x, na.rm = T))</code></td><td style="text-align: left"><code>combine(df, :x =&gt; x -&gt; mean(skipmissing(x)))</code></td></tr><tr><td style="text-align: left">转换多列数据</td><td style="text-align: left"><code>summarize(df, max(x), min(y))</code></td><td style="text-align: left"><code>combine(df, :x =&gt; maximum,  :y =&gt; minimum)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>summarize(df, across(c(x, y), mean))</code></td><td style="text-align: left"><code>combine(df, [:x, :y] .=&gt; mean)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>summarize(df, across(starts_with(&quot;x&quot;), mean))</code></td><td style="text-align: left"><code>combine(df, names(df, r&quot;^x&quot;) .=&gt; mean)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>summarize(df, across(c(x, y), list(max, min)))</code></td><td style="text-align: left"><code>combine(df, ([:x, :y] .=&gt; [maximum minimum])...)</code></td></tr><tr><td style="text-align: left">多变量函数</td><td style="text-align: left"><code>mutate(df, cor(x, y))</code></td><td style="text-align: left"><code>transform(df, [:x, :y] =&gt; cor)</code></td></tr><tr><td style="text-align: left">逐行操作</td><td style="text-align: left"><code>mutate(rowwise(df), min(x, y))</code></td><td style="text-align: left"><code>transform(df, [:x, :y] =&gt; ByRow(min))</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>mutate(rowwise(df), which.max(c_across(matches(&quot;^x&quot;))))</code></td><td style="text-align: left"><code>transform(df, AsTable(r&quot;^x&quot;) =&gt; ByRow(argmax))</code></td></tr><tr><td style="text-align: left">以DataFrame作为输入</td><td style="text-align: left"><code>summarize(df, head(across(), 2))</code></td><td style="text-align: left"><code>combine(d -&gt; first(d, 2), df)</code></td></tr><tr><td style="text-align: left">以DataFrame作为输出</td><td style="text-align: left"><code>summarize(df, tibble(value = c(min(x), max(x))))</code></td><td style="text-align: left"><code>combine(df, :x =&gt; (x -&gt; (value = [minimum(x), maximum(x)],)) =&gt; AsTable)</code></td></tr></table><h2 id="与-R-包-data.table-的比较"><a class="docs-heading-anchor" href="#与-R-包-data.table-的比较">与 R 包 data.table 的比较</a><a id="与-R-包-data.table-的比较-1"></a><a class="docs-heading-anchor-permalink" href="#与-R-包-data.table-的比较" title="Permalink"></a></h2><p>下表比较了 DataFrames.jl 的主要函数与 R 包 data.table（版本 1.14.1）的对应关系。</p><pre><code class="language-R hljs">library(data.table)
df  &lt;- data.table(grp = rep(1:2, 3), x = 6:1, y = 4:9,
                  z = c(3:7, NA), id = letters[1:6])
df2 &lt;- data.table(grp=c(1,3), w = c(10,11))</code></pre><table><tr><th style="text-align: left">操作</th><th style="text-align: left">data.table</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">多值归约</td><td style="text-align: left"><code>df[, .(mean(x))]</code></td><td style="text-align: left"><code>combine(df, :x =&gt; mean)</code></td></tr><tr><td style="text-align: left">添加新列</td><td style="text-align: left"><code>df[, x_mean:=mean(x) ]</code></td><td style="text-align: left"><code>transform!(df, :x =&gt; mean =&gt; :x_mean)</code></td></tr><tr><td style="text-align: left">重命名列（原地操作）</td><td style="text-align: left"><code>setnames(df, &quot;x&quot;, &quot;x_new&quot;)</code></td><td style="text-align: left"><code>rename!(df, :x =&gt; :x_new)</code></td></tr><tr><td style="text-align: left">重命名多列（原地操作）</td><td style="text-align: left"><code>setnames(df, c(&quot;x&quot;, &quot;y&quot;), c(&quot;x_new&quot;, &quot;y_new&quot;))</code></td><td style="text-align: left"><code>rename!(df, [:x, :y] .=&gt; [:x_new, :y_new])</code></td></tr><tr><td style="text-align: left">选择列作为 DataFrame</td><td style="text-align: left"><code>df[, .(x, y)]</code></td><td style="text-align: left"><code>select(df, :x, :y)</code></td></tr><tr><td style="text-align: left">选择列作为向量</td><td style="text-align: left"><code>df[, x]</code></td><td style="text-align: left"><code>df[!, :x]</code></td></tr><tr><td style="text-align: left">删除列</td><td style="text-align: left"><code>df[, -&quot;x&quot;]</code></td><td style="text-align: left"><code>select(df, Not(:x))</code></td></tr><tr><td style="text-align: left">删除列（原地操作）</td><td style="text-align: left"><code>df[, x:=NULL]</code></td><td style="text-align: left"><code>select!(df, Not(:x))</code></td></tr><tr><td style="text-align: left">删除多列（原地操作）</td><td style="text-align: left"><code>df[, c(&quot;x&quot;, &quot;y&quot;):=NULL]</code></td><td style="text-align: left"><code>select!(df, Not([:x, :y]))</code></td></tr><tr><td style="text-align: left">选择并转换列</td><td style="text-align: left"><code>df[, .(mean(x), y)]</code></td><td style="text-align: left"><code>select(df, :x =&gt; mean, :y)</code></td></tr><tr><td style="text-align: left">选择行</td><td style="text-align: left"><code>df[ x &gt;= 1 ]</code></td><td style="text-align: left"><code>filter(:x =&gt; &gt;=(1), df)</code></td></tr><tr><td style="text-align: left">排序行（原地操作）</td><td style="text-align: left"><code>setorder(df, x)</code></td><td style="text-align: left"><code>sort!(df, :x)</code></td></tr><tr><td style="text-align: left">排序行</td><td style="text-align: left"><code>df[ order(x) ]</code></td><td style="text-align: left"><code>sort(df, :x)</code></td></tr></table><h3 id="数据分组和聚合"><a class="docs-heading-anchor" href="#数据分组和聚合">数据分组和聚合</a><a id="数据分组和聚合-1"></a><a class="docs-heading-anchor-permalink" href="#数据分组和聚合" title="Permalink"></a></h3><table><tr><th style="text-align: left">操作</th><th style="text-align: left">data.table</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">多值归约</td><td style="text-align: left"><code>df[, mean(x), by=id ]</code></td><td style="text-align: left"><code>combine(groupby(df, :id), :x =&gt; mean)</code></td></tr><tr><td style="text-align: left">添加新列（原地操作）</td><td style="text-align: left"><code>df[, x_mean:=mean(x), by=id]</code></td><td style="text-align: left"><code>transform!(groupby(df, :id), :x =&gt; mean)</code></td></tr><tr><td style="text-align: left">选择并转换列</td><td style="text-align: left"><code>df[, .(x_mean = mean(x), y), by=id]</code></td><td style="text-align: left"><code>select(groupby(df, :id), :x =&gt; mean, :y)</code></td></tr></table><h3 id="更高级的命令-2"><a class="docs-heading-anchor" href="#更高级的命令-2">更高级的命令</a><a class="docs-heading-anchor-permalink" href="#更高级的命令-2" title="Permalink"></a></h3><table><tr><th style="text-align: left">操作</th><th style="text-align: left">data.table</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">复杂函数</td><td style="text-align: left"><code>df[, .(mean(x, na.rm=TRUE)) ]</code></td><td style="text-align: left"><code>combine(df, :x =&gt; x -&gt; mean(skipmissing(x)))</code></td></tr><tr><td style="text-align: left">转换特定行（原地操作）</td><td style="text-align: left"><code>df[x&lt;=0, x:=0]</code></td><td style="text-align: left"><code>df.x[df.x .&lt;= 0] .= 0</code></td></tr><tr><td style="text-align: left">转换多列</td><td style="text-align: left"><code>df[, .(max(x), min(y)) ]</code></td><td style="text-align: left"><code>combine(df, :x =&gt; maximum, :y =&gt; minimum)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df[, lapply(.SD, mean), .SDcols = c(&quot;x&quot;, &quot;y&quot;) ]</code></td><td style="text-align: left"><code>combine(df, [:x, :y] .=&gt; mean)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df[, lapply(.SD, mean), .SDcols = patterns(&quot;*x&quot;) ]</code></td><td style="text-align: left"><code>combine(df, names(df, r&quot;^x&quot;) .=&gt; mean)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df[, unlist(lapply(.SD, function(x) c(max=max(x), min=min(x)))), .SDcols = c(&quot;x&quot;, &quot;y&quot;) ]</code></td><td style="text-align: left"><code>combine(df, ([:x, :y] .=&gt; [maximum minimum])...)</code></td></tr><tr><td style="text-align: left">多变量函数</td><td style="text-align: left"><code>df[, .(cor(x,y)) ]</code></td><td style="text-align: left"><code>transform(df, [:x, :y] =&gt; cor)</code></td></tr><tr><td style="text-align: left">逐行操作</td><td style="text-align: left"><code>df[, min_xy := min(x, y), by = 1:nrow(df)]</code></td><td style="text-align: left"><code>transform!(df, [:x, :y] =&gt; ByRow(min))</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>df[, argmax_xy := which.max(.SD) , .SDcols = patterns(&quot;*x&quot;), by = 1:nrow(df) ]</code></td><td style="text-align: left"><code>transform!(df, AsTable(r&quot;^x&quot;) =&gt; ByRow(argmax))</code></td></tr><tr><td style="text-align: left">输出为 DataFrame</td><td style="text-align: left"><code>df[, .SD[1], by=grp]</code></td><td style="text-align: left"><code>combine(groupby(df, :grp), first)</code></td></tr><tr><td style="text-align: left">输出为 DataFrame</td><td style="text-align: left"><code>df[, .SD[which.max(x)], by=grp]</code></td><td style="text-align: left"><code>combine(groupby(df, :grp), sdf -&gt; sdf[argmax(sdf.x), :])</code></td></tr></table><h3 id="连接数据框-2"><a class="docs-heading-anchor" href="#连接数据框-2">连接数据框</a><a class="docs-heading-anchor-permalink" href="#连接数据框-2" title="Permalink"></a></h3><table><tr><th style="text-align: left">操作</th><th style="text-align: left">data.table</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">内连接</td><td style="text-align: left"><code>merge(df, df2, on = &quot;grp&quot;)</code></td><td style="text-align: left"><code>innerjoin(df, df2, on = :grp)</code></td></tr><tr><td style="text-align: left">外连接</td><td style="text-align: left"><code>merge(df, df2, all = TRUE, on = &quot;grp&quot;)</code></td><td style="text-align: left"><code>outerjoin(df, df2, on = :grp)</code></td></tr><tr><td style="text-align: left">左连接</td><td style="text-align: left"><code>merge(df, df2, all.x = TRUE, on = &quot;grp&quot;)</code></td><td style="text-align: left"><code>leftjoin(df, df2, on = :grp)</code></td></tr><tr><td style="text-align: left">右连接</td><td style="text-align: left"><code>merge(df, df2, all.y = TRUE, on = &quot;grp&quot;)</code></td><td style="text-align: left"><code>rightjoin(df, df2, on = :grp)</code></td></tr><tr><td style="text-align: left">反连接（过滤）</td><td style="text-align: left"><code>df[!df2, on = &quot;grp&quot; ]</code></td><td style="text-align: left"><code>antijoin(df, df2, on = :grp)</code></td></tr><tr><td style="text-align: left">半连接（过滤）</td><td style="text-align: left"><code>merge(df1, df2[, .(grp)])</code></td><td style="text-align: left"><code>semijoin(df, df2, on = :grp)</code></td></tr></table><h2 id="与-Stata（8-版及以上版本）的比较"><a class="docs-heading-anchor" href="#与-Stata（8-版及以上版本）的比较">与 Stata（8 版及以上版本）的比较</a><a id="与-Stata（8-版及以上版本）的比较-1"></a><a class="docs-heading-anchor-permalink" href="#与-Stata（8-版及以上版本）的比较" title="Permalink"></a></h2><p>下表比较了 DataFrames.jl 的主要功能与 Stata 的对应关系：</p><table><tr><th style="text-align: left">操作</th><th style="text-align: left">Stata</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">多值合并</td><td style="text-align: left"><code>collapse (mean) x</code></td><td style="text-align: left"><code>combine(df, :x =&gt; mean)</code></td></tr><tr><td style="text-align: left">添加新列</td><td style="text-align: left"><code>egen x_mean = mean(x)</code></td><td style="text-align: left"><code>transform!(df, :x =&gt; mean =&gt; :x_mean)</code></td></tr><tr><td style="text-align: left">重命名列</td><td style="text-align: left"><code>rename x x_new</code></td><td style="text-align: left"><code>rename!(df, :x =&gt; :x_new)</code></td></tr><tr><td style="text-align: left">选择列</td><td style="text-align: left"><code>keep x y</code></td><td style="text-align: left"><code>select!(df, :x, :y)</code></td></tr><tr><td style="text-align: left">选择行</td><td style="text-align: left"><code>keep if x &gt;= 1</code></td><td style="text-align: left"><code>subset!(df, :x =&gt; ByRow(x -&gt; x &gt;= 1))</code></td></tr><tr><td style="text-align: left">排序行</td><td style="text-align: left"><code>sort x</code></td><td style="text-align: left"><code>sort!(df, :x)</code></td></tr></table><p>需要注意的是后缀 <code>!</code>（例如 <code>transform!</code>、<code>select!</code> 等）表示操作会直接在原始数据框上进行修改，与 Stata 中的操作方式类似。</p><p>其中一些函数可以应用于分组数据框，此时它们将按组进行操作：</p><table><tr><th style="text-align: left">操作</th><th style="text-align: left">Stata</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">添加新列</td><td style="text-align: left"><code>egen x_mean = mean(x), by(grp)</code></td><td style="text-align: left"><code>transform!(groupby(df, :grp), :x =&gt; mean)</code></td></tr><tr><td style="text-align: left">多值合并</td><td style="text-align: left"><code>collapse (mean) x, by(grp)</code></td><td style="text-align: left"><code>combine(groupby(df, :grp), :x =&gt; mean)</code></td></tr></table><p>下表比较了更高级的命令：</p><table><tr><th style="text-align: left">操作</th><th style="text-align: left">Stata</th><th style="text-align: left">DataFrames.jl</th></tr><tr><td style="text-align: left">转换特定行</td><td style="text-align: left"><code>replace x = 0 if x &lt;= 0</code></td><td style="text-align: left"><code>transform(df, :x =&gt; (x -&gt; ifelse.(x .&lt;= 0, 0, x)) =&gt; :x)</code></td></tr><tr><td style="text-align: left">转换多个列</td><td style="text-align: left"><code>collapse (max) x (min) y</code></td><td style="text-align: left"><code>combine(df, :x =&gt; maximum,  :y =&gt; minimum)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>collapse (mean) x y</code></td><td style="text-align: left"><code>combine(df, [:x, :y] .=&gt; mean)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>collapse (mean) x*</code></td><td style="text-align: left"><code>combine(df, names(df, r&quot;^x&quot;) .=&gt; mean)</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>collapse (max) x y (min) x y</code></td><td style="text-align: left"><code>combine(df, ([:x, :y] .=&gt; [maximum minimum])...)</code></td></tr><tr><td style="text-align: left">多变量函数</td><td style="text-align: left"><code>egen z = corr(x y)</code></td><td style="text-align: left"><code>transform!(df, [:x, :y] =&gt; cor =&gt; :z)</code></td></tr><tr><td style="text-align: left">逐行处理</td><td style="text-align: left"><code>egen z = rowmin(x y)</code></td><td style="text-align: left"><code>transform!(df, [:x, :y] =&gt; ByRow(min) =&gt; :z)</code></td></tr></table></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../querying_frameworks/">« Data manipulation frameworks</a><a class="docs-footer-nextpage" href="../../lib/types/">Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 15 December 2023 13:32">Friday 15 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
