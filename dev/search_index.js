var documenterSearchIndex = {"docs":
[{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"warning: Internal API\nThe functions, methods and types listed on this page are internal to DataFrames and are not considered to be part of the public API.","category":"page"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"compacttype\ngennames\ngetmaxwidths\nourshow\nourstrwidth\n@spawn_for_chunks\n@spawn_or_run_task\n@spawn_or_run\ndefault_table_transformation\nisreadonly","category":"page"},{"location":"lib/internals/#DataFrames.compacttype","page":"Internals","title":"DataFrames.compacttype","text":"compacttype(T::Type, maxwidth::Int=8, initial::Bool=true)\n\nReturn compact string representation of type T.\n\nFor displaying data frame we do not want string representation of type to be longer than maxwidth. This function implements rules how type names are cropped if they are longer than maxwidth.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DataFrames.gennames","page":"Internals","title":"DataFrames.gennames","text":"gennames(n::Integer)\n\nGenerate standardized names for columns of a DataFrame. The first name will be :x1, the second :x2, etc.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DataFrames.getmaxwidths","page":"Internals","title":"DataFrames.getmaxwidths","text":"DataFrames.getmaxwidths(df::AbstractDataFrame,\n                        io::IO,\n                        rowindices1::AbstractVector{Int},\n                        rowindices2::AbstractVector{Int},\n                        rowlabel::Symbol,\n                        rowid::Union{Integer, Nothing},\n                        show_eltype::Bool,\n                        buffer::IOBuffer)\n\nCalculate, for each column of an AbstractDataFrame, the maximum string width used to render the name of that column, its type, and the longest entry in that column – among the rows of the data frame will be rendered to IO. The widths for all columns are returned as a vector.\n\nReturn a Vector{Int} giving the maximum string widths required to render each column, including that column's name and type.\n\nNOTE: The last entry of the result vector is the string width of the implicit row ID column contained in every AbstractDataFrame.\n\nArguments\n\ndf::AbstractDataFrame: The data frame whose columns will be printed.\nio::IO: The IO to which df is to be printed\n`rowindices1::AbstractVector{Int}: A set of indices of the first chunk of the AbstractDataFrame that would be rendered to IO.\n`rowindices2::AbstractVector{Int}: A set of indices of the second chunk of the AbstractDataFrame that would be rendered to IO. Can be empty if the AbstractDataFrame would be printed without any ellipses.\nrowlabel::AbstractString: The label that will be used when rendered the numeric ID's of each row. Typically, this will be set to \"Row\".\nrowid: Used to handle showing DataFrameRow.\nshow_eltype: Whether to print the column type  under the column name in the heading.\nbuffer: buffer passed around to avoid reallocations in ourstrwidth\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DataFrames.ourshow","page":"Internals","title":"DataFrames.ourshow","text":"DataFrames.ourshow(io::IO, x::Any, truncstring::Int)\n\nRender a value to an IO object compactly using print. truncstring indicates the approximate number of text characters width to truncate the output (if it is a non-positive value then no truncation is applied).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DataFrames.ourstrwidth","page":"Internals","title":"DataFrames.ourstrwidth","text":"DataFrames.ourstrwidth(io::IO, x::Any, buffer::IOBuffer, truncstring::Int)\n\nDetermine the number of characters that would be used to print a value.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DataFrames.@spawn_for_chunks","page":"Internals","title":"DataFrames.@spawn_for_chunks","text":"@spawn_for_chunks basesize for i in range ... end\n\nParallelize a for loop by spawning separate tasks iterating each over a chunk of at least basesize elements in range.\n\nA number of tasks higher than Threads.nthreads() may be spawned, since that can allow for a more efficient load balancing in case some threads are busy (nested parallelism).\n\n\n\n\n\n","category":"macro"},{"location":"lib/internals/#DataFrames.@spawn_or_run_task","page":"Internals","title":"DataFrames.@spawn_or_run_task","text":"@spawn_or_run_task threads expr\n\nEquivalent to Threads.@spawn if threads === true, otherwise run expr and return a Task that returns its value.\n\n\n\n\n\n","category":"macro"},{"location":"lib/internals/#DataFrames.@spawn_or_run","page":"Internals","title":"DataFrames.@spawn_or_run","text":"@spawn_or_run threads expr\n\nEquivalent to Threads.@spawn if threads === true, otherwise run expr.\n\n\n\n\n\n","category":"macro"},{"location":"lib/internals/#DataFrames.default_table_transformation","page":"Internals","title":"DataFrames.default_table_transformation","text":"default_table_transformation(df_sel::AbstractDataFrame, fun)\n\nThis is a default implementation called when AsTable(...) => fun is requested. The df_sel argument is a data frame storing columns selected by AsTable(...) selector.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#DataFrames.isreadonly","page":"Internals","title":"DataFrames.isreadonly","text":"isreadonly(fun)\n\nTrait returning a Bool indicator if function fun is only reading the passed argument. Such a function guarantees not to modify nor return in any form the passed argument. By default false is returned.\n\nThis function might become a part of the public API of DataFrames.jl in the future, currently it should be considered experimental. Adding a method to isreadonly for a specific function fun will improve performance of AsTable(...) => ByRow(fun∘collect) operation.\n\n\n\n\n\n","category":"function"},{"location":"man/basics/#使用DataFrames.jl的第一步","page":"First Steps with DataFrames.jl","title":"使用DataFrames.jl的第一步","text":"","category":"section"},{"location":"man/basics/#设置环境","page":"First Steps with DataFrames.jl","title":"设置环境","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如果你想使用DataFrames.jl包，你需要首先安装它。 你可以使用以下命令来进行安装：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using Pkg\n\njulia> Pkg.add(\"DataFrames\")","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"或者","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> ] # 按下 ']'\n\n(@v1.9) pkg> add DataFrames","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如果你想确保一切都按预期工作，你可以运行与DataFrames.jl捆绑的测试， 但请注意，这将需要超过30分钟：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using Pkg\n\njulia> Pkg.test(\"DataFrames\") # 警告！这将需要超过30分钟。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"另外，建议使用status命令检查你已安装的DataFrames.jl的版本。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> ]\n\n(@v1.9) pkg> status DataFrames\n      Status `~\\v1.6\\Project.toml`\n  [a93c6f00] DataFrames v1.5.0","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在本教程的其余部分，我们将假设你已经安装了DataFrames.jl包，并已经键入using DataFrames来加载包：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using DataFrames","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"DataFrames.jl提供的最基本的类型是DataFrame，其中通常每行被解释为一个观察，每列被解释为一个特征。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"note: 高级安装配置\n在构建（预编译）包时，DataFrames.jl会投入额外的时间和努力，以确保在你使用它时它更具响应性。 然而，在某些情况下，用户可能希望避免这种额外的预编译工作，以减少构建包和后来加载它所需的时间。 要在你当前的项目中禁用DataFrames.jl的预编译，请按照PrecompileTools.jl文档中给出的指示操作。","category":"page"},{"location":"man/basics/#构造函数和基本实用函数","page":"First Steps with DataFrames.jl","title":"构造函数和基本实用函数","text":"","category":"section"},{"location":"man/basics/#构造函数","page":"First Steps with DataFrames.jl","title":"构造函数","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在本节中，你将看到使用构造函数创建DataFrame的几种方式。你可以在DataFrame对象的文档中找到支持的构造函数的详细列表，以及更多的示例。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"我们首先创建一个空的DataFrame：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame()\n0×0 DataFrame","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"现在让我们初始化一个包含多个列的DataFrame。基本的方式如下：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame(A=1:3, B=5:7, fixed=1)\n3×3 DataFrame\n Row │ A      B      fixed\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      5      1\n   2 │     2      6      1\n   3 │     3      7      1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"注意，使用这个构造函数时，标量（如列:fixed的1）会自动广播以填充创建的DataFrame的所有行。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"有时候，你需要创建一个其列名不是有效的Julia标识符的数据帧。在这种情况下，下面的形式，其中=被=>替换，会很方便：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame(\"customer age\" => [15, 20, 25],\n                 \"first name\" => [\"Rohit\", \"Rahul\", \"Akshat\"])\n3×2 DataFrame\n Row │ customer age  first name\n     │ Int64         String\n─────┼──────────────────────────\n   1 │           15  Rohit\n   2 │           20  Rahul\n   3 │           25  Akshat","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"注意，这次我们将列名作为字符串传递。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"你的源数据通常存储在字典中。 只要字典的键是字符串或Symbol，你也可以轻松地从中创建DataFrame：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> dict = Dict(\"customer age\" => [15, 20, 25],\n                   \"first name\" => [\"Rohit\", \"Rahul\", \"Akshat\"])\nDict{String, Vector} with 2 entries:\n  \"first name\"   => [\"Rohit\", \"Rahul\", \"Akshat\"]\n  \"customer age\" => [15, 20, 25]\n\njulia> DataFrame(dict)\n3×2 DataFrame\n Row │ customer age  first name\n     │ Int64         String\n─────┼──────────────────────────\n   1 │           15  Rohit\n   2 │           20  Rahul\n   3 │           25  Akshat\n\njulia> dict = Dict(:customer_age => [15, 20, 25],\n                   :first_name => [\"Rohit\", \"Rahul\", \"Akshat\"])\nDict{Symbol, Vector} with 2 entries:\n  :customer_age => [15, 20, 25]\n  :first_name   => [\"Rohit\", \"Rahul\", \"Akshat\"]\n\njulia> DataFrame(dict)\n3×2 DataFrame\n Row │ customer_age  first_name\n     │ Int64         String\n─────┼──────────────────────────\n   1 │           15  Rohit\n   2 │           20  Rahul\n   3 │           25  Akshat","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"使用Symbol，例如:customer_age，而不是字符串，例如\"customer age\"，来表示列名是首选的，因为它更快。然而，如你在上面的例子中看到的，如果我们的列名包含一个空格，将它作为一个Symbol传递并不方便（你必须写成Symbol(\"customer age\")，这很冗长），所以使用字符串更方便。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"从向量的NamedTuple或NamedTuple的向量创建DataFrame也很常见。下面是这些操作的一些示例：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame((a=[1, 2], b=[3, 4]))\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> DataFrame([(a=1, b=0), (a=2, b=0)])\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Sometimes your source data might have a heterogeneous set of columns for each observation. Here is an example:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> source = [(type=\"circle\", radius=10), (type=\"square\", side=20)]\n2-element Vector{NamedTuple{names, Tuple{String, Int64}} where names}:\n (type = \"circle\", radius = 10)\n (type = \"square\", side = 20)","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"If you want to create a data frame from such data containing all columns present in at least one of the source observations, with a missing entry if some column is not present then you can use Tables.dictcolumntable function to help you create the desired data frame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame(Tables.dictcolumntable(source))\n2×3 DataFrame\n Row │ type    radius   side\n     │ String  Int64?   Int64?\n─────┼──────────────────────────\n   1 │ circle       10  missing\n   2 │ square  missing       20","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The role of Tables.dictcolumntable is to make sure that the DataFrame constructor gets information about all columns present in the source data and properly instantiates them. If we did not use this function the DataFrame constructor would assume that the first row of data contains the set of columns present in the source, which would lead to an error in our example:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame(source)\nERROR: type NamedTuple has no field radius","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Sometimes your source data might have a heterogeneous set of columns for each observation. Here is an example:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> source = [(type=\"circle\", radius=10), (type=\"square\", side=20)]\n2-element Vector{NamedTuple{names, Tuple{String, Int64}} where names}:\n (type = \"circle\", radius = 10)\n (type = \"square\", side = 20)","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"If you want to create a data frame from such data containing all columns present in at least one of the source observations, with a missing entry if some column is not present then you can use Tables.dictcolumntable function to help you create the desired data frame:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame(Tables.dictcolumntable(source))\n2×3 DataFrame\n Row │ type    radius   side\n     │ String  Int64?   Int64?\n─────┼──────────────────────────\n   1 │ circle       10  missing\n   2 │ square  missing       20","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"The role of Tables.dictcolumntable is to make sure that the DataFrame constructor gets information about all columns present in the source data and properly instantiates them. If we did not use this function the DataFrame constructor would assume that the first row of data contains the set of columns present in the source, which would lead to an error in our example:","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame(source)\nERROR: type NamedTuple has no field radius","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"让我们通过展示如何从矩阵创建DataFrame来结束构造函数的复习。在这种情况下，你将矩阵作为第一个参数传递。如果第二个参数只是:auto，那么列名x1，x2，...将会自动生成。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> DataFrame([1 0; 2 0], :auto)\n2×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"或者，你可以将列名的向量作为第二个参数传递给DataFrame构造函数：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> mat = [1 2 4 5; 15 58 69 41; 23 21 26 69]\n3×4 Matrix{Int64}:\n  1   2   4   5\n 15  58  69  41\n 23  21  26  69\n\njulia> nms = [\"a\", \"b\", \"c\", \"d\"]\n4-element Vector{String}:\n \"a\"\n \"b\"\n \"c\"\n \"d\"\n\njulia> DataFrame(mat, nms)\n3×4 DataFrame\n Row │ a      b      c      d\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      4      5\n   2 │    15     58     69     41\n   3 │    23     21     26     69","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"现在你知道如何从你的Julia会话中已经有的数据创建DataFrame。在下一节中，我们将展示如何从磁盘加载数据到DataFrame。","category":"page"},{"location":"man/basics/#从CSV文件中读取数据","page":"First Steps with DataFrames.jl","title":"从CSV文件中读取数据","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"这里我们关注最常见的场景，即数据存储在硬盘上的CSV格式。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"首先确保你已经安装了CSV.jl。你可以按照以下指示进行安装：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using Pkg\n\njulia> Pkg.add(\"CSV\")","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"为了读取文件，我们将使用CSV.read函数。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using CSV\n\njulia> path = joinpath(pkgdir(DataFrames), \"docs\", \"src\", \"assets\", \"german.csv\");\n\njulia> german_ref = CSV.read(path, DataFrame)\n1000×10 DataFrame\n  Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking accou ⋯\n      │ Int64  Int64  String7  Int64  String7  String15         String15       ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0     67  male         2  own      NA               little         ⋯\n    2 │     1     22  female       2  own      little           moderate\n    3 │     2     49  male         1  own      little           NA\n    4 │     3     45  male         2  free     little           little\n    5 │     4     53  male         2  free     little           little         ⋯\n    6 │     5     35  male         1  free     NA               NA\n    7 │     6     53  male         2  own      quite rich       NA\n    8 │     7     35  male         3  rent     little           moderate\n  ⋮   │   ⋮      ⋮       ⋮       ⋮       ⋮            ⋮                ⋮       ⋱\n  994 │   993     30  male         3  own      little           little         ⋯\n  995 │   994     50  male         2  own      NA               NA\n  996 │   995     31  female       1  own      little           NA\n  997 │   996     40  male         3  own      little           little\n  998 │   997     38  male         2  own      little           NA             ⋯\n  999 │   998     23  male         2  free     little           little\n 1000 │   999     27  male         2  own      moderate         moderate\n                                                  4 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如你所见，数据框比显示宽度更宽更高，因此它被剪裁，其最右边的4列和中间的985行未被打印。稍后在教程中，我们将讨论如何强制Julia显示整个数据框（如果我们需要的话）。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"另外请注意，DataFrames.jl在列名下方显示了列的数据类型。在我们的例子中，它是Int64，或者String7和String15。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"让我们在这里提到Julia中标准的String类型和例如String7或String15类型之间的区别。带有数字后缀的类型表示具有固定宽度的字符串（类似于许多数据库提供的CHAR(N)类型）。这种字符串的处理速度要比标准的String类型快得多（特别是如果你有很多这样的字符串），因为它们的实例不是在堆上分配的。出于这个原因，CSV.read默认使用这些固定宽度类型读取狭窄的字符串列。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"现在让我们详细解释以下代码块：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"path = joinpath(pkgdir(DataFrames), \"docs\", \"src\", \"assets\", \"german.csv\");\n\ngerman_ref = CSV.read(path, DataFrame)","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"我们将german.csv文件存储在DataFrames.jl仓库中，以便使用户的生活更轻松，避免每次都需要下载它；\npkgdir(DataFrames)给我们提供了到DataFrames.jl包根目录的完整路径。\n然后从这个目录，我们需要移动到存储german.csv文件的目录；我们使用joinpath，因为这是在操作系统中独立地组合硬盘上资源的路径的推荐方式（记住，Windows和Unix的路径分隔符不同，它们使用/或\\作为路径分隔符；joinpath函数确保我们不会因此遇到问题）；\n然后我们读取CSV文件；CSV.read的第二个参数是DataFrame，表示我们想要将文件读入一个DataFrame（因为CSV.read允许读入许多不同的目标数据格式）。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在继续之前，复制参考数据框：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german = copy(german_ref); # 我们复制数据框","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"通过这种方式，即使我们通过修改german数据框弄乱了数据，我们也可以轻松地恢复我们的数据。","category":"page"},{"location":"man/basics/#对数据框进行基本操作","page":"First Steps with DataFrames.jl","title":"对数据框进行基本操作","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"要直接提取数据框的列（即不进行复制），你可以使用以下语法之一： german.Sex，german.\"Sex\"，german[!, :Sex] 或 german[!, \"Sex\"]。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"后两种使用索引的语法更为灵活，因为它们允许我们传递一个变量来存储列的名称，而不仅仅是使用 . 的语法中的文字名称。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german.Sex\n1000-element PooledArrays.PooledVector{String7, UInt32, Vector{UInt32}}:\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n ⋮\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n\njulia> colname = \"Sex\"\n\"Sex\"\n\njulia> german[!, colname]\n1000-element PooledArrays.PooledVector{String7, UInt32, Vector{UInt32}}:\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n ⋮\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"由于 german.Sex 在提取数据框的列时不会复制，因此改变此操作返回的向量的元素将影响存储在原始 german 数据框中的值。要获取列的副本，你可以使用 german[:, :Sex] 或 german[:, \"Sex\"]。在这种情况下，改变此操作返回的向量不会影响存储在 german 数据框中的数据。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"=== 函数允许我们检查两个表达式是否生成了相同的对象，并确认上述行为：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german.Sex === german[!, :Sex]\ntrue\n\njulia> german.Sex === german[:, :Sex]\nfalse","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"你可以使用 names 函数获取数据框的列名向量，列名为 String：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> names(german)\n10-element Vector{String}:\n \"id\"\n \"Age\"\n \"Sex\"\n \"Job\"\n \"Housing\"\n \"Saving accounts\"\n \"Checking account\"\n \"Credit amount\"\n \"Duration\"\n \"Purpose\"","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"有时你可能对满足特定条件的列名感兴趣。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"例如，你可以通过将此类型作为 names 函数的第二个参数来获取具有给定元素类型的列名：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> names(german, AbstractString)\n5-element Vector{String}:\n \"Sex\"\n \"Housing\"\n \"Saving accounts\"\n \"Checking account\"\n \"Purpose\"","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"你可以在 names 函数的文档中探索更多过滤列名的选项。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如果你想将数据框的列名作为 Symbol 获取，可以使用 propertynames 函数：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> propertynames(german)\n10-element Vector{Symbol}:\n :id\n :Age\n :Sex\n :Job\n :Housing\n Symbol(\"Saving accounts\")\n Symbol(\"Checking account\")\n Symbol(\"Credit amount\")\n :Duration\n :Purpose","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如你所见，包含空格的列名作为 Symbol 使用并不方便，因为它们需要更多的输入并引入了一些视觉噪声。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如果你对列的元素类型感兴趣，你可以使用 eachcol(german) 函数获取数据框列的迭代器。然后，你可以对其进行广播 eltype 函数以获得所需的结果：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> eltype.(eachcol(german))\n10-element Vector{DataType}:\n Int64\n Int64\n String7\n Int64\n String7\n String15\n String15\n Int64\n Int64\n String31","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"note: Note\n请记住，DataFrames.jl 允许使用 Symbol（如 :id）和字符串（如 \"id\"）进行所有列索引操作以方便使用。然而，使用 Symbol 稍微快一些，但是当列名中存在非标准字符或者你想要操作它们时，字符串更简单。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在我们结束之前，让我们讨论 empty 和 empty! 函数，这两个函数会从 DataFrame 中移除所有行。理解这两个函数行为的差异将帮助你理解 DataFrames.jl 中的函数命名方案。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"让我们从使用 empty 和 empty! 函数的例子开始：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> empty(german)\n0×10 DataFrame\n Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking accoun ⋯\n     │ Int64  Int64  String7  Int64  String7  String15         String15        ⋯\n─────┴──────────────────────────────────────────────────────────────────────────\n                                                               4 columns omitted\n\njulia> german\n1000×10 DataFrame\n  Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking accou ⋯\n      │ Int64  Int64  String7  Int64  String7  String15         String15       ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0     67  male         2  own      NA               little         ⋯\n    2 │     1     22  female       2  own      little           moderate\n    3 │     2     49  male         1  own      little           NA\n    4 │     3     45  male         2  free     little           little\n    5 │     4     53  male         2  free     little           little         ⋯\n    6 │     5     35  male         1  free     NA               NA\n    7 │     6     53  male         2  own      quite rich       NA\n    8 │     7     35  male         3  rent     little           moderate\n  ⋮   │   ⋮      ⋮       ⋮       ⋮       ⋮            ⋮                ⋮       ⋱\n  994 │   993     30  male         3  own      little           little         ⋯\n  995 │   994     50  male         2  own      NA               NA\n  996 │   995     31  female       1  own      little           NA\n  997 │   996     40  male         3  own      little           little\n  998 │   997     38  male         2  own      little           NA             ⋯\n  999 │   998     23  male         2  free     little           little\n 1000 │   999     27  male         2  own      moderate         moderate\n                                                  4 columns and 985 rows omitted\n\njulia> empty!(german)\n0×10 DataFrame\n Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking accoun ⋯\n     │ Int64  Int64  String7  Int64  String7  String15         String15        ⋯\n─────┴──────────────────────────────────────────────────────────────────────────\n                                                               4 columns omitted\n\njulia> german\n0×10 DataFrame\n Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking accoun ⋯\n     │ Int64  Int64  String7  Int64  String7  String15         String15        ⋯\n─────┴──────────────────────────────────────────────────────────────────────────\n                                                               4 columns omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在上述示例中，empty 函数创建了一个新的 DataFrame，其列名和列元素类型与 german 相同，但没有行。另一方面，empty! 函数在原地从 german 中移除了所有行，并使其每一列都为空。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"empty 和 empty! 函数行为的差异是应用了 Julia 语言中的风格约定。DataFrames.jl 包提供的所有函数都遵循这一约定。","category":"page"},{"location":"man/basics/#获取DataFrame的基本信息","page":"First Steps with DataFrames.jl","title":"获取DataFrame的基本信息","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在这一部分，我们将了解如何获取我们的german DataFrame的基本信息：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"size函数返回数据框的维度。首先我们恢复german数据框，因为我们刚刚在上面清空了它。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german = copy(german_ref);\n\njulia> size(german)\n(1000, 10)\n\njulia> size(german, 1)\n1000\n\njulia> size(german, 2)\n10","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"此外，nrow和ncol函数可以用来获取数据框的行数和列数：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> nrow(german)\n1000\n\njulia> ncol(german)\n10","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"要获取数据框中的数据的基本统计信息，使用describe函数（查看describe的帮助以了解如何自定义显示的统计信息）。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> describe(german)\n10×7 DataFrame\n Row │ variable          mean     min       median  max              nmissing  ⋯\n     │ Symbol            Union…   Any       Union…  Any              Int64     ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ id                499.5    0         499.5   999                     0  ⋯\n   2 │ Age               35.546   19        33.0    75                      0\n   3 │ Sex                        female            male                    0\n   4 │ Job               1.904    0         2.0     3                       0\n   5 │ Housing                    free              rent                    0  ⋯\n   6 │ Saving accounts            NA                rich                    0\n   7 │ Checking account           NA                rich                    0\n   8 │ Credit amount     3271.26  250       2319.5  18424                   0\n   9 │ Duration          20.903   4         18.0    72                      0  ⋯\n  10 │ Purpose                    business          vacation/others         0\n                                                                1 column omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"要限制describe处理的列，使用cols关键字参数，例如：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> describe(german, cols=1:3)\n3×7 DataFrame\n Row │ variable  mean    min     median  max   nmissing  eltype\n     │ Symbol    Union…  Any     Union…  Any   Int64     DataType\n─────┼────────────────────────────────────────────────────────────\n   1 │ id        499.5   0       499.5   999          0  Int64\n   2 │ Age       35.546  19      33.0    75           0  Int64\n   3 │ Sex               female          male         0  String7","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"默认报告的统计量是平均值、最小值、中位数、最大值、缺失值的数量以及列的元素类型。在计算摘要统计时，会跳过missing值。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"你可以通过手动调用show函数来调整数据框的显示方式：show(german, allrows=true)会打印所有行，即使它们无法在屏幕上显示，show(german, allcols=true)对列也会做同样的处理，例如：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> show(german, allcols=true)\n1000×10 DataFrame\n  Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking account  Credit amount  Duration  Purpose\n      │ Int64  Int64  String7  Int64  String7  String15         String15          Int64          Int64     String31\n──────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n    1 │     0     67  male         2  own      NA               little                     1169         6  radio/TV\n    2 │     1     22  female       2  own      little           moderate                   5951        48  radio/TV\n    3 │     2     49  male         1  own      little           NA                         2096        12  education\n    4 │     3     45  male         2  free     little           little                     7882        42  furniture/equipment\n    5 │     4     53  male         2  free     little           little                     4870        24  car\n    6 │     5     35  male         1  free     NA               NA                         9055        36  education\n    7 │     6     53  male         2  own      quite rich       NA                         2835        24  furniture/equipment\n    8 │     7     35  male         3  rent     little           moderate                   6948        36  car\n  ⋮   │   ⋮      ⋮       ⋮       ⋮       ⋮            ⋮                ⋮                ⋮           ⋮               ⋮\n  994 │   993     30  male         3  own      little           little                     3959        36  furniture/equipment\n  995 │   994     50  male         2  own      NA               NA                         2390        12  car\n  996 │   995     31  female       1  own      little           NA                         1736        12  furniture/equipment\n  997 │   996     40  male         3  own      little           little                     3857        30  car\n  998 │   997     38  male         2  own      little           NA                          804        12  radio/TV\n  999 │   998     23  male         2  free     little           little                     1845        45  radio/TV\n 1000 │   999     27  male         2  own      moderate         moderate                   4576        45  car\n                                                                                                               985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"直接在单个列上计算描述性统计量非常容易，只需使用在Statistics模块中定义的函数：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using Statistics\n\njulia> mean(german.Age)\n35.546","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如果我们想对数据框的所有列应用某个函数，我们可以使用mapcols函数。它返回一个DataFrame，其中源数据框的每一列都通过第一个参数传递的函数进行转换。请注意，mapcols保证不会在返回的DataFrame中重用german的列。如果转换返回其参数，那么在存储之前会先复制它。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> mapcols(id -> id .^ 2, german)\n1000×10 DataFrame\n  Row │ id      Age    Sex           Job    Housing   Saving accounts       Ch ⋯\n      │ Int64   Int64  String        Int64  String    String                St ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │      0   4489  malemale          4  ownown    NANA                  li ⋯\n    2 │      1    484  femalefemale      4  ownown    littlelittle          mo\n    3 │      4   2401  malemale          1  ownown    littlelittle          NA\n    4 │      9   2025  malemale          4  freefree  littlelittle          li\n    5 │     16   2809  malemale          4  freefree  littlelittle          li ⋯\n    6 │     25   1225  malemale          1  freefree  NANA                  NA\n    7 │     36   2809  malemale          4  ownown    quite richquite rich  NA\n    8 │     49   1225  malemale          9  rentrent  littlelittle          mo\n  ⋮   │   ⋮       ⋮         ⋮          ⋮       ⋮               ⋮               ⋱\n  994 │ 986049    900  malemale          9  ownown    littlelittle          li ⋯\n  995 │ 988036   2500  malemale          4  ownown    NANA                  NA\n  996 │ 990025    961  femalefemale      1  ownown    littlelittle          NA\n  997 │ 992016   1600  malemale          9  ownown    littlelittle          li\n  998 │ 994009   1444  malemale          4  ownown    littlelittle          NA ⋯\n  999 │ 996004    529  malemale          4  freefree  littlelittle          li\n 1000 │ 998001    729  malemale          4  ownown    moderatemoderate      mo\n                                                  4 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如果你想查看数据框的第一行和最后一行，那么你可以使用first和last函数分别进行操作：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> first(german, 6)\n6×10 DataFrame\n Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking accoun ⋯\n     │ Int64  Int64  String7  Int64  String7  String15         String15        ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     0     67  male         2  own      NA               little          ⋯\n   2 │     1     22  female       2  own      little           moderate\n   3 │     2     49  male         1  own      little           NA\n   4 │     3     45  male         2  free     little           little\n   5 │     4     53  male         2  free     little           little          ⋯\n   6 │     5     35  male         1  free     NA               NA\n                                                               4 columns omitted\n\njulia> last(german, 5)\n5×10 DataFrame\n Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking accoun ⋯\n     │ Int64  Int64  String7  Int64  String7  String15         String15        ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │   995     31  female       1  own      little           NA              ⋯\n   2 │   996     40  male         3  own      little           little\n   3 │   997     38  male         2  own      little           NA\n   4 │   998     23  male         2  free     little           little\n   5 │   999     27  male         2  own      moderate         moderate        ⋯\n                                                               4 columns omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如果不传递行数，使用first和last将返回数据框中的第一/最后一个DataFrameRow。DataFrameRow是AbstractDataFrame的单行视图。它存储了对父DataFrame的引用以及从父数据框中选择的行和列的信息。你可以将DataFrameRow看作是可变的NamedTuple，即允许更新源数据框，这通常很有用。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> first(german)\nDataFrameRow\n Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking accoun ⋯\n     │ Int64  Int64  String7  Int64  String7  String15         String15        ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     0     67  male         2  own      NA               little          ⋯\n                                                               4 columns omitted\n\njulia> last(german)\nDataFrameRow\n  Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking accou ⋯\n      │ Int64  Int64  String7  Int64  String7  String15         String15       ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n 1000 │   999     27  male         2  own      moderate         moderate       ⋯\n                                                               4 columns omitted","category":"page"},{"location":"man/basics/#获取和设置数据框中的数据","page":"First Steps with DataFrames.jl","title":"获取和设置数据框中的数据","text":"","category":"section"},{"location":"man/basics/#索引语法","page":"First Steps with DataFrames.jl","title":"索引语法","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"数据框可以类似于矩阵的方式进行索引。在手册的Indexing部分，你可以找到所有可用选项的详细信息。在这里，我们只强调基本的几种。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"一般的索引语法是data_frame[selected_rows, selected_columns]。请注意，与Julia Base中的矩阵不同，这里总是需要传递行选择器和列选择器。冒号:表示应保留所有项目（取决于它的位置是行还是列）。以下是一些例子：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[1:5, [:Sex, :Age]]\n5×2 DataFrame\n Row │ Sex      Age\n     │ String7  Int64\n─────┼────────────────\n   1 │ male        67\n   2 │ female      22\n   3 │ male        49\n   4 │ male        45\n   5 │ male        53\n\njulia> german[1:5, :]\n5×10 DataFrame\n Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking accoun ⋯\n     │ Int64  Int64  String7  Int64  String7  String15         String15        ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     0     67  male         2  own      NA               little          ⋯\n   2 │     1     22  female       2  own      little           moderate\n   3 │     2     49  male         1  own      little           NA\n   4 │     3     45  male         2  free     little           little\n   5 │     4     53  male         2  free     little           little          ⋯\n                                                               4 columns omitted\n\njulia> german[[1, 6, 15], :]\n3×10 DataFrame\n Row │ id     Age    Sex      Job    Housing  Saving accounts  Checking accoun ⋯\n     │ Int64  Int64  String7  Int64  String7  String15         String15        ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │     0     67  male         2  own      NA               little          ⋯\n   2 │     5     35  male         1  free     NA               NA\n   3 │    14     28  female       2  rent     little           little\n                                                               4 columns omitted\n\njulia> german[:, [:Age, :Sex]]\n1000×2 DataFrame\n  Row │ Age    Sex\n      │ Int64  String7\n──────┼────────────────\n    1 │    67  male\n    2 │    22  female\n    3 │    49  male\n    4 │    45  male\n    5 │    53  male\n    6 │    35  male\n    7 │    53  male\n    8 │    35  male\n  ⋮   │   ⋮       ⋮\n  994 │    30  male\n  995 │    50  male\n  996 │    31  female\n  997 │    40  male\n  998 │    38  male\n  999 │    23  male\n 1000 │    27  male\n       985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"注意，german[!, [:Sex]]和german[:, [:Sex]]返回的是一个数据框对象，而german[!, :Sex]和german[:, :Sex]返回的是一个向量。在第一种情况下，[:Sex]是一个向量，表示结果对象应该是一个数据框。另一方面，:Sex是一个单独的Symbol，表示应该提取一个单独的列向量。注意，第一种情况需要传递一个向量（不仅仅是任何可迭代的对象），所以例如german[:, (:Age, :Sex)]是不允许的，但german[:, [:Age, :Sex]]是有效的。下面我们展示这两种操作以强调这个区别：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[!, [:Sex]]\n1000×1 DataFrame\n  Row │ Sex\n      │ String7\n──────┼─────────\n    1 │ male\n    2 │ female\n    3 │ male\n    4 │ male\n    5 │ male\n    6 │ male\n    7 │ male\n    8 │ male\n  ⋮   │    ⋮\n  994 │ male\n  995 │ male\n  996 │ female\n  997 │ male\n  998 │ male\n  999 │ male\n 1000 │ male\n985 rows omitted\n\njulia> german[!, :Sex]\n1000-element PooledArrays.PooledVector{String7, UInt32, Vector{UInt32}}:\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n ⋮\n \"male\"\n \"male\"\n \"male\"\n \"male\"\n \"female\"\n \"male\"\n \"male\"\n \"male\"\n \"male\"","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如同本教程之前解释的，使用!和:传递行索引的区别在于!不复制列，而:从数据框读取数据时会复制。因此，german[!, [:Sex]]数据框存储的是与源german数据框相同的向量，而german[:, [:Sex]]存储的是它的复制品。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"!选择器通常应该避免使用，因为使用它可能导致难以捕获的错误。然而，当处理非常大的数据框时，它可以用来节省内存和提高操作的性能。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"回顾我们已经学到的，要从german数据框中获取列:Age，你可以执行以下操作：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"复制向量：german[:, :Age]，german[:, \"Age\"]或german[:, 2]；\n获取向量而不复制：german.Age，german.\"Age\"，german[!, :Age]，german[!, \"Age\"]或german[!, 2]。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"要获取前两列作为DataFrame，我们可以如下索引：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"获取复制的列：german[:, 1:2]，german[:, [:id, :Age]]，或german[:, [\"id\", \"Age\"]]；\n不复制列的情况下重复使用列：german[!, 1:2]，german[!, [:id, :Age]]，或german[!, [\"id\", \"Age\"]]。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如果你想获取数据框的单个单元格，使用与获取矩阵单元格相同的语法：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[4, 4]\n2","category":"page"},{"location":"man/basics/#视图","page":"First Steps with DataFrames.jl","title":"视图","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"我们也可以创建一个数据帧的view。它通常非常有用，因为它比创建实体化的选择更节省内存。你可以使用view函数来创建：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> view(german, :, 2:5)\n1000×4 SubDataFrame\n  Row │ Age    Sex      Job    Housing\n      │ Int64  String7  Int64  String7\n──────┼────────────────────────────────\n    1 │    67  male         2  own\n    2 │    22  female       2  own\n    3 │    49  male         1  own\n    4 │    45  male         2  free\n    5 │    53  male         2  free\n    6 │    35  male         1  free\n    7 │    53  male         2  own\n    8 │    35  male         3  rent\n  ⋮   │   ⋮       ⋮       ⋮       ⋮\n  994 │    30  male         3  own\n  995 │    50  male         2  own\n  996 │    31  female       1  own\n  997 │    40  male         3  own\n  998 │    38  male         2  own\n  999 │    23  male         2  free\n 1000 │    27  male         2  own\n                       985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"或者使用@view宏：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> @view german[end:-1:1, [1, 4]]\n1000×2 SubDataFrame\n  Row │ id     Job\n      │ Int64  Int64\n──────┼──────────────\n    1 │   999      2\n    2 │   998      2\n    3 │   997      2\n    4 │   996      3\n    5 │   995      1\n    6 │   994      2\n    7 │   993      3\n    8 │   992      1\n  ⋮   │   ⋮      ⋮\n  994 │     6      2\n  995 │     5      1\n  996 │     4      2\n  997 │     3      2\n  998 │     2      1\n  999 │     1      2\n 1000 │     0      2\n     985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"同样，我们可以获取数据帧一列的视图：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> @view german[1:5, 1]\n5-element view(::Vector{Int64}, 1:5) with eltype Int64:\n 0\n 1\n 2\n 3\n 4","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"它的单个单元格：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> @view german[2, 2]\n0-dimensional view(::Vector{Int64}, 2) with eltype Int64:\n22","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"或者单独的一行：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> @view german[3, 2:5]\nDataFrameRow\n Row │ Age    Sex      Job    Housing\n     │ Int64  String7  Int64  String7\n─────┼────────────────────────────────\n   3 │    49  male         1  own","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如你所见，行和列的索引语法与索引完全相同。唯一的区别是我们没有创建一个新的对象，而是创建了一个现有对象的视图。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"为了比较索引的性能和创建视图的性能，让我们使用BenchmarkTools.jl包运行以下基准测试（如果你想重新运行这个比较，请安装它）：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using BenchmarkTools\n\njulia> @btime $german[1:end-1, 1:end-1];\n  9.900 μs (44 allocations: 57.56 KiB)\n\njulia> @btime @view $german[1:end-1, 1:end-1];\n  67.332 ns (2 allocations: 32 bytes)","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如你所见，创建一个视图：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"快一个数量级；\n分配的内存更少。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"视图的缺点是：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"它指向与其父对象相同的内存（所以改变视图会改变父对象，这有时是不可取的）；\n一些操作可能稍微慢一些（因为DataFrames.jl需要执行视图的索引到父对象的索引的映射）。","category":"page"},{"location":"man/basics/#更改存储在数据框中的数据","page":"First Steps with DataFrames.jl","title":"更改存储在数据框中的数据","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"为了展示如何在数据框上执行变异操作，我们首先创建一个german数据框的子集：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1 = german[1:6, 2:4]\n6×3 DataFrame\n Row │ Age    Sex      Job\n     │ Int64  String7  Int64\n─────┼───────────────────────\n   1 │    67  male         2\n   2 │    22  female       2\n   3 │    49  male         1\n   4 │    45  male         2\n   5 │    53  male         2\n   6 │    35  male         1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在下面的示例中，我们用一个新的向量替换了df1数据框中的列:Age：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> val = [80, 85, 98, 95, 78, 89]\n6-element Vector{Int64}:\n 80\n 85\n 98\n 95\n 78\n 89\n\njulia> df1.Age = val\n6-element Vector{Int64}:\n 80\n 85\n 98\n 95\n 78\n 89\n\njulia> df1\n6×3 DataFrame\n Row │ Age    Sex      Job\n     │ Int64  String7  Int64\n─────┼───────────────────────\n   1 │    80  male         2\n   2 │    85  female       2\n   3 │    98  male         1\n   4 │    95  male         2\n   5 │    78  male         2\n   6 │    89  male         1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"这是一个非复制操作。只有当val向量的长度与df1的行数相同时，才能执行此操作，或者作为特殊情况，如果df1没有任何列。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1.Age === val # 没有进行复制\ntrue","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如果在索引中从数据框中选择了一部分行，则会就地执行变异操作，即写入现有向量。下面将行1:3中的列:Job的值设置为[2, 4, 6]：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[1:3, :Job] = [2, 3, 2]\n3-element Vector{Int64}:\n 2\n 3\n 2\n\njulia> df1\n6×3 DataFrame\n Row │ Age    Sex      Job\n     │ Int64  String7  Int64\n─────┼───────────────────────\n   1 │    80  male         2\n   2 │    85  female       3\n   3 │    98  male         2\n   4 │    95  male         2\n   5 │    78  male         2\n   6 │    89  male         1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"作为特殊规则，使用!作为行选择器将替换列而不进行复制（就像上面的df1.Age = val示例中一样）。例如，下面我们替换:Sex列：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[!, :Sex] = [\"male\", \"female\", \"female\", \"transgender\", \"female\", \"male\"]\n6-element Vector{String}:\n \"male\"\n \"female\"\n \"female\"\n \"transgender\"\n \"female\"\n \"male\"\n\njulia> df1\n6×3 DataFrame\n Row │ Age    Sex          Job\n     │ Int64  String       Int64\n─────┼───────────────────────────\n   1 │    80  male             2\n   2 │    85  female           3\n   3 │    98  female           2\n   4 │    95  transgender      2\n   5 │    78  female           2\n   6 │    89  male             1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"类似于设置单列的选定行，我们还可以设置数据框的给定行的选定列：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[3, 1:3] = [78, \"male\", 4]\n3-element Vector{Any}:\n 78\n   \"male\"\n  4\n\njulia> df1\n6×3 DataFrame\n Row │ Age    Sex          Job\n     │ Int64  String       Int64\n─────┼───────────────────────────\n   1 │    80  male             2\n   2 │    85  female           3\n   3 │    78  male             4\n   4 │    95  transgender      2\n   5 │    78  female           2\n   6 │    89  male             1","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"我们已经提到过DataFrameRow可以用于修改其父数据框。下面是一些示例：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> dfr = df1[2, :] # DataFrameRow，包含df1的第二行和所有列\nDataFrameRow\n Row │ Age    Sex     Job\n     │ Int64  String  Int64\n─────┼──────────────────────\n   2 │    85  female      3\n\njulia> dfr.Age = 98 # 将第二行中列`:Age`的值设置为`98`\n98\n\njulia> dfr\nDataFrameRow\n Row │ Age    Sex     Job\n     │ Int64  String  Int64\n─────┼──────────────────────\n   2 │    98  female      3\n\njulia> dfr[2:3] = [\"male\", 2] # 设置列`:Sex`和`:Job`中的条目值\n2-element Vector{Any}:\n  \"male\"\n 2\n\njulia> dfr\nDataFrameRow\n Row │ Age    Sex     Job\n     │ Int64  String  Int64\n─────┼──────────────────────\n   2 │    98  male        2","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"这些操作更新了存储在df1数据框中的数据。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"类似地，视图可以用于更新其父数据框中存储的数据。下面是一些示例：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> sdf = view(df1, :, 2:3)\n6×2 SubDataFrame\n Row │ Sex          Job\n     │ String       Int64\n─────┼────────────────────\n   1 │ male             2\n   2 │ male             2\n   3 │ male             4\n   4 │ transgender      2\n   5 │ female           2\n   6 │ male             1\n\njulia> sdf[2, :Sex] = \"female\" # 将第二行中的列`:Sex`的值设置为`female`\n\"female\"\n\njulia> sdf\n6×2 SubDataFrame\n Row │ Sex          Job\n     │ String       Int64\n─────┼────────────────────\n   1 │ male             2\n   2 │ female           2\n   3 │ male             4\n   4 │ transgender      2\n   5 │ female           2\n   6 │ male             1\n\njulia> sdf[6, 1:2] = [\"female\", 3]\n2-element Vector{Any}:\n  \"female\"\n 3\n\njulia> sdf\n6×2 SubDataFrame\n Row │ Sex          Job\n     │ String       Int64\n─────┼────────────────────\n   1 │ male             2\n   2 │ female           2\n   3 │ male             4\n   4 │ transgender      2\n   5 │ female           2\n   6 │ female           3","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在所有这些情况下，sdf视图的父级也会被更新。","category":"page"},{"location":"man/basics/#广播赋值","page":"First Steps with DataFrames.jl","title":"广播赋值","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"除了普通的赋值，还可以使用.=操作进行广播赋值。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在我们继续之前，让我们解释一下在Julia中广播是如何工作的。 执行broadcasting的标准语法是使用.。例如，与R不同，下面的操作会失败：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> s = [25, 26, 35, 56]\n4-element Vector{Int64}:\n 25\n 26\n 35\n 56\n\njulia> s[2:3] = 0\nERROR: ArgumentError: indexed assignment with a single value to possibly many locations is not supported; perhaps use broadcasting `.=` instead?","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"相反，我们必须写成：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> s[2:3] .= 0\n2-element view(::Vector{Int64}, 2:3) with eltype Int64:\n 0\n 0\n\njulia> s\n4-element Vector{Int64}:\n 25\n  0\n  0\n 56","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"DataFrames.jl完全支持类似的语法。在这里，由于广播赋值，列:Age被一个全新的分配的向量替换：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[!, :Age] .= [85, 89, 78, 58, 96, 68] # 列`:Age`被一个全新的分配的向量替换\n6-element Vector{Int64}:\n 85\n 89\n 78\n 58\n 96\n 68\n\njulia> df1\n6×3 DataFrame\n Row │ Age    Sex          Job\n     │ Int64  String       Int64\n─────┼───────────────────────────\n   1 │    85  male             2\n   2 │    89  female           2\n   3 │    78  male             4\n   4 │    58  transgender      2\n   5 │    96  female           2\n   6 │    68  female           3","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在上面的例子中，如果使用:而不是!，将在现有列中进行广播赋值。 就地(in-place)和替换(replace)操作之间的主要区别在于，如果新值与旧值具有不同的类型，则需要替换列。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在下面的示例中，我们操作不存在于df1中的列:Customers和:City。 在这种情况下，使用!和:是等效的，并且会分配一个新的列：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[!, :Customers] .= [\"Rohit\", \"Akshat\", \"Rahul\", \"Aayush\", \"Prateek\", \"Anam\"]\n6-element Vector{String}:\n \"Rohit\"\n \"Akshat\"\n \"Rahul\"\n \"Aayush\"\n \"Prateek\"\n \"Anam\"\n\njulia> df1[:, :City] .= [\"Kanpur\", \"Lucknow\", \"Bhuvneshwar\", \"Jaipur\", \"Ranchi\", \"Dehradoon\"]\n6-element Vector{String}:\n \"Kanpur\"\n \"Lucknow\"\n \"Bhuvneshwar\"\n \"Jaipur\"\n \"Ranchi\"\n \"Dehradoon\"\n\njulia> df1\n6×5 DataFrame\n Row │ Age    Sex          Job    Customers  City\n     │ Int64  String       Int64  String     String\n─────┼───────────────────────────────────────────────────\n   1 │    85  male             2  Rohit      Kanpur\n   2 │    89  female           2  Akshat     Lucknow\n   3 │    78  male             4  Rahul      Bhuvneshwar\n   4 │    58  transgender      2  Aayush     Jaipur\n   5 │    96  female           2  Prateek    Ranchi\n   6 │    68  female           3  Anam       Dehradoon","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"对于:Age选择器，广播赋值操作是就地进行的，所以下面的操作会引发错误：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[:, :Age] .= \"Economics\"\nERROR: MethodError: Cannot `convert` an object of type String to an object of type Int64","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"我们需要使用!，因为它会用一个全新的向量替换旧的向量：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df1[!, :Age] .= \"Economics\"\n6-element Vector{String}:\n \"Economics\"\n \"Economics\"\n \"Economics\"\n \"Economics\"\n \"Economics\"\n \"Economics\"\n\njulia> df1\n6×5 DataFrame\n Row │ Age        Sex          Job    Customers  City\n     │ String     String       Int64  String     String\n─────┼───────────────────────────────────────────────────────\n   1 │ Economics  male             2  Rohit      Kanpur\n   2 │ Economics  female           2  Akshat     Lucknow\n   3 │ Economics  male             4  Rahul      Bhuvneshwar\n   4 │ Economics  transgender      2  Aayush     Jaipur\n   5 │ Economics  female           2  Prateek    Ranchi\n   6 │ Economics  female           3  Anam       Dehradoon","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在DataFrames.jl中，有一些情况下，我们自然地希望实现类似广播的行为，但不允许使用.操作。 在这种情况下，为了方便用户，执行所谓的伪广播(pseudo-broadcasting)。 我们已经在DataFrame构造函数的示例中看到了它。下面我们展示了在insertcols!函数中伪广播的工作方式， 该函数在任意位置向数据框中插入列。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在下面的示例中，我们使用insertcols!函数创建了一个名为:Country的列。 由于我们传递了一个标量值\"India\"，该列的值被广播到输出数据框的所有行：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> insertcols!(df1, 1, :Country => \"India\")\n6×6 DataFrame\n Row │ Country  Age        Sex          Job    Customers  City\n     │ String   String     String       Int64  String     String\n─────┼────────────────────────────────────────────────────────────────\n   1 │ India    Economics  male             2  Rohit      Kanpur\n   2 │ India    Economics  female           2  Akshat     Lucknow\n   3 │ India    Economics  male             4  Rahul      Bhuvneshwar\n   4 │ India    Economics  transgender      2  Aayush     Jaipur\n   5 │ India    Economics  female           2  Prateek    Ranchi\n   6 │ India    Economics  female           3  Anam       Dehradoon","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"您可以将要插入列的位置作为第二个参数传递给insertcols!函数：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> insertcols!(df1, 4, :b => exp(4))\n6×7 DataFrame\n Row │ Country  Age        Sex          b        Job    Customers  City        ⋯\n     │ String   String     String       Float64  Int64  String     String      ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ India    Economics  male         54.5982      4  Rohit      Kanpur      ⋯\n   2 │ India    Economics  female       54.5982      4  Akshat     Lucknow\n   3 │ India    Economics  male         54.5982      4  Rahul      Bhuvneshwar\n   4 │ India    Economics  transgender  54.5982      4  Aayush     Jaipur\n   5 │ India    Economics  female       54.5982      4  Prateek    Ranchi      ⋯\n   6 │ India    Economics  female       54.5982      4  Anam       Dehradoon","category":"page"},{"location":"man/basics/#Not、Between、Cols和All列选择器","page":"First Steps with DataFrames.jl","title":"Not、Between、Cols和All列选择器","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在更复杂的列选择场景中，您可以使用Not、Between、Cols和All选择器：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"Not选择器（来自InvertedIndices.jl包）允许我们指定要从结果数据框中排除的列。我们可以在Not内部放置任何有效的其他列选择器；\nBetween选择器允许我们指定一系列列（我们可以使用任何单列选择器语法传递起始和停止列）；\nCols(...)选择器选择作为其参数传递的其他选择器的并集；\nAll()允许我们选择DataFrame的所有列；这与传递:是相同的；\n使用正则表达式选择与其名称匹配的列。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"让我们给出一些这些选择器的示例。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"删除:Age列：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[:, Not(:Age)]\n1000×9 DataFrame\n  Row │ id     Sex      Job    Housing  Saving accounts  Checking account  Cre ⋯\n      │ Int64  String7  Int64  String7  String15         String15          Int ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0  male         2  own      NA               little                ⋯\n    2 │     1  female       2  own      little           moderate\n    3 │     2  male         1  own      little           NA\n    4 │     3  male         2  free     little           little\n    5 │     4  male         2  free     little           little                ⋯\n    6 │     5  male         1  free     NA               NA\n    7 │     6  male         2  own      quite rich       NA\n    8 │     7  male         3  rent     little           moderate\n  ⋮   │   ⋮       ⋮       ⋮       ⋮            ⋮                ⋮              ⋱\n  994 │   993  male         3  own      little           little                ⋯\n  995 │   994  male         2  own      NA               NA\n  996 │   995  female       1  own      little           NA\n  997 │   996  male         3  own      little           little\n  998 │   997  male         2  own      little           NA                    ⋯\n  999 │   998  male         2  free     little           little\n 1000 │   999  male         2  own      moderate         moderate\n                                                  3 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"选择从:Sex到:Housing的列：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[:, Between(:Sex, :Housing)]\n1000×3 DataFrame\n  Row │ Sex     Job    Housing\n      │ String  Int64  String\n──────┼────────────────────────\n    1 │ male        2  own\n    2 │ female      2  own\n    3 │ male        1  own\n    4 │ male        2  free\n    5 │ male        2  free\n    6 │ male        1  free\n    7 │ male        2  own\n    8 │ male        3  rent\n  ⋮   │   ⋮       ⋮       ⋮\n  994 │ male        3  own\n  995 │ male        2  own\n  996 │ female      1  own\n  997 │ male        3  own\n  998 │ male        2  own\n  999 │ male        2  free\n 1000 │ male        2  own\n               985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在下面的示例中，Cols选择器选择作为其参数传递的\"Age\"和Between(\"Sex\", \"Job\")选择器的并集：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[:, Cols(\"Age\", Between(\"Sex\", \"Job\"))]\n1000×3 DataFrame\n  Row │ Age    Sex      Job\n      │ Int64  String7  Int64\n──────┼───────────────────────\n    1 │    67  male         2\n    2 │    22  female       2\n    3 │    49  male         1\n    4 │    45  male         2\n    5 │    53  male         2\n    6 │    35  male         1\n    7 │    53  male         2\n    8 │    35  male         3\n  ⋮   │   ⋮       ⋮       ⋮\n  994 │    30  male         3\n  995 │    50  male         2\n  996 │    31  female       1\n  997 │    40  male         3\n  998 │    38  male         2\n  999 │    23  male         2\n 1000 │    27  male         2\n              985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"您还可以使用正则表达式Regex来选择列。在下面的示例中，我们选择具有其名称中包含\"S\"的列，并使用Not来删除第5行：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german[Not(5), r\"S\"]\n999×2 DataFrame\n Row │ Sex      Saving accounts\n     │ String7  String15\n─────┼──────────────────────────\n   1 │ male     NA\n   2 │ female   little\n   3 │ male     little\n   4 │ male     little\n   5 │ male     NA\n   6 │ male     quite rich\n   7 │ male     little\n   8 │ male     rich\n  ⋮  │    ⋮            ⋮\n 993 │ male     little\n 994 │ male     NA\n 995 │ female   little\n 996 │ male     little\n 997 │ male     little\n 998 │ male     little\n 999 │ male     moderate\n                984 rows omitted","category":"page"},{"location":"man/basics/#转换函数的基本用法","page":"First Steps with DataFrames.jl","title":"转换函数的基本用法","text":"","category":"section"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在DataFrames.jl中，我们有五个函数可以用来对数据帧的列进行转换：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"combine：创建一个新的数据帧，其中包含对源数据帧列应用转换得到的列，可以合并行；\nselect：创建一个与源数据帧具有相同行数的新数据帧，其中包含对源数据帧列应用转换得到的列；\nselect!：与select相同，但会直接在传入的数据帧上进行更新；\ntransform：与select相同，但会保留数据帧中已存在的列（需要注意的是，这些列可能会被传递给transform的转换修改）；\ntransform!：与transform相同，但会直接在传入的数据帧上进行更新。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"指定转换的基本方式有以下几种：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"source_column => transformation => target_column_name：在这种情况下，将source_column作为参数传递给transformation函数，并将其存储在target_column_name列中。\nsource_column => transformation：在这种情况下，我们将转换函数应用于source_column，目标列名会自动生成。\nsource_column => target_column_name：将source_column重命名为target_column_name。\nsource_column：在结果中保持源列不进行任何转换。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"这些规则通常被称为转换迷你语言。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"让我们来看一些应用这些规则的示例。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> using Statistics\n\njulia> combine(german, :Age => mean => :mean_age)\n1×1 DataFrame\n Row │ mean_age\n     │ Float64\n─────┼──────────\n   1 │   35.546\n\njulia> select(german, :Age => mean => :mean_age)\n1000×1 DataFrame\n  Row │ mean_age\n      │ Float64\n──────┼──────────\n    1 │   35.546\n    2 │   35.546\n    3 │   35.546\n    4 │   35.546\n    5 │   35.546\n    6 │   35.546\n    7 │   35.546\n    8 │   35.546\n  ⋮   │    ⋮\n  994 │   35.546\n  995 │   35.546\n  996 │   35.546\n  997 │   35.546\n  998 │   35.546\n  999 │   35.546\n 1000 │   35.546\n 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如您所见，在这两种情况下，mean函数被应用于:Age列，并将结果存储在:mean_age列中。combine和select函数的区别在于，combine对数据进行聚合，并根据转换函数返回的行数生成相应的行数。而select函数始终保持数据帧中的行数与源数据帧相同。因此，在这种情况下，mean函数的结果被广播。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"由于combine可以根据转换的结果生成任意数量的行，如果我们组合了一些转换，其中一些转换生成向量，而其他转换生成标量，则标量会像在select中一样被广播。下面是一个示例：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> combine(german, :Age => mean => :mean_age, :Housing => unique => :housing)\n3×2 DataFrame\n Row │ mean_age  housing\n     │ Float64   String7\n─────┼───────────────────\n   1 │   35.546  own\n   2 │   35.546  free\n   3 │   35.546  rent","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"请注意，不允许在不同的转换中返回长度不同的向量：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> combine(german, :Age, :Housing => unique => :Housing)\nERROR: ArgumentError: New columns must have the same length as old columns","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"让我们使用select讨论一些其他示例。通常，我们希望将某个函数应用于数据帧的整个列，而不是其各个元素。通常，我们可以使用广播来实现这一点，如下所示：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Sex => (x -> uppercase.(x)) => :Sex)\n1000×1 DataFrame\n  Row │ Sex\n      │ String\n──────┼────────\n    1 │ MALE\n    2 │ FEMALE\n    3 │ MALE\n    4 │ MALE\n    5 │ MALE\n    6 │ MALE\n    7 │ MALE\n    8 │ MALE\n  ⋮   │   ⋮\n  994 │ MALE\n  995 │ MALE\n  996 │ FEMALE\n  997 │ MALE\n  998 │ MALE\n  999 │ MALE\n 1000 │ MALE\n985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"这种模式在实践中经常遇到，因此有一个ByRow的便捷包装器，用于创建广播变体的函数。在这些示例中，ByRow是一种特殊类型，用于选择操作，以表示应将包装的函数应用于选择的每个元素（行）。在这里，我们使用uppercase函数将ByRow包装器传递给目标列名:Sex：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Sex => ByRow(uppercase) => :SEX)\n1000×1 DataFrame\n  Row │ SEX\n      │ String\n──────┼────────\n    1 │ MALE\n    2 │ FEMALE\n    3 │ MALE\n    4 │ MALE\n    5 │ MALE\n    6 │ MALE\n    7 │ MALE\n    8 │ MALE\n  ⋮   │   ⋮\n  994 │ MALE\n  995 │ MALE\n  996 │ FEMALE\n  997 │ MALE\n  998 │ MALE\n  999 │ MALE\n 1000 │ MALE\n985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在这种情况下，我们使用ByRow包装器来转换源列:Age，并自动生成目标列名：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Age, :Age => ByRow(sqrt))\n1000×2 DataFrame\n  Row │ Age    Age_sqrt\n      │ Int64  Float64\n──────┼─────────────────\n    1 │    67   8.18535\n    2 │    22   4.69042\n    3 │    49   7.0\n    4 │    45   6.7082\n    5 │    53   7.28011\n    6 │    35   5.91608\n    7 │    53   7.28011\n    8 │    35   5.91608\n  ⋮   │   ⋮       ⋮\n  994 │    30   5.47723\n  995 │    50   7.07107\n  996 │    31   5.56776\n  997 │    40   6.32456\n  998 │    38   6.16441\n  999 │    23   4.79583\n 1000 │    27   5.19615\n        985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"当我们只传递一个列（不包括=>部分）时，我们可以使用在索引中允许的任何列选择器。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在这里，我们从结果数据框中排除列:Age：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, Not(:Age))\n1000×9 DataFrame\n  Row │ id     Sex      Job    Housing  Saving accounts  Checking account  Cre ⋯\n      │ Int64  String7  Int64  String7  String15         String15          Int ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0  male         2  own      NA               little                ⋯\n    2 │     1  female       2  own      little           moderate\n    3 │     2  male         1  own      little           NA\n    4 │     3  male         2  free     little           little\n    5 │     4  male         2  free     little           little                ⋯\n    6 │     5  male         1  free     NA               NA\n    7 │     6  male         2  own      quite rich       NA\n    8 │     7  male         3  rent     little           moderate\n  ⋮   │   ⋮       ⋮       ⋮       ⋮            ⋮                ⋮              ⋱\n  994 │   993  male         3  own      little           little                ⋯\n  995 │   994  male         2  own      NA               NA\n  996 │   995  female       1  own      little           NA\n  997 │   996  male         3  own      little           little\n  998 │   997  male         2  own      little           NA                    ⋯\n  999 │   998  male         2  free     little           little\n 1000 │   999  male         2  own      moderate         moderate\n                                                  3 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在下一个示例中，我们删除列\"Age\"、\"Saving accounts\"、\"Checking account\"、\"Credit amount\"和\"Purpose\"。请注意，这次我们使用字符串列选择器，因为一些列名中包含空格：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, Not([\"Age\", \"Saving accounts\", \"Checking account\",\n                           \"Credit amount\", \"Purpose\"]))\n1000×5 DataFrame\n  Row │ id     Sex      Job    Housing  Duration\n      │ Int64  String7  Int64  String7  Int64\n──────┼──────────────────────────────────────────\n    1 │     0  male         2  own             6\n    2 │     1  female       2  own            48\n    3 │     2  male         1  own            12\n    4 │     3  male         2  free           42\n    5 │     4  male         2  free           24\n    6 │     5  male         1  free           36\n    7 │     6  male         2  own            24\n    8 │     7  male         3  rent           36\n  ⋮   │   ⋮       ⋮       ⋮       ⋮        ⋮\n  994 │   993  male         3  own            36\n  995 │   994  male         2  own            12\n  996 │   995  female       1  own            12\n  997 │   996  male         3  own            30\n  998 │   997  male         2  own            12\n  999 │   998  male         2  free           45\n 1000 │   999  male         2  own            45\n                                 985 rows omitted\n","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"作为另一个示例，让我们展示一下我们之前使用的r\"S\"正则表达式在select中也可以使用：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, r\"S\")\n1000×2 DataFrame\n  Row │ Sex      Saving accounts\n      │ String7  String15\n──────┼──────────────────────────\n    1 │ male     NA\n    2 │ female   little\n    3 │ male     little\n    4 │ male     little\n    5 │ male     little\n    6 │ male     NA\n    7 │ male     quite rich\n    8 │ male     little\n  ⋮   │    ⋮            ⋮\n  994 │ male     little\n  995 │ male     NA\n  996 │ female   little\n  997 │ male     little\n  998 │ male     little\n  999 │ male     little\n 1000 │ male     moderate\n                 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"使用select或combine相对于索引的好处是更容易获取多个列选择器的并集，例如：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, r\"S\", \"Job\", 1)\n1000×4 DataFrame\n  Row │ Sex      Saving accounts  Job    id\n      │ String7  String15         Int64  Int64\n──────┼────────────────────────────────────────\n    1 │ male     NA                   2      0\n    2 │ female   little               2      1\n    3 │ male     little               1      2\n    4 │ male     little               2      3\n    5 │ male     little               2      4\n    6 │ male     NA                   1      5\n    7 │ male     quite rich           2      6\n    8 │ male     little               3      7\n  ⋮   │    ⋮            ⋮           ⋮      ⋮\n  994 │ male     little               3    993\n  995 │ male     NA                   2    994\n  996 │ female   little               1    995\n  997 │ male     little               3    996\n  998 │ male     little               2    997\n  999 │ male     little               2    998\n 1000 │ male     moderate             2    999\n                               985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"利用这种灵活性，这里是一种将某些列移动到数据框前面的惯用模式：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, \"Sex\", :)\n1000×10 DataFrame\n  Row │ Sex      id     Age    Job    Housing  Saving accounts  Checking accou ⋯\n      │ String7  Int64  Int64  Int64  String7  String15         String15       ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │ male         0     67      2  own      NA               little         ⋯\n    2 │ female       1     22      2  own      little           moderate\n    3 │ male         2     49      1  own      little           NA\n    4 │ male         3     45      2  free     little           little\n    5 │ male         4     53      2  free     little           little         ⋯\n    6 │ male         5     35      1  free     NA               NA\n    7 │ male         6     53      2  own      quite rich       NA\n    8 │ male         7     35      3  rent     little           moderate\n  ⋮   │    ⋮       ⋮      ⋮      ⋮       ⋮            ⋮                ⋮       ⋱\n  994 │ male       993     30      3  own      little           little         ⋯\n  995 │ male       994     50      2  own      NA               NA\n  996 │ female     995     31      1  own      little           NA\n  997 │ male       996     40      3  own      little           little\n  998 │ male       997     38      2  own      little           NA             ⋯\n  999 │ male       998     23      2  free     little           little\n 1000 │ male       999     27      2  own      moderate         moderate\n                                                  4 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"下面，我们只是传递源列和目标列名来重命名它们（没有指定转换部分）：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Sex => :x1, :Age => :x2)\n1000×2 DataFrame\n  Row │ x1       x2\n      │ String7  Int64\n──────┼────────────────\n    1 │ male        67\n    2 │ female      22\n    3 │ male        49\n    4 │ male        45\n    5 │ male        53\n    6 │ male        35\n    7 │ male        53\n    8 │ male        35\n  ⋮   │    ⋮       ⋮\n  994 │ male        30\n  995 │ male        50\n  996 │ female      31\n  997 │ male        40\n  998 │ male        38\n  999 │ male        23\n 1000 │ male        27\n       985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"需要注意的是，select始终返回一个数据框，即使只选择了一个单独的列，与索引语法相反。比较以下两种情况：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Age)\n1000×1 DataFrame\n  Row │ Age\n      │ Int64\n──────┼───────\n    1 │    67\n    2 │    22\n    3 │    49\n    4 │    45\n    5 │    53\n    6 │    35\n    7 │    53\n    8 │    35\n  ⋮   │   ⋮\n  994 │    30\n  995 │    50\n  996 │    31\n  997 │    40\n  998 │    38\n  999 │    23\n 1000 │    27\n985 rows omitted\n\njulia> german[:, :Age]\n1000-element Vector{Int64}:\n 67\n 22\n 49\n 45\n 53\n 35\n 53\n 35\n 61\n 28\n  ⋮\n 34\n 23\n 30\n 50\n 31\n 40\n 38\n 23\n 27","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"默认情况下，select会复制传递的源数据框的列。为了避免复制，可以传递copycols=false关键字参数：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> df = select(german, :Sex)\n1000×1 DataFrame\n  Row │ Sex\n      │ String7\n──────┼─────────\n    1 │ male\n    2 │ female\n    3 │ male\n    4 │ male\n    5 │ male\n    6 │ male\n    7 │ male\n    8 │ male\n  ⋮   │    ⋮\n  994 │ male\n  995 │ male\n  996 │ female\n  997 │ male\n  998 │ male\n  999 │ male\n 1000 │ male\n985 rows omitted\n\njulia> df.Sex === german.Sex # copy\nfalse\n\njulia> df = select(german, :Sex, copycols=false)\n1000×1 DataFrame\n  Row │ Sex\n      │ String7\n──────┼─────────\n    1 │ male\n    2 │ female\n    3 │ male\n    4 │ male\n    5 │ male\n    6 │ male\n    7 │ male\n    8 │ male\n  ⋮   │    ⋮\n  994 │ male\n  995 │ male\n  996 │ female\n  997 │ male\n  998 │ male\n  999 │ male\n 1000 │ male\n985 rows omitted\n\njulia> df.Sex === german.Sex # no-copy is performed\ntrue","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"要在原地执行选择操作，请使用select!：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select!(german, Not(:Age));\n\njulia> german\n1000×9 DataFrame\n  Row │ id     Sex      Job    Housing  Saving accounts  Checking account  Cre ⋯\n      │ Int64  String7  Int64  String7  String15         String15          Int ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0  male         2  own      NA               little                ⋯\n    2 │     1  female       2  own      little           moderate\n    3 │     2  male         1  own      little           NA\n    4 │     3  male         2  free     little           little\n    5 │     4  male         2  free     little           little                ⋯\n    6 │     5  male         1  free     NA               NA\n    7 │     6  male         2  own      quite rich       NA\n    8 │     7  male         3  rent     little           moderate\n  ⋮   │   ⋮       ⋮       ⋮       ⋮            ⋮                ⋮              ⋱\n  994 │   993  male         3  own      little           little                ⋯\n  995 │   994  male         2  own      NA               NA\n  996 │   995  female       1  own      little           NA\n  997 │   996  male         3  own      little           little\n  998 │   997  male         2  own      little           NA                    ⋯\n  999 │   998  male         2  free     little           little\n 1000 │   999  male         2  own      moderate         moderate\n                                                  3 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"正如您所看到的，german数据框中的:Age列已被删除。","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"transform和transform!函数的工作方式与select和select!完全相同，唯一的区别是它们保留源数据框中存在的所有列。以下是一些示例：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> german = copy(german_ref);\n\njulia> df = german_ref[1:8, 1:5]\n8×5 DataFrame\n Row │ id     Age    Sex      Job    Housing\n     │ Int64  Int64  String7  Int64  String7\n─────┼───────────────────────────────────────\n   1 │     0     67  male         2  own\n   2 │     1     22  female       2  own\n   3 │     2     49  male         1  own\n   4 │     3     45  male         2  free\n   5 │     4     53  male         2  free\n   6 │     5     35  male         1  free\n   7 │     6     53  male         2  own\n   8 │     7     35  male         3  rent\n\njulia> transform(df, :Age => maximum)\n8×6 DataFrame\n Row │ id     Age    Sex      Job    Housing  Age_maximum\n     │ Int64  Int64  String7  Int64  String7  Int64\n─────┼────────────────────────────────────────────────────\n   1 │     0     67  male         2  own               67\n   2 │     1     22  female       2  own               67\n   3 │     2     49  male         1  own               67\n   4 │     3     45  male         2  free              67\n   5 │     4     53  male         2  free              67\n   6 │     5     35  male         1  free              67\n   7 │     6     53  male         2  own               67\n   8 │     7     35  male         3  rent              67","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在下面的示例中，我们交换存储在:Sex列和:Age列中的值：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> transform(german, :Age => :Sex, :Sex => :Age)\n1000×10 DataFrame\n  Row │ id     Age      Sex    Job    Housing  Saving accounts  Checking accou ⋯\n      │ Int64  String7  Int64  Int64  String7  String15         String15       ⋯\n──────┼─────────────────────────────────────────────────────────────────────────\n    1 │     0  male        67      2  own      NA               little         ⋯\n    2 │     1  female      22      2  own      little           moderate\n    3 │     2  male        49      1  own      little           NA\n    4 │     3  male        45      2  free     little           little\n    5 │     4  male        53      2  free     little           little         ⋯\n    6 │     5  male        35      1  free     NA               NA\n    7 │     6  male        53      2  own      quite rich       NA\n    8 │     7  male        35      3  rent     little           moderate\n  ⋮   │   ⋮       ⋮       ⋮      ⋮       ⋮            ⋮                ⋮       ⋱\n  994 │   993  male        30      3  own      little           little         ⋯\n  995 │   994  male        50      2  own      NA               NA\n  996 │   995  female      31      1  own      little           NA\n  997 │   996  male        40      3  own      little           little\n  998 │   997  male        38      2  own      little           NA             ⋯\n  999 │   998  male        23      2  free     little           little\n 1000 │   999  male        27      2  own      moderate         moderate\n                                                  4 columns and 985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"如果我们将多个源列传递给转换函数，它们将作为连续的位置参数传递。因此，例如下面的[:Age, :Job] => (+) => :res转换会计算+(df1.Age, df1.Job)（将两列相加），并将结果存储在:res列中：","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"julia> select(german, :Age, :Job, [:Age, :Job] => (+) => :res)\n1000×3 DataFrame\n  Row │ Age    Job    res\n      │ Int64  Int64  Int64\n──────┼─────────────────────\n    1 │    67      2     69\n    2 │    22      2     24\n    3 │    49      1     50\n    4 │    45      2     47\n    5 │    53      2     55\n    6 │    35      1     36\n    7 │    53      2     55\n    8 │    35      3     38\n  ⋮   │   ⋮      ⋮      ⋮\n  994 │    30      3     33\n  995 │    50      2     52\n  996 │    31      1     32\n  997 │    40      3     43\n  998 │    38      2     40\n  999 │    23      2     25\n 1000 │    27      2     29\n            985 rows omitted","category":"page"},{"location":"man/basics/","page":"First Steps with DataFrames.jl","title":"First Steps with DataFrames.jl","text":"在这个入门教程中给出的示例并没有涵盖转换迷你语言的所有选项。在手册的后面部分，有更高级的示例，特别是展示如何使用AsTable操作传递或生成多列的示例（您可能在一些DataFrames.jl的演示中见过）。","category":"page"},{"location":"man/importing_and_exporting/#导入和导出数据-(I/O)","page":"Importing and Exporting Data (I/O)","title":"导入和导出数据 (I/O)","text":"","category":"section"},{"location":"man/importing_and_exporting/#CSV-文件","page":"Importing and Exporting Data (I/O)","title":"CSV 文件","text":"","category":"section"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"对于从 CSV 和其他分隔符文本文件读取和写入表格数据，可以使用 CSV.jl 包。","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"如果你之前没有使用过 CSV.jl 包，那么你可能需要先安装它：","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"using Pkg\nPkg.add(\"CSV\")","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"CSV.jl 的函数不会自动加载，必须导入到会话中。","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"using CSV","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"现在可以从路径 input 的 CSV 文件中读取数据集：","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"DataFrame(CSV.File(input))","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"可以将 DataFrame 写入到路径 output 的 CSV 文件中：","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"df = DataFrame(x=1, y=2)\nCSV.write(output, df)","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"CSV 函数的行为可以通过关键字参数进行调整。更多信息请参阅 ?CSV.File，?CSV.read 和 ?CSV.write，或查看在线 CSV.jl 文档。","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"在简单的情况下，当 CSV.jl 的编译延迟可能成为问题时，可以考虑使用 Julia 标准库的 DelimitedFiles 模块。以下是一个示例，展示如何读入数据并进行后处理：","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"julia> using DelimitedFiles, DataFrames\n\njulia> path = joinpath(pkgdir(DataFrames), \"docs\", \"src\", \"assets\", \"iris.csv\");\n\njulia> data, header = readdlm(path, ',', header=true);\n\njulia> iris_raw = DataFrame(data, vec(header))\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Any          Any         Any          Any         Any\n─────┼──────────────────────────────────────────────────────────────────\n   1 │ 5.1          3.5         1.4          0.2         Iris-setosa\n   2 │ 4.9          3.0         1.4          0.2         Iris-setosa\n   3 │ 4.7          3.2         1.3          0.2         Iris-setosa\n   4 │ 4.6          3.1         1.5          0.2         Iris-setosa\n   5 │ 5.0          3.6         1.4          0.2         Iris-setosa\n   6 │ 5.4          3.9         1.7          0.4         Iris-setosa\n   7 │ 4.6          3.4         1.4          0.3         Iris-setosa\n   8 │ 5.0          3.4         1.5          0.2         Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │ 6.8          3.2         5.9          2.3         Iris-virginica\n 145 │ 6.7          3.3         5.7          2.5         Iris-virginica\n 146 │ 6.7          3.0         5.2          2.3         Iris-virginica\n 147 │ 6.3          2.5         5.0          1.9         Iris-virginica\n 148 │ 6.5          3.0         5.2          2.0         Iris-virginica\n 149 │ 6.2          3.4         5.4          2.3         Iris-virginica\n 150 │ 5.9          3.0         5.1          1.8         Iris-virginica\n                                                        135 rows omitted\n\njulia> iris = identity.(iris_raw)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     SubStrin…\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         6.8         3.2          5.9         2.3  Iris-virginica\n 145 │         6.7         3.3          5.7         2.5  Iris-virginica\n 146 │         6.7         3.0          5.2         2.3  Iris-virginica\n 147 │         6.3         2.5          5.0         1.9  Iris-virginica\n 148 │         6.5         3.0          5.2         2.0  Iris-virginica\n 149 │         6.2         3.4          5.4         2.3  Iris-virginica\n 150 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                        135 rows omitted","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"请注意，在我们的例子中：","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"header 是一个 Matrix，因此我们必须将 vec(header) 传递给 DataFrame 构造器；\n我们对 iris_raw 数据框进行了 identity 函数的广播，以执行 iris_raw 列的 eltype 的缩小；原因是 readdlm 函数读入的数据存储在 data Matrix 中，所以 iris_raw 中的所有列最初都有相同的 eltype – 在这种情况下，必须是 Any，因为某些列是数值型，而某些列是字符串。","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"所有这些操作（以及更多）都可以由 CSV.jl 自动处理。","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"类似地，你可以使用 DelimitedFiles 模块的 writedlm 函数来保存数据框，例如：","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"writedlm(\"test.csv\", Iterators.flatten(([names(iris)], eachrow(iris))), ',')","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"如你所见，将 iris 转换成适合 writedlm 函数的正确输入，以便你可以创建具有预期格式的 CSV 文件，这是不容易的。因此，CSV.jl 是写入存储在数据框中的数据的 CSV 文件的首选包。","category":"page"},{"location":"man/importing_and_exporting/#其他格式","page":"Importing and Exporting Data (I/O)","title":"其他格式","text":"","category":"section"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"以下包支持读取和写入其他数据格式（非详尽列表）：","category":"page"},{"location":"man/importing_and_exporting/","page":"Importing and Exporting Data (I/O)","title":"Importing and Exporting Data (I/O)","text":"Apache Arrow（包括 Feather v2）：Arrow.jl\nApache Feather（v1）：Feather.jl\nApache Avro：Avro.jl\nJSON：JSONTables.jl\nParquet：Parquet2.jl\nStata，SAS 和 SPSS：ReadStatTables.jl （或者 Queryverse 用户可以选择 StatFiles.jl）\n读取 R 数据文件 (.rda, .RData)：RData.jl\nMicrosoft Excel (XLSX)：XLSX.jl\n复制/粘贴到剪贴板，用于发送数据到电子表格和从电子表格获取数据：ClipData.jl","category":"page"},{"location":"man/querying_frameworks/#数据操作框架","page":"Data manipulation frameworks","title":"数据操作框架","text":"","category":"section"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"有三个框架提供了方便的方法来操作 DataFrame：DataFramesMeta.jl，DataFrameMacros.jl和Query.jl。它们实现了类似于dplyr或LINQ的功能。","category":"page"},{"location":"man/querying_frameworks/#DataFramesMeta.jl","page":"Data manipulation frameworks","title":"DataFramesMeta.jl","text":"","category":"section"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"DataFramesMeta.jl包提供了一个便捷且快速的基于宏的接口来处理 DataFrame。下面的指南适用于DataFramesMeta.jl的0.10.0版本。","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"首先安装DataFramesMeta.jl包：","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"using Pkg\nPkg.add(\"DataFramesMeta\")","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"该包的主要优点是它通过宏@transform，@select，@combine等提供了更便捷的语法来进行转换函数 transform，select和combine。","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"DataFramesMeta.jl还从Chain.jl中重新导出了@chain宏，允许用户把一个转换的输出作为另一个转换的输入，就像在R中的|>和%>%一样。","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"下面我们展示了一些使用该包的选定示例。","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"首先我们使用逻辑条件对源数据框的行进行子集选择，并选择其两列，重命名其中一列：","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> using DataFramesMeta\n\njulia> df = DataFrame(name=[\"John\", \"Sally\", \"Roger\"],\n                      age=[54.0, 34.0, 79.0],\n                      children=[0, 2, 4])\n3×3 DataFrame\n Row │ name    age      children\n     │ String  Float64  Int64\n─────┼───────────────────────────\n   1 │ John       54.0         0\n   2 │ Sally      34.0         2\n   3 │ Roger      79.0         4\n\njulia> @chain df begin\n           @rsubset :age > 40 \n           @select(:number_of_children = :children, :name)\n       end\n2×2 DataFrame\n Row │ number_of_children  name\n     │ Int64               String\n─────┼────────────────────────────\n   1 │                  0  John\n   2 │                  4  Roger","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"在下面的示例中，我们展示了DataFramesMeta.jl也支持分割-应用-组合模式：","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> df = DataFrame(key=repeat(1:3, 4), value=1:12)\n12×2 DataFrame\n Row │ key    value\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     1      4\n   5 │     2      5\n   6 │     3      6\n   7 │     1      7\n   8 │     2      8\n   9 │     3      9\n  10 │     1     10\n  11 │     2     11\n  12 │     3     12\n\njulia> @chain df begin\n           @rsubset :value > 3 \n           @by(:key, :min = minimum(:value), :max = maximum(:value))\n           @select(:key, :range = :max - :min)\n        end\n3×2 DataFrame\n Row │ key    range\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      6\n   2 │     2      6\n   3 │     3      6\n\njulia> @chain df begin\n           groupby(:key)\n           @transform :value0 = :value .- minimum(:value)\n       end\n12×3 DataFrame\n Row │ key    value  value0\n     │ Int64  Int64  Int64\n─────┼──────────────────────\n   1 │     1      1       0\n   2 │     2      2       0\n   3 │     3      3       0\n   4 │     1      4       3\n   5 │     2      5       3\n   6 │     3      6       3\n   7 │     1      7       6\n   8 │     2      8       6\n   9 │     3      9       6\n  10 │     1     10       9\n  11 │     2     11       9\n  12 │     3     12       9","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"你可以在DataFramesMeta.jl GitHub页面上找到更多关于如何使用此包的详细信息。","category":"page"},{"location":"man/querying_frameworks/#DataFrameMacros.jl","page":"Data manipulation frameworks","title":"DataFrameMacros.jl","text":"","category":"section"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"DataFrameMacros.jl 是DataFramesMeta.jl的替代品，它额外关注于便捷地同时转换多列的解决方案。下面的指南适用于DataFrameMacros.jl的0.3版本。","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"首先，安装DataFrameMacros.jl包：","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"using Pkg\nPkg.add(\"DataFrameMacros\")","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"在DataFrameMacros.jl中，除了@combine宏，默认情况下所有宏都是按行处理的。还有一个@groupby宏，它允许使用与@transform相同的语法在运行时创建分组列，以便在不需要两次编写它们的情况下按新列进行分组。","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"在下面的示例中，你还可以看到DataFrameMacros.jl的多列功能，其中mean一次应用于通过r\"age\"正则表达式选择的两个年龄列。然后使用\"{}\"快捷方式生成新的列名，该快捷方式将转换的列名插入到字符串中。","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> using DataFrames, DataFrameMacros, Chain, Statistics\n\njulia> df = DataFrame(name=[\"John\", \"Sally\", \"Roger\"],\n                      age=[54.0, 34.0, 79.0],\n                      children=[0, 2, 4])\n3×3 DataFrame\n Row │ name    age      children \n     │ String  Float64  Int64    \n─────┼───────────────────────────\n   1 │ John       54.0         0\n   2 │ Sally      34.0         2\n   3 │ Roger      79.0         4\n\njulia> @chain df begin\n           @transform :age_months = :age * 12\n           @groupby :has_child = :children > 0\n           @combine \"mean_{}\" = mean({r\"age\"})\n       end\n2×3 DataFrame\n Row │ has_child  mean_age  mean_age_months \n     │ Bool       Float64   Float64         \n─────┼──────────────────────────────────────\n   1 │     false      54.0            648.0\n   2 │      true      56.5            678.0","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"还有一种能力是将一组多列作为一个单元引用，例如对它们进行聚合，使用{{ }}语法。在下面的示例中，将第一季度与其他三个季度的最大值进行比较：","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> df = DataFrame(q1 = [12.0, 0.4, 42.7],\n                      q2 = [6.4, 2.3, 40.9],\n                      q3 = [9.5, 0.2, 13.6],\n                      q4 = [6.3, 5.4, 39.3])\n3×4 DataFrame\n Row │ q1       q2       q3       q4      \n     │ Float64  Float64  Float64  Float64 \n─────┼────────────────────────────────────\n   1 │    12.0      6.4      9.5      6.3\n   2 │     0.4      2.3      0.2      5.4\n   3 │    42.7     40.9     13.6     39.3\n\njulia> @transform df :q1_best = :q1 > maximum({{Not(:q1)}})\n3×5 DataFrame\n Row │ q1       q2       q3       q4       q1_best \n     │ Float64  Float64  Float64  Float64  Bool    \n─────┼─────────────────────────────────────────────\n   1 │    12.0      6.4      9.5      6.3     true\n   2 │     0.4      2.3      0.2      5.4    false\n   3 │    42.7     40.9     13.6     39.3     true","category":"page"},{"location":"man/querying_frameworks/#Query.jl","page":"Data manipulation frameworks","title":"Query.jl","text":"","category":"section"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"Query.jl包为DataFrame（以及许多其他数据结构）提供了高级数据操作功能。本节提供了该包的简短介绍，Query.jl文档提供了包的更全面的文档。这里的指示适用于Query.jl的1.0.0版本。","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"首先，安装Query.jl包：","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"using Pkg\nPkg.add(\"Query\")","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"查询以@from宏开始，并由一系列查询命令组成。Query.jl提供了可以过滤，投射，连接，展平和分组DataFrame数据的命令。查询可以返回一个迭代器，或者可以将查询结果实体化到各种数据结构中，包括新的DataFrame。","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"一个简单的查询示例如下：","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> using DataFrames, Query\n\njulia> df = DataFrame(name=[\"John\", \"Sally\", \"Roger\"],\n                      age=[54.0, 34.0, 79.0],\n                      children=[0, 2, 4])\n3×3 DataFrame\n Row │ name    age      children\n     │ String  Float64  Int64\n─────┼───────────────────────────\n   1 │ John       54.0         0\n   2 │ Sally      34.0         2\n   3 │ Roger      79.0         4\n\njulia> q1 = @from i in df begin\n            @where i.age > 40\n            @select {number_of_children=i.children, i.name}\n            @collect DataFrame\n       end\n2×2 DataFrame\n Row │ number_of_children  name\n     │ Int64               String\n─────┼────────────────────────────\n   1 │                  0  John\n   2 │                  4  Roger","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"查询以@from宏开始。第一个参数i是将在后续查询命令中用于引用单个行的范围变量的名称。下一个参数df是你想要查询的数据源。此查询中的@where命令将通过应用过滤条件i.age > 40来过滤源数据。这将过滤掉任何age列不大于40的行。然后，@select命令将源数据的列投射到新的列结构上。这里的示例应用了三个特定的修改：1) 它只保留源DataFrame中的列子集，即转换后的数据不会包含age列；2) 它更改了选定的两列的顺序；和3) 它将选定的一列从children重命名为number_of_children。示例查询使用{}语法来实现这一点。Query.jl表达式中的{}实例化一个新的NamedTuple，即它是编写@NT(number_of_children=>i.children, name=>i.name)的快捷方式。@collect语句确定查询返回的数据结构。在此示例中，结果以DataFrame的形式返回。","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"没有@collect语句的查询返回一个标准的Julia迭代器，可以用任何可以处理迭代器的正常Julia语言结构来使用。以下代码为查询结果返回一个Julia迭代器：","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> q2 = @from i in df begin\n                   @where i.age > 40\n                   @select {number_of_children=i.children, i.name}\n              end; # suppress printing the iterator type\n","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"可以使用标准的Julia for语句遍历结果：","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> total_children = 0\n0\n\njulia> for i in q2\n           global total_children += i.number_of_children\n       end\n\njulia> total_children\n4\n","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"或者可以使用理解（comprehension）来提取一部分行的名称：","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> y = [i.name for i in q2 if i.number_of_children > 0]\n1-element Vector{String}:\n \"Roger\"\n","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"最后一个示例（只提取名称并应用第二个过滤器）当然可以完全表示为查询表达式：","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> q3 = @from i in df begin\n            @where i.age > 40 && i.children > 0\n            @select i.name\n            @collect\n       end\n1-element Vector{String}:\n \"Roger\"\n","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"以@collect语句结束但没有特定类型的查询将查询结果实体化为数组。还要注意@select语句中的区别：前面的查询都在@select语句中使用{}语法将结果投射到表格格式。最后一个查询在@select语句中只从每行中选择一个值。","category":"page"},{"location":"man/querying_frameworks/","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"这些例子只是使用Query.jl可以做的事情的冰山一角，有兴趣的读者可以参考Query.jl文档以获取更多信息。","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/indexing/#Indexing","page":"Indexing","title":"Indexing","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Pages = [\"indexing.md\"]","category":"page"},{"location":"lib/indexing/#General-rules","page":"Indexing","title":"General rules","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The following rules explain target functionality of how getindex, setindex!, view, and broadcasting are intended to work with DataFrame, SubDataFrame and DataFrameRow objects.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The following values are a valid column index:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"a scalar, later denoted as col:\na Symbol;\nan AbstractString;\nan Integer that is not Bool;\na vector, later denoted as cols:\na vector of Symbol (does not have to be a subtype of AbstractVector{Symbol});\na vector of AbstractString (does not have to be a subtype of AbstractVector{<:AbstractString});\na vector of Integer that are not Bool (does not have to be a subtype of AbstractVector{<:Integer});\na vector of Bool (must be a subtype of AbstractVector{Bool});\na regular expression (will be expanded to a vector of matching column names);\na Not expression (see InvertedIndices.jl); Not(idx) selects all indices not in the passed idx; when passed as column selector Not(idx...) is equivalent to Not(Cols(idx...)).\na Cols expression (see DataAPI.jl); Cols(idxs...) selects the union of the selections in idxs; in particular Cols() selects no columns and Cols(:) selects all columns; a special rule is Cols(predicate), where predicate is a predicate function; in this case the columns whose names passed to predicate as strings return true are selected.\na Between expression (see DataAPI.jl); Between(first, last) selects the columns between first and last inclusively;\nan All expression (see DataAPI.jl); All() selects all columns, equivalent to :;\na literal colon : (selects all columns).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The following values are a valid row index:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"a scalar, later denoted as row:\nan Integer that is not Bool;\na vector, later denoted as rows:\na vector of Integer that are not Bool (does not have to be a subtype of AbstractVector{<:Integer});\na vector of Bool (must be a subtype of AbstractVector{Bool});\na Not expression (see InvertedIndices.jl);\na literal colon : (selects all rows with copying);\na literal exclamation mark ! (selects all rows without copying).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Additionally it is allowed to index into an AbstractDataFrame using a two-dimensional CartesianIndex.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"In the descriptions below df represents a DataFrame, sdf is a SubDataFrame and dfr is a DataFrameRow.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":": always expands to axes(df, 1) or axes(sdf, 1).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"df.col works like df[!, col] and sdf.col works like sdf[!, col] in all cases. An exception is that under Julia 1.6 or earlier df.col .= v and sdf.col .= v performs in-place broadcasting if col is present in df/sdf and is a valid identifier (this inconsistency is not present under Julia 1.7 and later).","category":"page"},{"location":"lib/indexing/#getindex-and-view","page":"Indexing","title":"getindex and view","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The following list specifies the behavior of getindex and view operations depending on argument types.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"In particular a description explicitly mentions that the data is copied or reused without copying.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"For performance reasons, accessing, via getindex or view, a single row and multiple cols of a DataFrame, a SubDataFrame or a DataFrameRow always returns a DataFrameRow (which is a view type).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"getindex on DataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"df[row, col] -> the value contained in row row of column col, the same as df[!, col][row];\ndf[CartesianIndex(row, col)] -> the same as df[row, col];\ndf[row, cols] -> a DataFrameRow with parent df;\ndf[rows, col] -> a copy of the vector df[!, col] with only the entries                    corresponding to rows selected, the same as df[!, col][rows];\ndf[rows, cols] -> a DataFrame containing copies of columns cols with                     only the entries corresponding to rows selected;\ndf[!, col] -> the vector contained in column col returned without copying;                 the same as df.col if col is a valid identifier.\ndf[!, cols] -> create a new DataFrame with columns cols without copying                  of columns; the same as select(df, cols, copycols=false).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"view on DataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"@view df[row, col] -> a 0-dimensional view into df[!, col] in row row,                         the same as view(df[!, col], row);\n@view df[CartesianIndex(row, col)] -> the same as @view df[row, col];\n@view df[row, cols] -> the same as df[row, cols];\n@view df[rows, col] -> a view into df[!, col] with rows selected, the                          same as view(df[!, col], rows);\n@view df[rows, cols] -> a SubDataFrame with rows selected with parent df;\n@view df[!, col] -> a view into df[!, col]  with all rows.\n@view df[!, cols] -> the same as @view df[:, cols].","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"getindex on SubDataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"sdf[row, col] -> a value contained in row row of column col;\nsdf[CartesianIndex(row, col)] -> the same as sdf[row, col];\nsdf[row, cols] -> a DataFrameRow with parent parent(sdf);\nsdf[rows, col] -> a copy of sdf[!, col] with only rows rows selected,                     the same as sdf[!, col][rows];\nsdf[rows, cols] -> a DataFrame containing columns cols and sdf[rows, col] as a vector for each col in cols;\nsdf[!, col] -> a view of entries corresponding to sdf in the vector                  parent(sdf)[!, col]; the same as sdf.col if col is a                  valid identifier.\nsdf[!, cols] -> create a new SubDataFrame with columns cols, the same                   parent as sdf, and the same rows selected; the same as                   select(sdf, cols, copycols=false).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"view on SubDataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"@view sdf[row, col] -> a 0-dimensional view into df[!, col] at row                          row, the same as view(sdf[!, col], row);\n@view sdf[CartesianIndex(row, col)] -> the same as @view sdf[row, col];\n@view sdf[row, cols] -> a DataFrameRow with parent parent(sdf);\n@view sdf[rows, col] -> a view into sdf[!, col] vector with rows                           selected, the same as view(sdf[!, col], rows);\n@view sdf[rows, cols] -> a SubDataFrame with parent parent(sdf);\n@view sdf[!, col] -> a view into sdf[!, col] vector with all rows.\n@view sdf[!, cols] -> the same as @view sdf[:, cols].","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"getindex on DataFrameRow:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"dfr[col] -> the value contained in column col of dfr; the same as               dfr.col if col is a valid identifier;\ndfr[cols] -> a DataFrameRow with parent parent(dfr);","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"view on DataFrameRow:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"@view dfr[col] -> a 0-dimensional view into                     parent(dfr)[DataFrames.row(dfr), col];\n@view dfr[cols] -> a DataFrameRow with parent parent(dfr);","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Note that views created with columns selector set to : change their columns' count if columns are added/removed/renamed in the parent; if column selector is other than : then view points to selected columns by their number at the moment of creation of the view.","category":"page"},{"location":"lib/indexing/#setindex!","page":"Indexing","title":"setindex!","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The following list specifies the behavior of setindex! operations depending on argument types.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"In particular a description explicitly mentions if the assignment is in-place.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Note that if a setindex! operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"setindex! on DataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"df[row, col] = v -> set value of col in row row to v in-place;\ndf[CartesianIndex(row, col)] = v -> the same as df[row, col] = v;\ndf[row, cols] = v -> set row row of columns cols in-place; the same as                        dfr = df[row, cols]; dfr[:] = v;\ndf[rows, col] = v -> set rows rows of column col in-place; v must be                        an AbstractVector; if rows is : and col is a                        Symbol or AbstractString that is not present in                        df then a new column in df is created and holds a                        copy of v; equivalent to df.col = copy(v) if                        col is a valid identifier;\ndf[rows, cols] = v -> set rows rows of columns cols in-place; v must                         be an AbstractMatrix or an AbstractDataFrame (in                         this case column names must match);\ndf[!, col] = v -> replaces col with v without copying (with the                     exception that if v is an AbstractRange it gets                     converted to a Vector); also if col is a Symbol or                     AbstractString that is not present in df then a new                     column in df is created and holds v; equivalent to                     df.col = v if col is a valid identifier; this is                     allowed if ncol(df) == 0 || length(v) == nrow(df);\ndf[!, cols] = v -> replaces existing columns cols in data frame df with                      copying; v must be an AbstractMatrix or an                      AbstractDataFrame (in the latter case column names must                      match);","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"setindex! on SubDataFrame:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"sdf[row, col] = v -> set value of col in row row to v in-place;\nsdf[CartesianIndex(row, col)] = v -> the same as sdf[row, col] = v;\nsdf[row, cols] = v -> the same as dfr = df[row, cols]; dfr[:] = v in-place;\nsdf[rows, col] = v -> set rows rows of column col, in-place; v must be                         an abstract vector;\nsdf[rows, cols] = v -> set rows rows of columns cols in-place; v can                          be an AbstractMatrix or v can be                          AbstractDataFrame in which case column names must                          match;\nsdf[!, col] = v -> replaces col with v with copying; if col is present                      in sdf then filtered-out rows in newly created vector                      are filled with values already present in that column and                      promote_type is used to determine the eltype of the                      new column; if col is not present in sdf then the                      operation is only allowed if sdf was created with :                      as column selector, in which case filtered-out rows are                      filled with missing; equivalent to sdf.col = v if                      col is a valid identifier; operation is allowed if                      length(v) == nrow(sdf);\nsdf[!, cols] = v -> replaces existing columns cols in data frame sdf                       with copying; v must be an AbstractMatrix or an                       AbstractDataFrame (in the latter case column names                       must match); filtered-out rows in newly created vectors                       are filled with values already present in respective                       columns and promote_type is used to determine the                       eltype of the new columns;","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"note: Note\nThe rules above mean that sdf[:, col] = v is an in-place operation if col is present in sdf, therefore it will be fast in general. On the other hand using sdf[!, col] = v or sdf.col = v will always allocate a new vector, which is more expensive computationally.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"setindex! on DataFrameRow:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"dfr[col] = v -> set value of col in row row to v in-place;                   equivalent to dfr.col = v if col is a valid identifier;\ndfr[cols] = v -> set values of entries in columns cols in dfr by                    elements of v in place; v can be: 1) a Tuple or an                    AbstractArray, in which cases it must have a number of                    elements equal to length(dfr), 2) an AbstractDict, in                    which case column names must match, 3) a NamedTuple or                    DataFrameRow, in which case column names and order must                    match;","category":"page"},{"location":"lib/indexing/#Broadcasting","page":"Indexing","title":"Broadcasting","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The following broadcasting rules apply to AbstractDataFrame objects:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"AbstractDataFrame behaves in broadcasting like a two-dimensional collection compatible with matrices.\nIf an AbstractDataFrame takes part in broadcasting then a DataFrame is always produced as a result. In this case the requested broadcasting operation produces an object with exactly two dimensions. An exception is when an AbstractDataFrame is used only as a source of broadcast assignment into an object of dimensionality higher than two.\nIf multiple AbstractDataFrame objects take part in broadcasting then they have to have identical column names.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Note that if broadcasting assignment operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Broadcasting DataFrameRow is currently not allowed (which is consistent with NamedTuple).","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"It is possible to assign a value to AbstractDataFrame and DataFrameRow objects using the .= operator. In such an operation AbstractDataFrame is considered as two-dimensional and DataFrameRow as single-dimensional.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"note: Note\nThe rule above means that, similar to single-dimensional objects in Base (e.g. vectors), DataFrameRow is considered to be column-oriented.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Additional rules:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"in the df[CartesianIndex(row, col)] .= v, df[row, col] .= v syntaxes v is broadcasted into the contents of df[row, col] (this is consistent with Julia Base);\nin the df[row, cols] .= v syntaxes the assignment to df is performed in-place;\nin the df[rows, col] .= v and df[rows, cols] .= v syntaxes the assignment to df is performed in-place; if rows is : and col is Symbol or AbstractString and it is missing from df then a new column is allocated and added; the length of the column is always the value of nrow(df) before the assignment takes place;\nin the df[!, col] .= v syntax column col is replaced by a freshly allocated vector; if col is Symbol or AbstractString and it is missing from df then a new column is allocated added; the length of the column is always the value of nrow(df) before the assignment takes place;\nthe df[!, cols] .= v syntax replaces existing columns cols in data frame df with freshly allocated vectors;\ndf.col .= v syntax currently performs in-place assignment to an existing vector df.col; this behavior is deprecated and a new column will be allocated in the future. Starting from Julia 1.7 if :col is not present in df then a new column will be created in df.\nin the sdf[CartesianIndex(row, col)] .= v, sdf[row, col] .= v and sdf[row, cols] .= v syntaxes the assignment to sdf is performed in-place;\nin the sdf[rows, col] .= v and sdf[rows, cols] .= v syntaxes the assignment to sdf is performed in-place; if rows is : and col is a Symbol or AbstractString referring to a column missing from sdf and sdf was created with : as column selector then a new column is allocated and added; the filtered-out rows are filled with missing;\nin the sdf[!, col] .= v syntax column col is replaced by a freshly allocated vector; the filtered-out rows are filled with values already present in col; if col is a Symbol or AbstractString referring to a column missing from sdf and was sdf created with : as column selector then a new column is allocated and added; in this case the filtered-out rows are filled with missing;\nthe sdf[!, cols] .= v syntax replaces existing columns cols in data frame sdf with freshly allocated vectors; the filtered-out rows are filled with values already present in cols;\nsdf.col .= v syntax currently performs in-place assignment to an existing vector sdf.col; this behavior is deprecated and a new column will be allocated in the future. Starting from Julia 1.7 if :col is not present in sdf then a new column will be created in sdf if sdf was created with : as a column selector.\ndfr.col .= v syntax is allowed and performs in-place assignment to a value extracted by dfr.col.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Note that sdf[!, col] .= v and sdf[!, cols] .= v syntaxes are not allowed as sdf can be only modified in-place.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"If column indexing using Symbol or AbstractString names in cols is performed, the order of columns in the operation is specified by the order of names.","category":"page"},{"location":"lib/indexing/#Indexing-GroupedDataFrames","page":"Indexing","title":"Indexing GroupedDataFrames","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"A GroupedDataFrame can behave as either an AbstractVector or AbstractDict depending on the type of index used. Integers (or arrays of them) trigger vector-like indexing while Tupless and NamedTuples trigger dictionary-like indexing. An intermediate between the two is the GroupKey type returned by keys(::GroupedDataFrame), which behaves similarly to a NamedTuple but has performance on par with integer indexing.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"The elements of a GroupedDataFrame are SubDataFrames of its parent.","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"gd[i::Integer] -> Get the ith group.\ngd[key::NamedTuple] -> Get the group corresponding to the given values of the grouping columns. The fields of the NamedTuple must match the grouping columns columns passed to groupby (including order).\ngd[key::Tuple] -> Same as previous, but omitting the names on key.\nget(gd, key::Union{Tuple, NamedTuple}, default) -> Get group for key key, returning default if it does not exist.\ngd[key::GroupKey] -> Get the group corresponding to the GroupKey key (one of the elements of the vector returned by keys(::GroupedDataFrame)). This should be nearly as fast as integer indexing.\ngd[a::AbstractVector] -> Select multiple groups and return them in a new GroupedDataFrame object. Groups may be selected by integer position using an array of Integers or Bools, similar to a standard array. Alternatively the array may contain keys of any of the types supported for dictionary-like indexing (GroupKey, Tuple, or NamedTuple). Selected groups must be unique, and different types of indices cannot be mixed.\ngd[n::Not] -> Any of the above types wrapped in Not. The result will be a  new GroupedDataFrame containing all groups in gd not selected by the  wrapped index.","category":"page"},{"location":"lib/indexing/#Common-API-for-types-defined-in-DataFrames.jl","page":"Indexing","title":"Common API for types defined in DataFrames.jl","text":"","category":"section"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"This table presents return value types of calling names, propertynames, keys, length and ndims on types exposed to the user by DataFrames.jl:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Type names propertynames keys length ndims\nAbstractDataFrame Vector{String} Vector{Symbol} undefined undefined 2\nDataFrameRow Vector{String} Vector{Symbol} Vector{Symbol} Int 1\nDataFrameRows Vector{String} Vector{Symbol} vector of Int Int 1\nDataFrameColumns Vector{String} Vector{Symbol} Vector{Symbol} Int 1\nGroupedDataFrame Vector{String} tuple of fields GroupKeys Int 1\nGroupKeys undefined tuple of fields vector of Int Int 1\nGroupKey Vector{String} Vector{Symbol} Vector{Symbol} Int 1","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"Additionally the above types T (i.e. AbstractDataFrame, DataFrameRow, DataFrameRows, DataFrameColumns, GroupedDataFrame, GroupKeys, GroupKey) the following methods are defined:","category":"page"},{"location":"lib/indexing/","page":"Indexing","title":"Indexing","text":"size(::T) returning a Tuple of Int.\nsize(::T, ::Integer) returning an Int.\naxes(::T) returning a Tuple of Int vectors.\naxes(::T, ::Integer) returning an Int vector for a valid dimension (except  DataFrameRows and GroupKeys for which Base.OneTo(1) is also returned  for a dimension higher than a valid one because they are AbstractVector).\nfirstindex(::T) returning 1 (except AbstractDataFrame for which it is undefined).\nfirstindex(::T, ::Integer) returning 1 for a valid dimension (except  DataFrameRows and GroupKeys for which 1 is also returned for a  dimension higher than a valid one because they are AbstractVector).\nlastindex(::T) returning Int (except AbstractDataFrame for which it is undefined).\nlastindex(::T, ::Integer) returning Int for a valid dimension  (except  DataFrameRows and GroupKeys for which 1 is also returned for a  dimension higher than a valid one because they are AbstractVector).","category":"page"},{"location":"man/reshaping_and_pivoting/#重塑和旋转数据","page":"Reshaping","title":"重塑和旋转数据","text":"","category":"section"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"使用 stack 函数将数据从宽格式转换为长格式：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> using DataFrames, CSV\n\njulia> path = joinpath(pkgdir(DataFrames), \"docs\", \"src\", \"assets\", \"iris.csv\");\n\njulia> iris = CSV.read(path, DataFrame)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         6.8         3.2          5.9         2.3  Iris-virginica\n 145 │         6.7         3.3          5.7         2.5  Iris-virginica\n 146 │         6.7         3.0          5.2         2.3  Iris-virginica\n 147 │         6.3         2.5          5.0         1.9  Iris-virginica\n 148 │         6.5         3.0          5.2         2.0  Iris-virginica\n 149 │         6.2         3.4          5.4         2.3  Iris-virginica\n 150 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                        135 rows omitted\n\njulia> stack(iris, 1:4)\n600×3 DataFrame\n Row │ Species         variable     value\n     │ String15        String       Float64\n─────┼──────────────────────────────────────\n   1 │ Iris-setosa     SepalLength      5.1\n   2 │ Iris-setosa     SepalLength      4.9\n   3 │ Iris-setosa     SepalLength      4.7\n   4 │ Iris-setosa     SepalLength      4.6\n   5 │ Iris-setosa     SepalLength      5.0\n   6 │ Iris-setosa     SepalLength      5.4\n   7 │ Iris-setosa     SepalLength      4.6\n   8 │ Iris-setosa     SepalLength      5.0\n  ⋮  │       ⋮              ⋮          ⋮\n 594 │ Iris-virginica  PetalWidth       2.3\n 595 │ Iris-virginica  PetalWidth       2.5\n 596 │ Iris-virginica  PetalWidth       2.3\n 597 │ Iris-virginica  PetalWidth       1.9\n 598 │ Iris-virginica  PetalWidth       2.0\n 599 │ Iris-virginica  PetalWidth       2.3\n 600 │ Iris-virginica  PetalWidth       1.8\n                            585 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"stack 的第二个可选参数表示要堆叠的列。这些通常被称为测量变量。也可以给出列名：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> stack(iris, [:SepalLength, :SepalWidth, :PetalLength, :PetalWidth])\n600×3 DataFrame\n Row │ Species         variable     value\n     │ String15        String       Float64\n─────┼──────────────────────────────────────\n   1 │ Iris-setosa     SepalLength      5.1\n   2 │ Iris-setosa     SepalLength      4.9\n   3 │ Iris-setosa     SepalLength      4.7\n   4 │ Iris-setosa     SepalLength      4.6\n   5 │ Iris-setosa     SepalLength      5.0\n   6 │ Iris-setosa     SepalLength      5.4\n   7 │ Iris-setosa     SepalLength      4.6\n   8 │ Iris-setosa     SepalLength      5.0\n  ⋮  │       ⋮              ⋮          ⋮\n 594 │ Iris-virginica  PetalWidth       2.3\n 595 │ Iris-virginica  PetalWidth       2.5\n 596 │ Iris-virginica  PetalWidth       2.3\n 597 │ Iris-virginica  PetalWidth       1.9\n 598 │ Iris-virginica  PetalWidth       2.0\n 599 │ Iris-virginica  PetalWidth       2.3\n 600 │ Iris-virginica  PetalWidth       1.8\n                            585 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"注意，所有列可以是不同的类型。类型提升遵循 vcat 的规则。","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"堆叠后的 DataFrame 包括所有未指定为堆叠的列。这些列对于每个堆叠的列都会重复。这些通常被称为标识符（id）列。除了 id 列，还有两个额外的列，标签为 :variable 和 :values，包含列标识符和堆叠的列。","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"stack 的第三个可选参数表示重复的 id 列。这使得指定您希望包含在长格式中的变量更加容易：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> stack(iris, [:SepalLength, :SepalWidth], :Species)\n300×3 DataFrame\n Row │ Species         variable     value\n     │ String15        String       Float64\n─────┼──────────────────────────────────────\n   1 │ Iris-setosa     SepalLength      5.1\n   2 │ Iris-setosa     SepalLength      4.9\n   3 │ Iris-setosa     SepalLength      4.7\n   4 │ Iris-setosa     SepalLength      4.6\n   5 │ Iris-setosa     SepalLength      5.0\n   6 │ Iris-setosa     SepalLength      5.4\n   7 │ Iris-setosa     SepalLength      4.6\n   8 │ Iris-setosa     SepalLength      5.0\n  ⋮  │       ⋮              ⋮          ⋮\n 294 │ Iris-virginica  SepalWidth       3.2\n 295 │ Iris-virginica  SepalWidth       3.3\n 296 │ Iris-virginica  SepalWidth       3.0\n 297 │ Iris-virginica  SepalWidth       2.5\n 298 │ Iris-virginica  SepalWidth       3.0\n 299 │ Iris-virginica  SepalWidth       3.4\n 300 │ Iris-virginica  SepalWidth       3.0\n                            285 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"如果你更喜欢指定 id 列，那么可以像这样使用 Not 和 stack：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> stack(iris, Not(:Species))\n600×3 DataFrame\n Row │ Species         variable     value\n     │ String15        String       Float64\n─────┼──────────────────────────────────────\n   1 │ Iris-setosa     SepalLength      5.1\n   2 │ Iris-setosa     SepalLength      4.9\n   3 │ Iris-setosa     SepalLength      4.7\n   4 │ Iris-setosa     SepalLength      4.6\n   5 │ Iris-setosa     SepalLength      5.0\n   6 │ Iris-setosa     SepalLength      5.4\n   7 │ Iris-setosa     SepalLength      4.6\n   8 │ Iris-setosa     SepalLength      5.0\n  ⋮  │       ⋮              ⋮          ⋮\n 594 │ Iris-virginica  PetalWidth       2.3\n 595 │ Iris-virginica  PetalWidth       2.5\n 596 │ Iris-virginica  PetalWidth       2.3\n 597 │ Iris-virginica  PetalWidth       1.9\n 598 │ Iris-virginica  PetalWidth       2.0\n 599 │ Iris-virginica  PetalWidth       2.3\n 600 │ Iris-virginica  PetalWidth       1.8\n                            585 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"unstack 将数据从长格式转换为宽格式。默认情况下需要指定哪些列是 id 变量、列变量名和列值：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"这是对上述Julia代码和注释的中文翻译：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> iris.id = 1:size(iris, 1)\n1:150\n\njulia> longdf = stack(iris, Not([:Species, :id]))\n600×4 DataFrame\n Row │ Species         id     variable     value\n     │ String15        Int64  String       Float64\n─────┼─────────────────────────────────────────────\n   1 │ Iris-setosa         1  SepalLength      5.1\n   2 │ Iris-setosa         2  SepalLength      4.9\n   3 │ Iris-setosa         3  SepalLength      4.7\n   4 │ Iris-setosa         4  SepalLength      4.6\n   5 │ Iris-setosa         5  SepalLength      5.0\n   6 │ Iris-setosa         6  SepalLength      5.4\n   7 │ Iris-setosa         7  SepalLength      4.6\n   8 │ Iris-setosa         8  SepalLength      5.0\n  ⋮  │       ⋮           ⋮         ⋮          ⋮\n 594 │ Iris-virginica    144  PetalWidth       2.3\n 595 │ Iris-virginica    145  PetalWidth       2.5\n 596 │ Iris-virginica    146  PetalWidth       2.3\n 597 │ Iris-virginica    147  PetalWidth       1.9\n 598 │ Iris-virginica    148  PetalWidth       2.0\n 599 │ Iris-virginica    149  PetalWidth       2.3\n 600 │ Iris-virginica    150  PetalWidth       1.8\n                                   585 rows omitted\n\njulia> unstack(longdf, :id, :variable, :value)\n150×5 DataFrame\n Row │ id     SepalLength  SepalWidth  PetalLength  PetalWidth\n     │ Int64  Float64?     Float64?    Float64?     Float64?\n─────┼─────────────────────────────────────────────────────────\n   1 │     1          5.1         3.5          1.4         0.2\n   2 │     2          4.9         3.0          1.4         0.2\n   3 │     3          4.7         3.2          1.3         0.2\n   4 │     4          4.6         3.1          1.5         0.2\n   5 │     5          5.0         3.6          1.4         0.2\n   6 │     6          5.4         3.9          1.7         0.4\n   7 │     7          4.6         3.4          1.4         0.3\n   8 │     8          5.0         3.4          1.5         0.2\n  ⋮  │   ⋮         ⋮           ⋮            ⋮           ⋮\n 144 │   144          6.8         3.2          5.9         2.3\n 145 │   145          6.7         3.3          5.7         2.5\n 146 │   146          6.7         3.0          5.2         2.3\n 147 │   147          6.3         2.5          5.0         1.9\n 148 │   148          6.5         3.0          5.2         2.0\n 149 │   149          6.2         3.4          5.4         2.3\n 150 │   150          5.9         3.0          5.1         1.8\n                                               135 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"如果剩余的列是唯一的，你可以跳过 id 变量并使用：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> unstack(longdf, :variable, :value)\n150×6 DataFrame\n Row │ Species         id     SepalLength  SepalWidth  PetalLength  PetalWidth ⋯\n     │ String15        Int64  Float64?     Float64?    Float64?     Float64?   ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Iris-setosa         1          5.1         3.5          1.4         0.2 ⋯\n   2 │ Iris-setosa         2          4.9         3.0          1.4         0.2\n   3 │ Iris-setosa         3          4.7         3.2          1.3         0.2\n   4 │ Iris-setosa         4          4.6         3.1          1.5         0.2\n   5 │ Iris-setosa         5          5.0         3.6          1.4         0.2 ⋯\n   6 │ Iris-setosa         6          5.4         3.9          1.7         0.4\n   7 │ Iris-setosa         7          4.6         3.4          1.4         0.3\n   8 │ Iris-setosa         8          5.0         3.4          1.5         0.2\n  ⋮  │       ⋮           ⋮         ⋮           ⋮            ⋮           ⋮      ⋱\n 144 │ Iris-virginica    144          6.8         3.2          5.9         2.3 ⋯\n 145 │ Iris-virginica    145          6.7         3.3          5.7         2.5\n 146 │ Iris-virginica    146          6.7         3.0          5.2         2.3\n 147 │ Iris-virginica    147          6.3         2.5          5.0         1.9\n 148 │ Iris-virginica    148          6.5         3.0          5.2         2.0 ⋯\n 149 │ Iris-virginica    149          6.2         3.4          5.4         2.3\n 150 │ Iris-virginica    150          5.9         3.0          5.1         1.8\n                                                               135 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"你甚至可以跳过传递 :variable 和 :value 值作为位置参数，因为它们将默认被使用，可以这样写：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> unstack(longdf)\n150×6 DataFrame\n Row │ Species         id     SepalLength  SepalWidth  PetalLength  PetalWidth ⋯\n     │ String15        Int64  Float64?     Float64?    Float64?     Float64?   ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Iris-setosa         1          5.1         3.5          1.4         0.2 ⋯\n   2 │ Iris-setosa         2          4.9         3.0          1.4         0.2\n   3 │ Iris-setosa         3          4.7         3.2          1.3         0.2\n   4 │ Iris-setosa         4          4.6         3.1          1.5         0.2\n   5 │ Iris-setosa         5          5.0         3.6          1.4         0.2 ⋯\n   6 │ Iris-setosa         6          5.4         3.9          1.7         0.4\n   7 │ Iris-setosa         7          4.6         3.4          1.4         0.3\n   8 │ Iris-setosa         8          5.0         3.4          1.5         0.2\n  ⋮  │       ⋮           ⋮         ⋮           ⋮            ⋮           ⋮      ⋱\n 144 │ Iris-virginica    144          6.8         3.2          5.9         2.3 ⋯\n 145 │ Iris-virginica    145          6.7         3.3          5.7         2.5\n 146 │ Iris-virginica    146          6.7         3.0          5.2         2.3\n 147 │ Iris-virginica    147          6.3         2.5          5.0         1.9\n 148 │ Iris-virginica    148          6.5         3.0          5.2         2.0 ⋯\n 149 │ Iris-virginica    149          6.2         3.4          5.4         2.3\n 150 │ Iris-virginica    150          5.9         3.0          5.1         1.8\n                                                               135 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"将 view=true 传递给 stack 会返回一个数据框，其列是原始宽数据框的视图。以下是一个例子：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> stack(iris, view=true)\n600×4 DataFrame\n Row │ Species         id     variable     value\n     │ String15        Int64  String       Float64\n─────┼─────────────────────────────────────────────\n   1 │ Iris-setosa         1  SepalLength      5.1\n   2 │ Iris-setosa         2  SepalLength      4.9\n   3 │ Iris-setosa         3  SepalLength      4.7\n   4 │ Iris-setosa         4  SepalLength      4.6\n   5 │ Iris-setosa         5  SepalLength      5.0\n   6 │ Iris-setosa         6  SepalLength      5.4\n   7 │ Iris-setosa         7  SepalLength      4.6\n   8 │ Iris-setosa         8  SepalLength      5.0\n  ⋮  │       ⋮           ⋮         ⋮          ⋮\n 594 │ Iris-virginica    144  PetalWidth       2.3\n 595 │ Iris-virginica    145  PetalWidth       2.5\n 596 │ Iris-virginica    146  PetalWidth       2.3\n 597 │ Iris-virginica    147  PetalWidth       1.9\n 598 │ Iris-virginica    148  PetalWidth       2.0\n 599 │ Iris-virginica    149  PetalWidth       2.3\n 600 │ Iris-virginica    150  PetalWidth       1.8\n                                   585 rows omitted","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"这样可以节省内存。为了创建这个视图，定义了几个AbstractVector：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":":variable列 – EachRepeatedVector 这将变量重复N次，其中N是原始AbstractDataFrame的行数。","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":":value列 – StackedVector 这提供了原始列堆叠在一起的视图。","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"Id列 – RepeatedVector 这将原始列重复N次，其中N是堆叠的列数。","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"要进行聚合，可以使用split-apply-combine函数与 unstack结合，或者在unstack中使用combine关键字参数。以下是一个例子：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> using Statistics\n\njulia> d = stack(iris, Not(:Species))\n750×3 DataFrame\n Row │ Species         variable     value\n     │ String15        String       Float64\n─────┼──────────────────────────────────────\n   1 │ Iris-setosa     SepalLength      5.1\n   2 │ Iris-setosa     SepalLength      4.9\n   3 │ Iris-setosa     SepalLength      4.7\n   4 │ Iris-setosa     SepalLength      4.6\n   5 │ Iris-setosa     SepalLength      5.0\n   6 │ Iris-setosa     SepalLength      5.4\n   7 │ Iris-setosa     SepalLength      4.6\n   8 │ Iris-setosa     SepalLength      5.0\n  ⋮  │       ⋮              ⋮          ⋮\n 744 │ Iris-virginica  id             144.0\n 745 │ Iris-virginica  id             145.0\n 746 │ Iris-virginica  id             146.0\n 747 │ Iris-virginica  id             147.0\n 748 │ Iris-virginica  id             148.0\n 749 │ Iris-virginica  id             149.0\n 750 │ Iris-virginica  id             150.0\n                            735 rows omitted\n\njulia> agg = combine(groupby(d, [:variable, :Species]), :value => mean => :vmean)\n15×3 DataFrame\n Row │ variable     Species          vmean\n     │ String       String15         Float64\n─────┼───────────────────────────────────────\n   1 │ SepalLength  Iris-setosa        5.006\n   2 │ SepalLength  Iris-versicolor    5.936\n   3 │ SepalLength  Iris-virginica     6.588\n   4 │ SepalWidth   Iris-setosa        3.418\n   5 │ SepalWidth   Iris-versicolor    2.77\n   6 │ SepalWidth   Iris-virginica     2.974\n   7 │ PetalLength  Iris-setosa        1.464\n   8 │ PetalLength  Iris-versicolor    4.26\n   9 │ PetalLength  Iris-virginica     5.552\n  10 │ PetalWidth   Iris-setosa        0.244\n  11 │ PetalWidth   Iris-versicolor    1.326\n  12 │ PetalWidth   Iris-virginica     2.026\n  13 │ id           Iris-setosa       25.5\n  14 │ id           Iris-versicolor   75.5\n  15 │ id           Iris-virginica   125.5\n\njulia> unstack(agg, :variable, :Species, :vmean)\n5×4 DataFrame\n Row │ variable     Iris-setosa  Iris-versicolor  Iris-virginica\n     │ String       Float64?     Float64?         Float64?\n─────┼───────────────────────────────────────────────────────────\n   1 │ SepalLength        5.006            5.936           6.588\n   2 │ SepalWidth         3.418            2.77            2.974\n   3 │ PetalLength        1.464            4.26            5.552\n   4 │ PetalWidth         0.244            1.326           2.026\n   5 │ id                25.5             75.5           125.5\n\njulia> unstack(d, :variable, :Species, :value, combine=mean)\n5×4 DataFrame\n Row │ variable     Iris-setosa  Iris-versicolor  Iris-virginica\n     │ String       Float64?     Float64?         Float64?\n─────┼───────────────────────────────────────────────────────────\n   1 │ SepalLength        5.006            5.936           6.588\n   2 │ SepalWidth         3.418            2.77            2.974\n   3 │ PetalLength        1.464            4.26            5.552\n   4 │ PetalWidth         0.244            1.326           2.026\n   5 │ id                25.5             75.5           125.5","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"要将AbstractDataFrame转置，可以使用permutedims函数。","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> df1 = DataFrame(a=[\"x\", \"y\"], b=[1.0, 2.0], c=[3, 4], d=[true, false])\n2×4 DataFrame\n Row │ a       b        c      d\n     │ String  Float64  Int64  Bool\n─────┼───────────────────────────────\n   1 │ x           1.0      3   true\n   2 │ y           2.0      4  false\n\njulia> permutedims(df1, 1)\n3×3 DataFrame\n Row │ a       x        y\n     │ String  Float64  Float64\n─────┼──────────────────────────\n   1 │ b           1.0      2.0\n   2 │ c           3.0      4.0\n   3 │ d           1.0      0.0","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"请注意，原始df中由src_colnames索引的列在转置结果中成为列名，原始列名成为新列。这通常用于具有同类元素类型的列，因为其他列的元素类型是对所有转置列的promote_type结果。还要注意，默认情况下，从原始df的列名创建的新列与src_namescol的名称相同。可选的位置参数dest_namescol可以改变这一点：","category":"page"},{"location":"man/reshaping_and_pivoting/","page":"Reshaping","title":"Reshaping","text":"julia> df2 = DataFrame(a=[\"x\", \"y\"], b=[1, \"two\"], c=[3, 4], d=[true, false])\n2×4 DataFrame\n Row │ a       b    c      d\n     │ String  Any  Int64  Bool\n─────┼───────────────────────────\n   1 │ x       1        3   true\n   2 │ y       two      4  false\n\njulia> permutedims(df2, 1, \"different_name\")\n3×3 DataFrame\n Row │ different_name  x     y\n     │ String          Any   Any\n─────┼─────────────────────────────\n   1 │ b               1     two\n   2 │ c               3     4\n   3 │ d               true  false","category":"page"},{"location":"man/categorical/#man-categorical","page":"Categorical Data","title":"分类数据","text":"","category":"section"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"我们经常需要处理数据框中的某些列，这些列只包含少数几个级别的数据：","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> v = [\"Group A\", \"Group A\", \"Group A\", \"Group B\", \"Group B\", \"Group B\"]\n6-element Vector{String}:\n \"Group A\"\n \"Group A\"\n \"Group A\"\n \"Group B\"\n \"Group B\"\n \"Group B\"","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"在Vector中使用的朴素编码将此向量的每个条目表示为一个完整的字符串。相比之下，我们可以通过将字符串替换为对少数级别的索引，更有效地表示数据。这样做有两个好处。第一，这种向量往往会使用更少的内存。第二，可以使用groupby函数有效地对其进行分组。","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"有两种常见的类型允许执行级别池化：","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"来自PooledArrays.jl的PooledVector；\n来自CategoricalArrays.jl的CategoricalVector。","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"PooledVector和CategoricalVector之间的区别如下：","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"PooledVector适用于数据压缩是唯一目标的情况；\nCategoricalVector被设计为同时提供全面的支持  用于处理分类变量，无论是无序的 （名义变量）还是有序的类别（序数变量），但代价是 只允许AbstractString、AbstractChar或Number元素类型 （可选地与Missing联合）。","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"当数组中的唯一值（级别）应该尊重有意义的排序时，CategoricalVector特别有用，例如在打印表格、绘制图表或拟合回归模型时。CategoricalArrays.jl提供了设置和检索此顺序以及根据它比较值的函数。相反，PooledVector类型实际上是Vector的替代品，几乎没有用户可见的差异，除了更低的内存使用和更高的性能。","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"下面我们展示了使用CategoricalArrays.jl的一些选定示例。 有关分类数组的更多信息，请参阅CategoricalArrays.jl文档包。 也请注意，本节我们只讨论向量，因为我们正在考虑数据框上下文。然而，一般来说，这两个包都允许处理任何维度的数组。","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"要跟随下面的例子，你需要先安装CategoricalArrays.jl包。","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> using CategoricalArrays\n\njulia> cv = categorical(v)\n6-element CategoricalArray{String,1,UInt32}:\n \"Group A\"\n \"Group A\"\n \"Group A\"\n \"Group B\"\n \"Group B\"\n \"Group B\"","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"CategoricalVectors支持缺失值。","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> cv = categorical([\"Group A\", missing, \"Group A\",\n                         \"Group B\", \"Group B\", missing])\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missing","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"除了有效地表示重复数据外，CategoricalArray 类型还允许我们使用levels函数随时有效地确定变量的允许级别（注意，级别可能实际上在数据中使用或未使用）：","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> levels(cv)\n2-element Vector{String}:\n \"Group A\"\n \"Group B\"","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"levels!函数还允许改变级别出现的顺序，这在显示目的或处理有序变量时可能有用。","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> levels!(cv, [\"Group B\", \"Group A\"])\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missing\n\njulia> levels(cv)\n2-element Vector{String}:\n \"Group B\"\n \"Group A\"\n\njulia> sort(cv)\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group B\"\n \"Group B\"\n \"Group A\"\n \"Group A\"\n missing\n missing","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"默认情况下，CategoricalVector能够表示2^32个不同的级别。你可以通过调用compress函数使用更少的内存：","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> cv = compress(cv)\n6-element CategoricalArray{Union{Missing, String},1,UInt8}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missing\n","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"categorical函数还接受一个关键字参数compress，当设置为true时，等同于在新向量上调用compress：","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> cv1 = categorical([\"A\", \"B\"], compress=true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"如果ordered关键字参数设置为true，结果 CategoricalVector将是有序的，这意味着它的级别可以被测试 为顺序（而不是抛出错误）：","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> cv2 = categorical([\"A\", \"B\"], ordered=true)\n2-element CategoricalArray{String,1,UInt32}:\n \"A\"\n \"B\"\n\njulia> cv1[1] < cv1[2]\nERROR: ArgumentError: Unordered CategoricalValue objects cannot be tested for order using <. Use isless instead, or call the ordered! function on the parent array to change this\n\njulia> cv2[1] < cv2[2]\ntrue","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"你可以使用isordered函数检查CategoricalVector是否有序，并使用ordered!函数在有序和无序之间切换。","category":"page"},{"location":"man/categorical/","page":"Categorical Data","title":"Categorical Data","text":"julia> isordered(cv1)\nfalse\n\njulia> ordered!(cv1, true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"\n\njulia> isordered(cv1)\ntrue\n\njulia> cv1[1] < cv1[2]\ntrue","category":"page"},{"location":"man/sorting/#排序","page":"Sorting","title":"排序","text":"","category":"section"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"排序是数据分析的基本组成部分。基本排序很简单：只需调用 sort! 就可以原地对所有列进行排序：","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"julia> using DataFrames, CSV\n\njulia> path = joinpath(pkgdir(DataFrames), \"docs\", \"src\", \"assets\", \"iris.csv\");\n\njulia> iris = CSV.read(path, DataFrame)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         6.8         3.2          5.9         2.3  Iris-virginica\n 145 │         6.7         3.3          5.7         2.5  Iris-virginica\n 146 │         6.7         3.0          5.2         2.3  Iris-virginica\n 147 │         6.3         2.5          5.0         1.9  Iris-virginica\n 148 │         6.5         3.0          5.2         2.0  Iris-virginica\n 149 │         6.2         3.4          5.4         2.3  Iris-virginica\n 150 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                        135 rows omitted\n\njulia> sort!(iris)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         4.3         3.0          1.1         0.1  Iris-setosa\n   2 │         4.4         2.9          1.4         0.2  Iris-setosa\n   3 │         4.4         3.0          1.3         0.2  Iris-setosa\n   4 │         4.4         3.2          1.3         0.2  Iris-setosa\n   5 │         4.5         2.3          1.3         0.3  Iris-setosa\n   6 │         4.6         3.1          1.5         0.2  Iris-setosa\n   7 │         4.6         3.2          1.4         0.2  Iris-setosa\n   8 │         4.6         3.4          1.4         0.3  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         7.4         2.8          6.1         1.9  Iris-virginica\n 145 │         7.6         3.0          6.6         2.1  Iris-virginica\n 146 │         7.7         2.6          6.9         2.3  Iris-virginica\n 147 │         7.7         2.8          6.7         2.0  Iris-virginica\n 148 │         7.7         3.0          6.1         2.3  Iris-virginica\n 149 │         7.7         3.8          6.7         2.2  Iris-virginica\n 150 │         7.9         3.8          6.4         2.0  Iris-virginica\n                                                        135 rows omitted","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"请注意，在对 DataFrame 进行排序时，所有列都会按字典顺序考虑。","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"你也可以调用 sort 函数来创建一个新的 DataFrame，其中包含新分配的排序向量。","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"在排序 DataFrame 时，你可能希望用不同的选项对不同的列进行排序。以下是一些示例，展示了大部分可能的选项：","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"julia> sort!(iris, rev = true)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         7.9         3.8          6.4         2.0  Iris-virginica\n   2 │         7.7         3.8          6.7         2.2  Iris-virginica\n   3 │         7.7         3.0          6.1         2.3  Iris-virginica\n   4 │         7.7         2.8          6.7         2.0  Iris-virginica\n   5 │         7.7         2.6          6.9         2.3  Iris-virginica\n   6 │         7.6         3.0          6.6         2.1  Iris-virginica\n   7 │         7.4         2.8          6.1         1.9  Iris-virginica\n   8 │         7.3         2.9          6.3         1.8  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         4.6         3.2          1.4         0.2  Iris-setosa\n 145 │         4.6         3.1          1.5         0.2  Iris-setosa\n 146 │         4.5         2.3          1.3         0.3  Iris-setosa\n 147 │         4.4         3.2          1.3         0.2  Iris-setosa\n 148 │         4.4         3.0          1.3         0.2  Iris-setosa\n 149 │         4.4         2.9          1.4         0.2  Iris-setosa\n 150 │         4.3         3.0          1.1         0.1  Iris-setosa\n                                                        135 rows omitted\n\njulia> sort!(iris, [:Species, :SepalWidth])\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         4.5         2.3          1.3         0.3  Iris-setosa\n   2 │         4.4         2.9          1.4         0.2  Iris-setosa\n   3 │         5.0         3.0          1.6         0.2  Iris-setosa\n   4 │         4.9         3.0          1.4         0.2  Iris-setosa\n   5 │         4.8         3.0          1.4         0.3  Iris-setosa\n   6 │         4.8         3.0          1.4         0.1  Iris-setosa\n   7 │         4.4         3.0          1.3         0.2  Iris-setosa\n   8 │         4.3         3.0          1.1         0.1  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         6.7         3.3          5.7         2.1  Iris-virginica\n 145 │         6.3         3.3          6.0         2.5  Iris-virginica\n 146 │         6.3         3.4          5.6         2.4  Iris-virginica\n 147 │         6.2         3.4          5.4         2.3  Iris-virginica\n 148 │         7.2         3.6          6.1         2.5  Iris-virginica\n 149 │         7.9         3.8          6.4         2.0  Iris-virginica\n 150 │         7.7         3.8          6.7         2.2  Iris-virginica\n                                                        135 rows omitted\n\njulia> sort!(iris, [order(:Species, by=length), order(:SepalLength, rev=true)])\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼───────────────────────────────────────────────────────────────────\n   1 │         5.8         4.0          1.2         0.2  Iris-setosa\n   2 │         5.7         3.8          1.7         0.3  Iris-setosa\n   3 │         5.7         4.4          1.5         0.4  Iris-setosa\n   4 │         5.5         3.5          1.3         0.2  Iris-setosa\n   5 │         5.5         4.2          1.4         0.2  Iris-setosa\n   6 │         5.4         3.4          1.7         0.2  Iris-setosa\n   7 │         5.4         3.4          1.5         0.4  Iris-setosa\n   8 │         5.4         3.7          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮              ⋮\n 144 │         5.5         2.6          4.4         1.2  Iris-versicolor\n 145 │         5.4         3.0          4.5         1.5  Iris-versicolor\n 146 │         5.2         2.7          3.9         1.4  Iris-versicolor\n 147 │         5.1         2.5          3.0         1.1  Iris-versicolor\n 148 │         5.0         2.0          3.5         1.0  Iris-versicolor\n 149 │         5.0         2.3          3.3         1.0  Iris-versicolor\n 150 │         4.9         2.4          3.3         1.0  Iris-versicolor\n                                                         135 rows omitted","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"上面使用的关键字包括 rev（用于逆序排序），和 by（用于在比较值之前对它们应用函数）。每个关键字可以是单个值，可以是与各列对应的值的向量，也可以是选择器：:、Cols、All、Not、Between 或 Regex。","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"作为使用向量值的替代方法，你可以使用 order 来指定一组列中特定列的排序。","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"以下两个示例展示了两种对 iris 数据集进行排序的方法，结果相同：Species 将以反向顺序排序，而在组内，行将按 PetalLength 的增序排序：","category":"page"},{"location":"man/sorting/","page":"Sorting","title":"Sorting","text":"julia> sort!(iris, [:Species, :PetalLength], rev=[true, false])\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         4.9         2.5          4.5         1.7  Iris-virginica\n   2 │         6.2         2.8          4.8         1.8  Iris-virginica\n   3 │         6.0         3.0          4.8         1.8  Iris-virginica\n   4 │         6.3         2.7          4.9         1.8  Iris-virginica\n   5 │         6.1         3.0          4.9         1.8  Iris-virginica\n   6 │         5.6         2.8          4.9         2.0  Iris-virginica\n   7 │         6.3         2.5          5.0         1.9  Iris-virginica\n   8 │         6.0         2.2          5.0         1.5  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         4.7         3.2          1.6         0.2  Iris-setosa\n 145 │         5.7         3.8          1.7         0.3  Iris-setosa\n 146 │         5.4         3.4          1.7         0.2  Iris-setosa\n 147 │         5.4         3.9          1.7         0.4  Iris-setosa\n 148 │         5.1         3.3          1.7         0.5  Iris-setosa\n 149 │         5.1         3.8          1.9         0.4  Iris-setosa\n 150 │         4.8         3.4          1.9         0.2  Iris-setosa\n                                                        135 rows omitted\n\njulia> sort!(iris, [order(:Species, rev=true), :PetalLength])\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         4.9         2.5          4.5         1.7  Iris-virginica\n   2 │         6.2         2.8          4.8         1.8  Iris-virginica\n   3 │         6.0         3.0          4.8         1.8  Iris-virginica\n   4 │         6.3         2.7          4.9         1.8  Iris-virginica\n   5 │         6.1         3.0          4.9         1.8  Iris-virginica\n   6 │         5.6         2.8          4.9         2.0  Iris-virginica\n   7 │         6.3         2.5          5.0         1.9  Iris-virginica\n   8 │         6.0         2.2          5.0         1.5  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         4.7         3.2          1.6         0.2  Iris-setosa\n 145 │         5.7         3.8          1.7         0.3  Iris-setosa\n 146 │         5.4         3.4          1.7         0.2  Iris-setosa\n 147 │         5.4         3.9          1.7         0.4  Iris-setosa\n 148 │         5.1         3.3          1.7         0.5  Iris-setosa\n 149 │         5.1         3.8          1.9         0.4  Iris-setosa\n 150 │         4.8         3.4          1.9         0.2  Iris-setosa\n                                                        135 rows omitted","category":"page"},{"location":"man/working_with_dataframes/#Working-with-Data-Frames","page":"Working with DataFrames","title":"Working with Data Frames","text":"","category":"section"},{"location":"man/working_with_dataframes/#Examining-the-Data","page":"Working with DataFrames","title":"Examining the Data","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The default printing of DataFrame objects only includes a sample of rows and columns that fits on screen:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using DataFrames\n\njulia> df = DataFrame(A=1:2:1000, B=repeat(1:10, inner=50), C=1:500)\n500×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     3      1      2\n   3 │     5      1      3\n   4 │     7      1      4\n   5 │     9      1      5\n   6 │    11      1      6\n   7 │    13      1      7\n   8 │    15      1      8\n  ⋮  │   ⋮      ⋮      ⋮\n 494 │   987     10    494\n 495 │   989     10    495\n 496 │   991     10    496\n 497 │   993     10    497\n 498 │   995     10    498\n 499 │   997     10    499\n 500 │   999     10    500\n           485 rows omitted","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Printing options can be adjusted by calling the show function manually: show(df, allrows=true) prints all rows even if they do not fit on screen and show(df, allcols=true) does the same for columns.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The first and last functions can be used to look at the first and last rows of a data frame (respectively):","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> first(df, 6)\n6×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     3      1      2\n   3 │     5      1      3\n   4 │     7      1      4\n   5 │     9      1      5\n   6 │    11      1      6\n\njulia> last(df, 6)\n6×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │   989     10    495\n   2 │   991     10    496\n   3 │   993     10    497\n   4 │   995     10    498\n   5 │   997     10    499\n   6 │   999     10    500","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Also notice that when DataFrame is printed to the console or rendered in HTML (e.g. in Jupyter Notebook) you get an information about type of elements held in its columns. For example in this case:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using CategoricalArrays\n\njulia> DataFrame(a=1:2, b=[1.0, missing],\n                 c=categorical('a':'b'), d=[1//2, missing])\n2×4 DataFrame\n Row │ a      b          c     d\n     │ Int64  Float64?   Cat…  Rational…?\n─────┼────────────────────────────────────\n   1 │     1        1.0  a           1//2\n   2 │     2  missing    b        missing\n","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"we can observe that:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"the first column :a can hold elements of type Int64;\nthe second column :b can hold Float64 or Missing, which is indicated by ? printed after the name of type;\nthe third column :c can hold categorical data; here we notice …, which indicates that the actual name of the type was long and got truncated;\nthe type information in fourth column :d presents a situation where the name is both truncated and the type allows Missing.","category":"page"},{"location":"man/working_with_dataframes/#Taking-a-Subset","page":"Working with DataFrames","title":"Taking a Subset","text":"","category":"section"},{"location":"man/working_with_dataframes/#Indexing-syntax","page":"Working with DataFrames","title":"Indexing syntax","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Specific subsets of a data frame can be extracted using the indexing syntax, similar to matrices. In the Indexing section of the manual you can find all the details about the available options. Here we highlight the basic options.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The colon : indicates that all items (rows or columns depending on its position) should be retained:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df[1:3, :]\n3×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     3      1      2\n   3 │     5      1      3\n\njulia> df[[1, 5, 10], :]\n3×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     9      1      5\n   3 │    19      1     10\n\njulia> df[:, [:A, :B]]\n500×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     3      1\n   3 │     5      1\n   4 │     7      1\n   5 │     9      1\n   6 │    11      1\n   7 │    13      1\n   8 │    15      1\n  ⋮  │   ⋮      ⋮\n 494 │   987     10\n 495 │   989     10\n 496 │   991     10\n 497 │   993     10\n 498 │   995     10\n 499 │   997     10\n 500 │   999     10\n    485 rows omitted\n\njulia> df[1:3, [:B, :A]]\n3×2 DataFrame\n Row │ B      A\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     1      3\n   3 │     1      5\n\njulia> df[[3, 1], [:C]]\n2×1 DataFrame\n Row │ C\n     │ Int64\n─────┼───────\n   1 │     3\n   2 │     1","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Do note that df[!, [:A]] and df[:, [:A]] return a DataFrame object, while df[!, :A] and df[:, :A] return a vector:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df[!, [:A]]\n500×1 DataFrame\n Row │ A\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     3\n   3 │     5\n   4 │     7\n   5 │     9\n   6 │    11\n   7 │    13\n   8 │    15\n  ⋮  │   ⋮\n 494 │   987\n 495 │   989\n 496 │   991\n 497 │   993\n 498 │   995\n 499 │   997\n 500 │   999\n485 rows omitted\n\njulia> df[!, [:A]] == df[:, [:A]]\ntrue\n\njulia> df[!, :A]\n500-element Vector{Int64}:\n   1\n   3\n   5\n   7\n   9\n  11\n  13\n  15\n  17\n  19\n   ⋮\n 983\n 985\n 987\n 989\n 991\n 993\n 995\n 997\n 999\n\njulia> df[!, :A] == df[:, :A]\ntrue","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"In the first case, [:A] is a vector, indicating that the resulting object should be a DataFrame. On the other hand, :A is a single symbol, indicating that a single column vector should be extracted. Note that in the first case a vector is required to be passed (not just any iterable), so e.g. df[:, (:x1, :x2)] is not allowed, but df[:, [:x1, :x2]] is valid.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"It is also possible to use a regular expression as a selector of columns matching it:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(x1=1, x2=2, y=3)\n1×3 DataFrame\n Row │ x1     x2     y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> df[!, r\"x\"]\n1×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"A Not selector (from the InvertedIndices package) can be used to select all columns excluding a specific subset:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df[!, Not(:x1)]\n1×2 DataFrame\n Row │ x2     y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      3","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Finally, you can use Not, Between, Cols and All selectors in more complex column selection scenarios (note that Cols() selects no columns while All() selects all columns therefore Cols is a preferred selector if you write generic code). Here are examples of using each of these selectors:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(r=1, x1=2, x2=3, y=4)\n1×4 DataFrame\n Row │ r      x1     x2     y\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      3      4\n\njulia> df[:, Not(:r)] # drop :r column\n1×3 DataFrame\n Row │ x1     x2     y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      3      4\n\njulia> df[:, Between(:r, :x2)] # keep columns between :r and :x2\n1×3 DataFrame\n Row │ r      x1     x2\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> df[:, All()] # keep all columns\n1×4 DataFrame\n Row │ r      x1     x2     y\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      3      4\n\njulia> df[:, Cols(x -> startswith(x, \"x\"))] # keep columns whose name starts with \"x\"\n1×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      3","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The following examples show a more complex use of the Cols selector, which moves all columns whose names match r\"x\" regular expression respectively to the front and to the end of the data frame:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df[:, Cols(r\"x\", :)]\n1×4 DataFrame\n Row │ x1     x2     r      y\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     2      3      1      4\n\njulia> df[:, Cols(Not(r\"x\"), :)]\n1×4 DataFrame\n Row │ r      y      x1     x2\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      4      2      3","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The indexing syntax can also be used to select rows based on conditions on variables:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(A=1:2:1000, B=repeat(1:10, inner=50), C=1:500)\n500×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     3      1      2\n   3 │     5      1      3\n   4 │     7      1      4\n   5 │     9      1      5\n   6 │    11      1      6\n   7 │    13      1      7\n   8 │    15      1      8\n  ⋮  │   ⋮      ⋮      ⋮\n 494 │   987     10    494\n 495 │   989     10    495\n 496 │   991     10    496\n 497 │   993     10    497\n 498 │   995     10    498\n 499 │   997     10    499\n 500 │   999     10    500\n           485 rows omitted\n\njulia> df[df.A .> 500, :]\n250×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │   501      6    251\n   2 │   503      6    252\n   3 │   505      6    253\n   4 │   507      6    254\n   5 │   509      6    255\n   6 │   511      6    256\n   7 │   513      6    257\n   8 │   515      6    258\n  ⋮  │   ⋮      ⋮      ⋮\n 244 │   987     10    494\n 245 │   989     10    495\n 246 │   991     10    496\n 247 │   993     10    497\n 248 │   995     10    498\n 249 │   997     10    499\n 250 │   999     10    500\n           235 rows omitted\n\njulia> df[(df.A .> 500) .& (300 .< df.C .< 400), :]\n99×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │   601      7    301\n   2 │   603      7    302\n   3 │   605      7    303\n   4 │   607      7    304\n   5 │   609      7    305\n   6 │   611      7    306\n   7 │   613      7    307\n   8 │   615      7    308\n  ⋮  │   ⋮      ⋮      ⋮\n  93 │   785      8    393\n  94 │   787      8    394\n  95 │   789      8    395\n  96 │   791      8    396\n  97 │   793      8    397\n  98 │   795      8    398\n  99 │   797      8    399\n            84 rows omitted","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Where a specific subset of values needs to be matched, the in() function can be applied:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df[in.(df.A, Ref([1, 5, 601])), :]\n3×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     5      1      3\n   3 │   601      7    301","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The Ref wrapper to [1, 5, 601] is needed to protect the vector against being broadcasted over (the vector will be treated as a scalar when wrapped in Ref). You could write this operation using a comprehension like this (note that it would be slower so it is not recommended): [a in [1, 5, 601] for a in df.A].","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Equivalently, the in function can be called with a single argument to create a function object that tests whether each value belongs to the subset (partial application of in): df[in([1, 5, 601]).(df.A), :].","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"note: Note\nAs with matrices, subsetting from a data frame will usually return a copy of columns, not a view or direct reference.The only indexing situations where data frames will not return a copy are:when a ! is placed in the first indexing position (df[!, :A], or df[!, [:A, :B]]),\nwhen using . (getpropery) notation (df.A),\nwhen a single row is selected using an integer (df[1, [:A, :B]])\nwhen view or @view is used (e.g. @view df[1:3, :A]).More details on copies, views, and references can be found in the getindex and view section.","category":"page"},{"location":"man/working_with_dataframes/#Subsetting-functions","page":"Working with DataFrames","title":"Subsetting functions","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"An alternative approach to row subsetting in a data frame is to use the subset function, or the subset! function, which is its in-place variant.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"These functions take a data frame as their first argument. The following positional arguments (one or more) are filtering condition specifications that must be jointly met. Each condition should be passed as a Pair consisting of source column(s) and a function specifying the filtering condition taking this or these column(s) as arguments:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> subset(df, :A => a -> a .< 10, :C => c -> isodd.(c))\n3×3 DataFrame\n Row │ A      B      C\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      1\n   2 │     5      1      3\n   3 │     9      1      5","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"It is a frequent situation that missing values might be present in the filtering columns, which could then lead the filtering condition to return missing instead of the expected true or false. In order to handle this situation one can either use the coalesce function or pass the skipmissing=true keyword argument to subset. Here is an example:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(x=[1, 2, missing, 4])\n4×1 DataFrame\n Row │ x\n     │ Int64?\n─────┼─────────\n   1 │       1\n   2 │       2\n   3 │ missing\n   4 │       4\n\njulia> subset(df, :x => x -> coalesce.(iseven.(x), false))\n2×1 DataFrame\n Row │ x\n     │ Int64?\n─────┼────────\n   1 │      2\n   2 │      4\n\njulia> subset(df, :x => x -> iseven.(x), skipmissing=true)\n2×1 DataFrame\n Row │ x\n     │ Int64?\n─────┼────────\n   1 │      2\n   2 │      4","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The subset function has been designed in a way that is consistent with how column transformations are specified in functions like combine, select, and transform. Examples of column transformations accepted by these functions are provided in the following section.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Additionally DataFrames.jl extends the filter and filter! functions provided in Julia Base, which also allow subsetting a data frame. These methods are defined so that DataFrames.jl implements the Julia API for collections, but it is generally recommended to use the subset and subset! functions instead, as they are consistent with other DataFrames.jl functions (as opposed to filter and filter!).","category":"page"},{"location":"man/working_with_dataframes/#Selecting-and-transforming-columns","page":"Working with DataFrames","title":"Selecting and transforming columns","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"You can also use the select/select! and transform/transform! functions to select, rename and transform columns in a data frame.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The select function creates a new data frame:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(x1=[1, 2], x2=[3, 4], y=[5, 6])\n2×3 DataFrame\n Row │ x1     x2     y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      3      5\n   2 │     2      4      6\n\njulia> select(df, Not(:x1)) # drop column :x1 in a new data frame\n2×2 DataFrame\n Row │ x2     y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     3      5\n   2 │     4      6\n\njulia> select(df, r\"x\") # select columns containing 'x' character\n2×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> select(df, :x1 => :a1, :x2 => :a2) # rename columns\n2×2 DataFrame\n Row │ a1     a2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> select(df, :x1, :x2 => (x -> x .- minimum(x)) => :x2) # transform columns\n2×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      1\n\njulia> select(df, :x2, :x2 => ByRow(sqrt)) # transform columns by row\n2×2 DataFrame\n Row │ x2     x2_sqrt\n     │ Int64  Float64\n─────┼────────────────\n   1 │     3  1.73205\n   2 │     4  2.0\n\njulia> select(df, :x1, :x2, [:x1, :x2] => ((x1, x2) -> x1 ./ x2) => :z) # transform multiple columns\n2×3 DataFrame\n Row │ x1     x2     z\n     │ Int64  Int64  Float64\n─────┼────────────────────────\n   1 │     1      3  0.333333\n   2 │     2      4  0.5\n\njulia> select(df, :x1, :x2, [:x1, :x2] => ByRow((x1, x2) -> x1 / x2) => :z)  # transform multiple columns by row\n2×3 DataFrame\n Row │ x1     x2     z\n     │ Int64  Int64  Float64\n─────┼────────────────────────\n   1 │     1      3  0.333333\n   2 │     2      4  0.5\n\njulia> select(df, AsTable(:) => ByRow(extrema) => [:lo, :hi]) # return multiple columns\n2×2 DataFrame\n Row │ lo     hi\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      5\n   2 │     2      6","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"It is important to note that select always returns a data frame, even if a single column is selected (as opposed to indexing syntax).","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> select(df, :x1)\n2×1 DataFrame\n Row │ x1\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> df[:, :x1]\n2-element Vector{Int64}:\n 1\n 2","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"By default select copies columns of a passed source data frame. In order to avoid copying, pass copycols=false:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df2 = select(df, :x1)\n2×1 DataFrame\n Row │ x1\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> df2.x1 === df.x1\nfalse\n\njulia> df2 = select(df, :x1, copycols=false)\n2×1 DataFrame\n Row │ x1\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> df2.x1 === df.x1\ntrue","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"To perform the selection operation in-place use select!:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> select!(df, Not(:x1));\n\njulia> df\n2×2 DataFrame\n Row │ x2     y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     3      5\n   2 │     4      6","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"transform and transform! functions work identically to select and select!, with the only difference that they retain all columns that are present in the source data frame. Here are some more advanced examples.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"First we show how to generate a column that is a sum of all other columns in the data frame using the All() selector:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(x1=[1, 2], x2=[3, 4], y=[5, 6])\n2×3 DataFrame\n Row │ x1     x2     y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      3      5\n   2 │     2      4      6\n\njulia> transform(df, All() => +)\n2×4 DataFrame\n Row │ x1     x2     y      x1_x2_y_+\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────────\n   1 │     1      3      5          9\n   2 │     2      4      6         12","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Using the ByRow wrapper, we can easily compute for each row the name of column with the highest score:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using Random\n\njulia> Random.seed!(1);\n\njulia> df = DataFrame(rand(10, 3), [:a, :b, :c])\n10×3 DataFrame\n Row │ a           b          c\n     │ Float64     Float64    Float64\n─────┼──────────────────────────────────\n   1 │ 0.236033    0.555751   0.0769509\n   2 │ 0.346517    0.437108   0.640396\n   3 │ 0.312707    0.424718   0.873544\n   4 │ 0.00790928  0.773223   0.278582\n   5 │ 0.488613    0.28119    0.751313\n   6 │ 0.210968    0.209472   0.644883\n   7 │ 0.951916    0.251379   0.0778264\n   8 │ 0.999905    0.0203749  0.848185\n   9 │ 0.251662    0.287702   0.0856352\n  10 │ 0.986666    0.859512   0.553206\n\njulia> transform(df, AsTable(:) => ByRow(argmax) => :prediction)\n10×4 DataFrame\n Row │ a           b          c          prediction\n     │ Float64     Float64    Float64    Symbol\n─────┼──────────────────────────────────────────────\n   1 │ 0.236033    0.555751   0.0769509  b\n   2 │ 0.346517    0.437108   0.640396   c\n   3 │ 0.312707    0.424718   0.873544   c\n   4 │ 0.00790928  0.773223   0.278582   b\n   5 │ 0.488613    0.28119    0.751313   c\n   6 │ 0.210968    0.209472   0.644883   c\n   7 │ 0.951916    0.251379   0.0778264  a\n   8 │ 0.999905    0.0203749  0.848185   a\n   9 │ 0.251662    0.287702   0.0856352  b\n  10 │ 0.986666    0.859512   0.553206   a","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"In the most complex example below we compute row-wise sum, number of elements, and mean, while ignoring missing values.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using Statistics\n\njulia> df = DataFrame(x=[1, 2, missing], y=[1, missing, missing])\n3×2 DataFrame\n Row │ x        y\n     │ Int64?   Int64?\n─────┼──────────────────\n   1 │       1        1\n   2 │       2  missing\n   3 │ missing  missing\n\njulia> transform(df, AsTable(:) .=>\n                     ByRow.([sum∘skipmissing,\n                             x -> count(!ismissing, x),\n                             mean∘skipmissing]) .=>\n                     [:sum, :n, :mean])\n3×5 DataFrame\n Row │ x        y        sum    n      mean\n     │ Int64?   Int64?   Int64  Int64  Float64\n─────┼─────────────────────────────────────────\n   1 │       1        1      2      2      1.0\n   2 │       2  missing      2      1      2.0\n   3 │ missing  missing      0      0    NaN","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"While the DataFrames.jl package provides basic data manipulation capabilities, users are encouraged to use querying frameworks for more convenient and powerful operations:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"the Query.jl package provides a LINQ-like interface to a large number of data sources\nthe DataFramesMeta.jl package provides interfaces similar to LINQ and dplyr\nthe DataFrameMacros.jl package provides macros for most standard functions from DataFrames.jl, with convenient syntax for the manipulation of multiple columns at once.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"See the 数据操作框架 section for more information.","category":"page"},{"location":"man/working_with_dataframes/#Summarizing-Data","page":"Working with DataFrames","title":"Summarizing Data","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The describe function returns a data frame summarizing the elementary statistics and information about each column:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(A=1:4, B=[\"M\", \"F\", \"F\", \"M\"])\n4×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  F\n   3 │     3  F\n   4 │     4  M\n\njulia> describe(df)\n2×7 DataFrame\n Row │ variable  mean    min  median  max  nmissing  eltype\n     │ Symbol    Union…  Any  Union…  Any  Int64     DataType\n─────┼────────────────────────────────────────────────────────\n   1 │ A         2.5     1    2.5     4           0  Int64\n   2 │ B                 F            M           0  String","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"If you are interested in describing only a subset of columns, then the easiest way to do it is to pass a subset of an original data frame to describe like this:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> describe(df[!, [:A]])\n1×7 DataFrame\n Row │ variable  mean     min    median   max    nmissing  eltype\n     │ Symbol    Float64  Int64  Float64  Int64  Int64     DataType\n─────┼──────────────────────────────────────────────────────────────\n   1 │ A             2.5      1      2.5      4         0  Int64","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Of course, one can also compute descriptive statistics directly on individual columns:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using Statistics\n\njulia> mean(df.A)\n2.5","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"We can also apply a function to each column of a DataFrame using combine. For example:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(A=1:4, B=4.0:-1.0:1.0)\n4×2 DataFrame\n Row │ A      B\n     │ Int64  Float64\n─────┼────────────────\n   1 │     1      4.0\n   2 │     2      3.0\n   3 │     3      2.0\n   4 │     4      1.0\n\njulia> combine(df, names(df) .=> sum)\n1×2 DataFrame\n Row │ A_sum  B_sum\n     │ Int64  Float64\n─────┼────────────────\n   1 │    10     10.0\n\njulia> combine(df, names(df) .=> sum, names(df) .=> prod)\n1×4 DataFrame\n Row │ A_sum  B_sum    A_prod  B_prod\n     │ Int64  Float64  Int64   Float64\n─────┼─────────────────────────────────\n   1 │    10     10.0      24     24.0","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"If you would prefer the result to have the same number of rows as the source data frame, use select instead of combine.","category":"page"},{"location":"man/working_with_dataframes/#Handling-of-Columns-Stored-in-a-DataFrame","page":"Working with DataFrames","title":"Handling of Columns Stored in a DataFrame","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Functions that transform a DataFrame to produce a new DataFrame always perform a copy of the columns by default, for example:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df = DataFrame(A=1:4, B=4.0:-1.0:1.0)\n4×2 DataFrame\n Row │ A      B\n     │ Int64  Float64\n─────┼────────────────\n   1 │     1      4.0\n   2 │     2      3.0\n   3 │     3      2.0\n   4 │     4      1.0\n\njulia> df2 = copy(df);\n\njulia> df2.A === df.A\nfalse","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"On the other hand, in-place functions, whose names end with !, may mutate the column vectors of the DataFrame they take as an argument. For example:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> x = [3, 1, 2];\n\njulia> df = DataFrame(x=x)\n3×1 DataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     3\n   2 │     1\n   3 │     2\n\njulia> sort!(df)\n3×1 DataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> x\n3-element Vector{Int64}:\n 3\n 1\n 2\n\njulia> df.x[1] = 100\n100\n\njulia> df\n3×1 DataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │   100\n   2 │     2\n   3 │     3\n\njulia> x\n3-element Vector{Int64}:\n 3\n 1\n 2","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Note that in the above example the original x vector is not mutated in the process, as the DataFrame(x=x) constructor makes a copy by default.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"In-place functions are safe to call, except when a view of the DataFrame (created via a view, @view or groupby) or when a DataFrame created with copycols=false are in use.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"It is possible to have a direct access to a column col of a DataFrame df using the syntaxes df.col, df[!, :col], via the eachcol function, by accessing a parent of a view of a column of a DataFrame, or simply by storing the reference to the column vector before the DataFrame was created with copycols=false.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> x = [3, 1, 2];\n\njulia> df = DataFrame(x=x)\n3×1 DataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     3\n   2 │     1\n   3 │     2\n\njulia> df.x == x\ntrue\n\njulia> df[!, 1] !== x\ntrue\n\njulia> eachcol(df)[1] === df.x\ntrue","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Note that a column obtained from a DataFrame using one of these methods should not be mutated without caution.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"The exact rules of handling columns of a DataFrame are explained in The design of handling of columns of a DataFrame section of the manual.","category":"page"},{"location":"man/working_with_dataframes/#Replacing-Data","page":"Working with DataFrames","title":"Replacing Data","text":"","category":"section"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Several approaches can be used to replace some values with others in a data frame. Some apply the replacement to all values in a data frame, and others to individual columns or subset of columns.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Do note that in-place replacement requires that the replacement value can be converted to the column's element type. In particular, this implies that replacing a value with missing requires a call to allowmissing! if the column did not allow for missing values.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Replacement operations affecting a single column can be performed using replace!:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> using DataFrames\n\njulia> df = DataFrame(a=[\"a\", \"None\", \"b\", \"None\"], b=1:4,\n                      c=[\"None\", \"j\", \"k\", \"h\"], d=[\"x\", \"y\", \"None\", \"z\"])\n4×4 DataFrame\n Row │ a       b      c       d\n     │ String  Int64  String  String\n─────┼───────────────────────────────\n   1 │ a           1  None    x\n   2 │ None        2  j       y\n   3 │ b           3  k       None\n   4 │ None        4  h       z\n\njulia> replace!(df.a, \"None\" => \"c\")\n4-element Vector{String}:\n \"a\"\n \"c\"\n \"b\"\n \"c\"\n\njulia> df\n4×4 DataFrame\n Row │ a       b      c       d\n     │ String  Int64  String  String\n─────┼───────────────────────────────\n   1 │ a           1  None    x\n   2 │ c           2  j       y\n   3 │ b           3  k       None\n   4 │ c           4  h       z","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"This is equivalent to df.a = replace(df.a, \"None\" => \"c\"), but operates in-place, without allocating a new column vector.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Replacement operations on multiple columns or on the whole data frame can be performed in-place using the broadcasting syntax:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"# replacement on a subset of columns [:c, :d]\njulia> df[:, [:c, :d]] .= ifelse.(df[!, [:c, :d]] .== \"None\", \"c\", df[!, [:c, :d]])\n4×2 SubDataFrame\n Row │ c       d\n     │ String  String\n─────┼────────────────\n   1 │ c       x\n   2 │ j       y\n   3 │ k       c\n   4 │ h       z\n\njulia> df\n4×4 DataFrame\n Row │ a       b      c       d\n     │ String  Int64  String  String\n─────┼───────────────────────────────\n   1 │ a           1  c       x\n   2 │ c           2  j       y\n   3 │ b           3  k       c\n   4 │ c           4  h       z\n\njulia> df .= ifelse.(df .== \"c\", \"None\", df) # replacement on entire data frame\n4×4 DataFrame\n Row │ a       b      c       d\n     │ String  Int64  String  String\n─────┼───────────────────────────────\n   1 │ a           1  None    x\n   2 │ None        2  j       y\n   3 │ b           3  k       None\n   4 │ None        4  h       z","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"Do note that in the above examples, changing .= to just = will allocate new column vectors instead of applying the operation in-place.","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"When replacing values with missing, if the columns do not already allow for missing values, one has to either avoid in-place operation and use = instead of .=, or call allowmissing! beforehand:","category":"page"},{"location":"man/working_with_dataframes/","page":"Working with DataFrames","title":"Working with DataFrames","text":"julia> df2 = ifelse.(df .== \"None\", missing, df) # do not operate in-place (`df = ` would also work)\n4×4 DataFrame\n Row │ a        b      c        d\n     │ String?  Int64  String?  String?\n─────┼──────────────────────────────────\n   1 │ a            1  missing  x\n   2 │ missing      2  j        y\n   3 │ b            3  k        missing\n   4 │ missing      4  h        z\n\njulia> allowmissing!(df) # operate in-place after allowing for missing\n4×4 DataFrame\n Row │ a        b       c        d\n     │ String?  Int64?  String?  String?\n─────┼───────────────────────────────────\n   1 │ a             1  None     x\n   2 │ None          2  j        y\n   3 │ b             3  k        None\n   4 │ None          4  h        z\n\njulia> df .= ifelse.(df .== \"None\", missing, df)\n4×4 DataFrame\n Row │ a        b       c        d\n     │ String?  Int64?  String?  String?\n─────┼───────────────────────────────────\n   1 │ a             1  missing  x\n   2 │ missing       2  j        y\n   3 │ b             3  k        missing\n   4 │ missing       4  h        z","category":"page"},{"location":"man/comparisons/#比较","page":"Comparison with Python/R/Stata","title":"比较","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"本节将DataFrames.jl与Python、R和Stata中的其他数据操作框架进行比较。","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"可以使用以下代码创建一个示例数据集：","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"using DataFrames\nusing Statistics\n\ndf = DataFrame(grp=repeat(1:2, 3), x=6:-1:1, y=4:9, z=[3:7; missing], id='a':'f')\ndf2 = DataFrame(grp=[1, 3], w=[10, 11])","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"note: Note\n某些操作会改变表格，因此每个操作都假设在原始数据框上进行。","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"请注意，在下面的比较中，像 x -> x >= 1 这样的谓词可以更简洁地写为 =>(1)。后一种形式还具有额外的好处，它在每个Julia会话中只编译一次（而 x -> x >= 1 每次引入时都会定义一个新的匿名函数）。","category":"page"},{"location":"man/comparisons/#与Python包pandas的比较","page":"Comparison with Python/R/Stata","title":"与Python包pandas的比较","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"下表比较了DataFrames.jl的主要函数与Python包pandas（版本1.1.0）的对应函数：","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({'grp': [1, 2, 1, 2, 1, 2],\n                   'x': range(6, 0, -1),\n                   'y': range(4, 10),\n                   'z': [3, 4, 5, 6, 7, None]},\n                   index = list('abcdef'))\ndf2 = pd.DataFrame({'grp': [1, 3], 'w': [10, 11]})","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"由于pandas支持多索引，此示例数据框使用 a 到 f 作为行索引，而不是单独的 id 列。","category":"page"},{"location":"man/comparisons/#访问数据","page":"Comparison with Python/R/Stata","title":"访问数据","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 pandas DataFrames.jl\n位置索引单元格 df.iloc[1, 1] df[2, 2]\n位置切片行 df.iloc[1:3] df[2:3, :]\n位置切片列 df.iloc[:, 1:] df[:, 2:end]\n标签索引行 df.loc['c'] df[findfirst(==('c'), df.id), :]\n标签索引列 df.loc[:, 'x'] df[:, :x]\n标签切片列 df.loc[:, ['x', 'z']] df[:, [:x, :z]]\n df.loc[:, 'x':'z'] df[:, Between(:x, :z)]\n混合索引 df.loc['c'][1] df[findfirst(==('c'), df.id), 2]","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"请注意，Julia使用基于1的索引，两端都包含。特殊关键字 end 可用于表示最后一个索引。同样，关键字 begin 可用于表示第一个索引。","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"此外，使用 findfirst 函数索引数据框时，返回一个单独的 DataFrameRow 对象。如果 id 不唯一，可以使用 findall 函数或布尔索引。它将返回一个包含所有匹配行的 DataFrame 对象。下面的两行代码是功能上等价的：","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"df[findall(==('c'), df.id), :]\ndf[df.id .== 'c', :]","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"DataFrames.jl的索引始终产生一致和可预测的返回类型。相比之下，pandas的 loc 函数在索引值为 'c' 的索引中只有一个值时返回一个 Series 对象，而在有多个索引值为 'c' 的行时返回一个 DataFrame 对象。","category":"page"},{"location":"man/comparisons/#常见操作","page":"Comparison with Python/R/Stata","title":"常见操作","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 pandas DataFrames.jl\n求多个值的平均值 df['z'].mean(skipna = False) mean(df.z)\n df['z'].mean() mean(skipmissing(df.z))\n df[['z']].agg(['mean']) combine(df, :z => mean ∘ skipmissing)\n添加新列 df.assign(z1 = df['z'] + 1) transform(df, :z => (v -> v .+ 1) => :z1)\n重命名列 df.rename(columns = {'x': 'x_new'}) rename(df, :x => :x_new)\n选择和转换列 df.assign(x_mean = df['x'].mean())[['x_mean', 'y']] select(df, :x => mean, :y)\n排序行 df.sort_values(by = 'x') sort(df, :x)\n df.sort_values(by = ['grp', 'x'], ascending = [True, False]) sort(df, [:grp, order(:x, rev = true)])\n删除缺失行 df.dropna() dropmissing(df)\n选择唯一行 df.drop_duplicates() unique(df)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"请注意，pandas默认情况下在其分析函数中跳过NaN值。相比之下， Julia函数不会跳过NaN值。如果需要，在处理之前可以过滤掉 NaN值，例如mean(Iterators.filter(!isnan, x))。","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"Pandas使用NaN表示缺失数据和浮点数的\"not a number\"值。 Julia为表示缺失数据定义了一个特殊值missing。DataFrames.jl在默认情况下遵守 Julia中有关传播missing值的一般规则。如果需要， 可以使用skipmissing函数删除缺失数据。 有关更多信息，请参阅缺失数据部分。","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"此外，pandas在应用函数后保留原始列名。 DataFrames.jl默认情况下在列名后附加后缀。为了简化起见， 上述示例没有在pandas和DataFrames.jl之间同步列名 （可以向select、transform和combine函数传递renamecols=false关键字参数以保留旧列名）。","category":"page"},{"location":"man/comparisons/#可变操作","page":"Comparison with Python/R/Stata","title":"可变操作","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 pandas DataFrames.jl\n添加新列 df['z1'] = df['z'] + 1 df.z1 = df.z .+ 1\n  transform!(df, :z => (x -> x .+ 1) => :z1)\n df.insert(1, 'const', 10) insertcols!(df, 2, :const => 10)\n重命名列 df.rename(columns = {'x': 'x_new'}, inplace = True) rename!(df, :x => :x_new)\n排序行 df.sort_values(by = 'x', inplace = True) sort!(df, :x)\n删除缺失行 df.dropna(inplace = True) dropmissing!(df)\n选择唯一行 df.drop_duplicates(inplace = True) unique!(df)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"一般来说，DataFrames.jl 遵循 Julia 的约定，在函数名中使用 ! 表示修改行为。","category":"page"},{"location":"man/comparisons/#分组数据和聚合","page":"Comparison with Python/R/Stata","title":"分组数据和聚合","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"DataFrames.jl 提供了 groupby 函数来对每个组进行操作。groupby 的结果是一个 GroupedDataFrame 对象，可以使用 combine、transform 或 select 函数对其进行处理。下表列举了一些常见的分组和聚合用法。","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 pandas DataFrames.jl\n按组聚合 df.groupby('grp')['x'].mean() combine(groupby(df, :grp), :x => mean)\n聚合后重命名列 df.groupby('grp')['x'].mean().rename(\"my_mean\") combine(groupby(df, :grp), :x => mean => :my_mean)\n添加聚合数据作为列 df.join(df.groupby('grp')['x'].mean(), on='grp', rsuffix='_mean') transform(groupby(df, :grp), :x => mean)\n...并选择输出列 df.join(df.groupby('grp')['x'].mean(), on='grp', rsuffix='_mean')[['grp', 'x_mean']] select(groupby(df, :grp), :id, :x => mean)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"请注意，pandas 对于一维结果返回一个 Series 对象，除非之后调用 reset_index。 相应的 DataFrames.jl 示例返回一个等价的 DataFrame 对象。 考虑第一个示例：","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":">>> df.groupby('grp')['x'].mean()\ngrp\n1    4\n2    3\nName: x, dtype: int64","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"在 DataFrames.jl 中，它看起来是这样的：","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"julia> combine(groupby(df, :grp), :x => mean)\n2×2 DataFrame\n Row │ grp    x_mean\n     │ Int64  Float64\n─────┼────────────────\n   1 │     1      4.0\n   2 │     2      3.0","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"在 DataFrames.jl 中，GroupedDataFrame 对象支持高效的键查找。因此，当需要重复执行查找时，它的性能表现良好。","category":"page"},{"location":"man/comparisons/#更高级的命令","page":"Comparison with Python/R/Stata","title":"更高级的命令","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"本节包括更复杂的示例。","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 pandas DataFrames.jl\n复杂函数 df[['z']].agg(lambda v: np.mean(np.cos(v))) combine(df, :z => v -> mean(cos, skipmissing(v)))\n聚合多列数据 df.agg({'x': max, 'y': min}) combine(df, :x => maximum, :y => minimum)\n df[['x', 'y']].mean() combine(df, [:x, :y] .=> mean)\n df.filter(regex=(\"^x\")).mean() combine(df, names(df, r\"^x\") .=> mean)\n应用函数于多个变量 df.assign(x_y_cor = np.corrcoef(df.x, df.y)[0, 1]) transform(df, [:x, :y] => cor)\n逐行操作 df.assign(x_y_min = df.apply(lambda v: min(v.x, v.y), axis=1)) transform(df, [:x, :y] => ByRow(min))\n df.assign(x_y_argmax = df.apply(lambda v: df.columns[v.argmax()], axis=1)) transform(df, AsTable([:x, :y]) => ByRow(argmax))\n以DataFrame作为输入 df.groupby('grp').head(2) combine(d -> first(d, 2), groupby(df, :grp))\n以DataFrame作为输出 df[['x']].agg(lambda x: [min(x), max(x)]) combine(df, :x => (x -> (x=[minimum(x), maximum(x)],)) => AsTable)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"请注意，pandas在groupby之后保留相同的行顺序，而DataFrames.jl在combine操作之后按提供的键进行分组， 但select和transform保留原始的行顺序。","category":"page"},{"location":"man/comparisons/#连接数据框","page":"Comparison with Python/R/Stata","title":"连接数据框","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"DataFrames.jl支持类似关系数据库的连接操作。","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 pandas DataFrames.jl\n内连接 pd.merge(df, df2, how = 'inner', on = 'grp') innerjoin(df, df2, on = :grp)\n外连接 pd.merge(df, df2, how = 'outer', on = 'grp') outerjoin(df, df2, on = :grp)\n左连接 pd.merge(df, df2, how = 'left', on = 'grp') leftjoin(df, df2, on = :grp)\n右连接 pd.merge(df, df2, how = 'right', on = 'grp') rightjoin(df, df2, on = :grp)\n半连接 (过滤) df[df.grp.isin(df2.grp)] semijoin(df, df2, on = :grp)\n反连接 (过滤) df[~df.grp.isin(df2.grp)] antijoin(df, df2, on = :grp)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"对于多列连接，pandas和DataFrames.jl都接受一个数组作为on关键字参数。","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"在半连接和反连接的情况下，pandas中的isin函数仍然可以使用，只要连接键以元组的形式组合起来。 在DataFrames.jl中，只需在on关键字参数中指定连接键的数组即可正常工作。","category":"page"},{"location":"man/comparisons/#与R包dplyr的比较","page":"Comparison with Python/R/Stata","title":"与R包dplyr的比较","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"下表比较了DataFrames.jl的主要函数与R包dplyr（版本1）的对应关系：","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"df <- tibble(grp = rep(1:2, 3), x = 6:1, y = 4:9,\n             z = c(3:7, NA), id = letters[1:6])","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 dplyr DataFrames.jl\n多值归约 summarize(df, mean(x)) combine(df, :x => mean)\n添加新列 mutate(df, x_mean = mean(x)) transform(df, :x => mean => :x_mean)\n重命名列 rename(df, x_new = x) rename(df, :x => :x_new)\n选择列 select(df, x, y) select(df, :x, :y)\n选择并转换列 transmute(df, mean(x), y) select(df, :x => mean, :y)\n选择行 filter(df, x >= 1) subset(df, :x => ByRow(x -> x >= 1))\n排序行 arrange(df, x) sort(df, :x)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"与dplyr类似，这些函数中的一些可以应用于分组的数据框，此时它们按组进行操作：","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 dplyr DataFrames.jl\n多值归约 summarize(group_by(df, grp), mean(x)) combine(groupby(df, :grp), :x => mean)\n添加新列 mutate(group_by(df, grp), mean(x)) transform(groupby(df, :grp), :x => mean)\n选择并转换列 transmute(group_by(df, grp), mean(x), y) select(groupby(df, :grp), :x => mean, :y)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"下表比较了更高级的命令：","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 dplyr DataFrames.jl\n复杂函数 summarize(df, mean(x, na.rm = T)) combine(df, :x => x -> mean(skipmissing(x)))\n转换多列数据 summarize(df, max(x), min(y)) combine(df, :x => maximum,  :y => minimum)\n summarize(df, across(c(x, y), mean)) combine(df, [:x, :y] .=> mean)\n summarize(df, across(starts_with(\"x\"), mean)) combine(df, names(df, r\"^x\") .=> mean)\n summarize(df, across(c(x, y), list(max, min))) combine(df, ([:x, :y] .=> [maximum minimum])...)\n多变量函数 mutate(df, cor(x, y)) transform(df, [:x, :y] => cor)\n逐行操作 mutate(rowwise(df), min(x, y)) transform(df, [:x, :y] => ByRow(min))\n mutate(rowwise(df), which.max(c_across(matches(\"^x\")))) transform(df, AsTable(r\"^x\") => ByRow(argmax))\n以DataFrame作为输入 summarize(df, head(across(), 2)) combine(d -> first(d, 2), df)\n以DataFrame作为输出 summarize(df, tibble(value = c(min(x), max(x)))) combine(df, :x => (x -> (value = [minimum(x), maximum(x)],)) => AsTable)","category":"page"},{"location":"man/comparisons/#与-R-包-data.table-的比较","page":"Comparison with Python/R/Stata","title":"与 R 包 data.table 的比较","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"下表比较了 DataFrames.jl 的主要函数与 R 包 data.table（版本 1.14.1）的对应关系。","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"library(data.table)\ndf  <- data.table(grp = rep(1:2, 3), x = 6:1, y = 4:9,\n                  z = c(3:7, NA), id = letters[1:6])\ndf2 <- data.table(grp=c(1,3), w = c(10,11))","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 data.table DataFrames.jl\n多值归约 df[, .(mean(x))] combine(df, :x => mean)\n添加新列 df[, x_mean:=mean(x) ] transform!(df, :x => mean => :x_mean)\n重命名列（原地操作） setnames(df, \"x\", \"x_new\") rename!(df, :x => :x_new)\n重命名多列（原地操作） setnames(df, c(\"x\", \"y\"), c(\"x_new\", \"y_new\")) rename!(df, [:x, :y] .=> [:x_new, :y_new])\n选择列作为 DataFrame df[, .(x, y)] select(df, :x, :y)\n选择列作为向量 df[, x] df[!, :x]\n删除列 df[, -\"x\"] select(df, Not(:x))\n删除列（原地操作） df[, x:=NULL] select!(df, Not(:x))\n删除多列（原地操作） df[, c(\"x\", \"y\"):=NULL] select!(df, Not([:x, :y]))\n选择并转换列 df[, .(mean(x), y)] select(df, :x => mean, :y)\n选择行 df[ x >= 1 ] filter(:x => >=(1), df)\n排序行（原地操作） setorder(df, x) sort!(df, :x)\n排序行 df[ order(x) ] sort(df, :x)","category":"page"},{"location":"man/comparisons/#数据分组和聚合","page":"Comparison with Python/R/Stata","title":"数据分组和聚合","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 data.table DataFrames.jl\n多值归约 df[, mean(x), by=id ] combine(groupby(df, :id), :x => mean)\n添加新列（原地操作） df[, x_mean:=mean(x), by=id] transform!(groupby(df, :id), :x => mean)\n选择并转换列 df[, .(x_mean = mean(x), y), by=id] select(groupby(df, :id), :x => mean, :y)","category":"page"},{"location":"man/comparisons/#更高级的命令-2","page":"Comparison with Python/R/Stata","title":"更高级的命令","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 data.table DataFrames.jl\n复杂函数 df[, .(mean(x, na.rm=TRUE)) ] combine(df, :x => x -> mean(skipmissing(x)))\n转换特定行（原地操作） df[x<=0, x:=0] df.x[df.x .<= 0] .= 0\n转换多列 df[, .(max(x), min(y)) ] combine(df, :x => maximum, :y => minimum)\n df[, lapply(.SD, mean), .SDcols = c(\"x\", \"y\") ] combine(df, [:x, :y] .=> mean)\n df[, lapply(.SD, mean), .SDcols = patterns(\"*x\") ] combine(df, names(df, r\"^x\") .=> mean)\n df[, unlist(lapply(.SD, function(x) c(max=max(x), min=min(x)))), .SDcols = c(\"x\", \"y\") ] combine(df, ([:x, :y] .=> [maximum minimum])...)\n多变量函数 df[, .(cor(x,y)) ] transform(df, [:x, :y] => cor)\n逐行操作 df[, min_xy := min(x, y), by = 1:nrow(df)] transform!(df, [:x, :y] => ByRow(min))\n df[, argmax_xy := which.max(.SD) , .SDcols = patterns(\"*x\"), by = 1:nrow(df) ] transform!(df, AsTable(r\"^x\") => ByRow(argmax))\n输出为 DataFrame df[, .SD[1], by=grp] combine(groupby(df, :grp), first)\n输出为 DataFrame df[, .SD[which.max(x)], by=grp] combine(groupby(df, :grp), sdf -> sdf[argmax(sdf.x), :])","category":"page"},{"location":"man/comparisons/#连接数据框-2","page":"Comparison with Python/R/Stata","title":"连接数据框","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 data.table DataFrames.jl\n内连接 merge(df, df2, on = \"grp\") innerjoin(df, df2, on = :grp)\n外连接 merge(df, df2, all = TRUE, on = \"grp\") outerjoin(df, df2, on = :grp)\n左连接 merge(df, df2, all.x = TRUE, on = \"grp\") leftjoin(df, df2, on = :grp)\n右连接 merge(df, df2, all.y = TRUE, on = \"grp\") rightjoin(df, df2, on = :grp)\n反连接（过滤） df[!df2, on = \"grp\" ] antijoin(df, df2, on = :grp)\n半连接（过滤） merge(df1, df2[, .(grp)]) semijoin(df, df2, on = :grp)","category":"page"},{"location":"man/comparisons/#与-Stata（8-版及以上版本）的比较","page":"Comparison with Python/R/Stata","title":"与 Stata（8 版及以上版本）的比较","text":"","category":"section"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"下表比较了 DataFrames.jl 的主要功能与 Stata 的对应关系：","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 Stata DataFrames.jl\n多值合并 collapse (mean) x combine(df, :x => mean)\n添加新列 egen x_mean = mean(x) transform!(df, :x => mean => :x_mean)\n重命名列 rename x x_new rename!(df, :x => :x_new)\n选择列 keep x y select!(df, :x, :y)\n选择行 keep if x >= 1 subset!(df, :x => ByRow(x -> x >= 1))\n排序行 sort x sort!(df, :x)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"需要注意的是后缀 !（例如 transform!、select! 等）表示操作会直接在原始数据框上进行修改，与 Stata 中的操作方式类似。","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"其中一些函数可以应用于分组数据框，此时它们将按组进行操作：","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 Stata DataFrames.jl\n添加新列 egen x_mean = mean(x), by(grp) transform!(groupby(df, :grp), :x => mean)\n多值合并 collapse (mean) x, by(grp) combine(groupby(df, :grp), :x => mean)","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"下表比较了更高级的命令：","category":"page"},{"location":"man/comparisons/","page":"Comparison with Python/R/Stata","title":"Comparison with Python/R/Stata","text":"操作 Stata DataFrames.jl\n转换特定行 replace x = 0 if x <= 0 transform(df, :x => (x -> ifelse.(x .<= 0, 0, x)) => :x)\n转换多个列 collapse (max) x (min) y combine(df, :x => maximum,  :y => minimum)\n collapse (mean) x y combine(df, [:x, :y] .=> mean)\n collapse (mean) x* combine(df, names(df, r\"^x\") .=> mean)\n collapse (max) x y (min) x y combine(df, ([:x, :y] .=> [maximum minimum])...)\n多变量函数 egen z = corr(x y) transform!(df, [:x, :y] => cor => :z)\n逐行处理 egen z = rowmin(x y) transform!(df, [:x, :y] => ByRow(min) => :z)","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"lib/types/#Type-hierarchy-design","page":"Types","title":"Type hierarchy design","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"AbstractDataFrame is an abstract type that provides an interface for data frame types. It is not intended as a fully generic interface for working with tabular data, which is the role of interfaces defined by Tables.jl instead.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"DataFrame is the most fundamental subtype of AbstractDataFrame, which stores a set of columns as AbstractVector objects. Indexing of all stored columns must be 1-based. Also, all functions exposed by DataFrames.jl API make sure to collect passed AbstractRange source columns before storing them in a DataFrame.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"SubDataFrame is an AbstractDataFrame subtype representing a view into a DataFrame. It stores only a reference to the parent DataFrame and information about which rows and columns from the parent are selected (both as integer indices referring to the parent). Typically it is created using the view function or is returned by indexing into a GroupedDataFrame object.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"GroupedDataFrame is a type that stores the result of a  grouping operation performed on an AbstractDataFrame. It is intended to be created as a result of a call to the groupby function.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"DataFrameRow is a view into a single row of an AbstractDataFrame. It stores only a reference to a parent DataFrame and information about which row and columns from the parent are selected (both as integer indices referring to the parent). The DataFrameRow type supports iteration over columns of the row and is similar in functionality to the NamedTuple type, but allows for modification of data stored in the parent DataFrame and reflects changes done to the parent after the creation of the view. Typically objects of the DataFrameRow type are encountered when returned by the eachrow function, or when accessing a single row of a DataFrame or SubDataFrame via getindex or view.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"The eachrow function returns a value of the DataFrameRows type, which serves as an iterator over rows of an AbstractDataFrame, returning DataFrameRow objects. The DataFrameRows is a subtype of AbstractVector and supports its interface with the exception that it is read-only.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"Similarly, the eachcol function returns a value of the DataFrameColumns type, which is not an AbstractVector, but supports most of its API. The key differences are that it is read-only and that the keys function returns a vector of Symbols (and not integers as for normal vectors).","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"Note that DataFrameRows and DataFrameColumns are not exported and should not be constructed directly, but using the eachrow and eachcol functions.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"The RepeatedVector and StackedVector types are subtypes of AbstractVector and support its interface with the exception that they are read only. Note that they are not exported and should not be constructed directly, but they are columns of a DataFrame returned by stack with view=true.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"The ByRow type is a special type used for selection operations to signal that the wrapped function should be applied to each element (row) of the selection.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"The AsTable type is a special type used for selection operations to signal that the columns selected by a wrapped selector should be passed as a NamedTuple to the function or to signal that it is requested to expand the return value of a transformation into multiple columns.","category":"page"},{"location":"lib/types/#man-columnhandling","page":"Types","title":"The design of handling of columns of a DataFrame","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"When a DataFrame is constructed columns are copied by default. You can disable this behavior by setting copycols keyword argument to false. The exception is if an AbstractRange is passed as a column, then it is always collected to a Vector.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"Also functions that transform a DataFrame to produce a new DataFrame perform a copy of the columns, unless they are passed copycols=false (available only for functions that could perform a transformation without copying the columns). Examples of such functions are vcat, hcat, filter, dropmissing, getindex, copy or the DataFrame constructor mentioned above.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"The generic single-argument constructor DataFrame(table) has copycols=nothing by default, meaning that columns are copied unless table signals that a copy of columns doesn't need to be made (this is done by wrapping the source table in Tables.CopiedColumns). CSV.jl does this when CSV.read(file, DataFrame) is called, since columns are built only for the purpose of use in a DataFrame constructor. Another example is Arrow.Table, where arrow data is inherently immutable so columns can't be accidentally mutated anyway. To be able to mutate arrow data, columns must be materialized, which can be accomplished via DataFrame(arrow_table, copycols=true).","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"On the contrary, functions that create a view of a DataFrame do not by definition make copies of the columns, and therefore require particular caution. This includes view, which returns a SubDataFrame or a DataFrameRow, and groupby, which returns a GroupedDataFrame.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"A partial exception to this rule is the stack function with view=true which creates a DataFrame that contains views of the columns from the source DataFrame.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"In-place functions whose names end with ! (like sort! or dropmissing!, setindex!, push!, append!) may mutate the column vectors of the DataFrame they take as an argument. These functions are safe to call due to the rules described above, except when a view of the DataFrame is in use (via a SubDataFrame, a DataFrameRow or a GroupedDataFrame). In the latter case, calling such a function on the parent might corrupt the view, which make trigger errors, silently return invalid data or even cause Julia to crash. The same caution applies when DataFrame was created using columns of another DataFrame without copying (for instance when copycols=false in functions such as DataFrame or hcat).","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"It is possible to have a direct access to a column col of a DataFrame df (e.g. this can be useful in performance critical code to avoid copying), using one of the following methods:","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"via the getproperty function using the syntax df.col;\nvia the getindex function using the syntax df[!, :col] (note this is in contrast to df[:, :col] which copies);\nby creating a DataFrameColumns object using the eachcol function;\nby calling the parent function on a view of a column of the DataFrame, e.g. parent(@view df[:, :col]);\nby storing the reference to the column before creating a DataFrame with copycols=false;","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"A column obtained from a DataFrame using one of the above methods should not be mutated without caution because:","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"resizing a column vector will corrupt its parent DataFrame and any associated views as methods only check the length of the column when it is added to the DataFrame and later assume that all columns have the same length;\nreordering values in a column vector (e.g. using sort!) will break the consistency of rows with other columns, which will also affect views (if any);\nchanging values contained in a column vector is acceptable as long as it is not used as a grouping column in a GroupedDataFrame created based on the DataFrame.","category":"page"},{"location":"lib/types/#Types-specification","page":"Types","title":"Types specification","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"AbstractDataFrame\nAsTable\nDataFrame\nDataFrameRow\nGroupedDataFrame\nGroupKey\nGroupKeys\nSubDataFrame\nDataFrameRows\nDataFrameColumns\nRepeatedVector\nStackedVector","category":"page"},{"location":"lib/types/#DataFrames.AbstractDataFrame","page":"Types","title":"DataFrames.AbstractDataFrame","text":"AbstractDataFrame\n\nAn abstract type for which all concrete types expose an interface for working with tabular data.\n\nAn AbstractDataFrame is a two-dimensional table with Symbols or strings for column names.\n\nDataFrames.jl defines two types that are subtypes of AbstractDataFrame: DataFrame and SubDataFrame.\n\nIndexing and broadcasting\n\nAbstractDataFrame can be indexed by passing two indices specifying row and column selectors. The allowed indices are a superset of indices that can be used for standard arrays. You can also access a single column of an AbstractDataFrame using getproperty and setproperty! functions. Columns can be selected using integers, Symbols, or strings. In broadcasting AbstractDataFrame behavior is similar to a Matrix.\n\nA detailed description of getindex, setindex!, getproperty, setproperty!, broadcasting and broadcasting assignment for data frames is given in the \"Indexing\" section of the manual.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.AsTable","page":"Types","title":"DataFrames.AsTable","text":"AsTable(cols)\n\nA type having a special meaning in source => transformation => destination selection operations supported by combine, select, select!, transform, transform!, subset, and subset!.\n\nIf AsTable(cols) is used in source position it signals that the columns selected by the wrapped selector cols should be passed as a NamedTuple to the function.\n\nIf AsTable is used in destination position it means that the result of the transformation operation is a vector of containers (or a single container if ByRow(transformation) is used) that should be expanded  into multiple columns using keys to get column names.\n\nExamples\n\njulia> df1 = DataFrame(a=1:3, b=11:13)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n\njulia> df2 = select(df1, AsTable([:a, :b]) => ByRow(identity))\n3×1 DataFrame\n Row │ a_b_identity\n     │ NamedTuple…\n─────┼─────────────────\n   1 │ (a = 1, b = 11)\n   2 │ (a = 2, b = 12)\n   3 │ (a = 3, b = 13)\n\njulia> select(df2, :a_b_identity => AsTable)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n\njulia> select(df1, AsTable([:a, :b]) => ByRow(nt -> map(x -> x^2, nt)) => AsTable)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1    121\n   2 │     4    144\n   3 │     9    169\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrame","page":"Types","title":"DataFrames.DataFrame","text":"DataFrame <: AbstractDataFrame\n\nAn AbstractDataFrame that stores a set of named columns.\n\nThe columns are normally AbstractVectors stored in memory, particularly a Vector, PooledVector or CategoricalVector.\n\nConstructors\n\nDataFrame(pairs::Pair...; makeunique::Bool=false, copycols::Bool=true)\nDataFrame(pairs::AbstractVector{<:Pair}; makeunique::Bool=false, copycols::Bool=true)\nDataFrame(ds::AbstractDict; copycols::Bool=true)\nDataFrame(; kwargs..., copycols::Bool=true)\n\nDataFrame(table; copycols::Union{Bool, Nothing}=nothing)\nDataFrame(table, names::AbstractVector;\n          makeunique::Bool=false, copycols::Union{Bool, Nothing}=nothing)\nDataFrame(columns::AbstractVecOrMat, names::AbstractVector;\n          makeunique::Bool=false, copycols::Bool=true)\n\nDataFrame(::DataFrameRow; copycols::Bool=true)\nDataFrame(::GroupedDataFrame; copycols::Bool=true, keepkeys::Bool=true)\n\nKeyword arguments\n\ncopycols : whether vectors passed as columns should be copied; by default set to true and the vectors are copied; if set to false then the constructor will still copy the passed columns if it is not possible to construct a DataFrame without materializing new columns. Note the copycols=nothing default in the Tables.jl compatible constructor; it is provided as certain input table types may have already made a copy of columns or the columns may otherwise be immutable, in which case columns are not copied by default. To force a copy in such cases, or to get mutable columns from an immutable input table (like Arrow.Table), pass copycols=true explicitly.\nmakeunique : if false (the default), an error will be raised\n\n(note that not all constructors support these keyword arguments)\n\nDetails on behavior of different constructors\n\nIt is allowed to pass a vector of Pairs, a list of Pairs as positional arguments, or a list of keyword arguments. In this case each pair is considered to represent a column name to column value mapping and column name must be a Symbol or string. Alternatively a dictionary can be passed to the constructor in which case its entries are considered to define the column name and column value pairs. If the dictionary is a Dict then column names will be sorted in the returned DataFrame.\n\nIn all the constructors described above column value can be a vector which is consumed as is or an object of any other type (except AbstractArray). In the latter case the passed value is automatically repeated to fill a new vector of the appropriate length. As a particular rule values stored in a Ref or a 0-dimensional AbstractArray are unwrapped and treated in the same way.\n\nIt is also allowed to pass a vector of vectors or a matrix as as the first argument. In this case the second argument must be a vector of Symbols or strings specifying column names, or the symbol :auto to generate column names x1, x2, ... automatically. Note that in this case if the first argument is a matrix and copycols=false the columns of the created DataFrame will be views of columns the source matrix.\n\nIf a single positional argument is passed to a DataFrame constructor then it is assumed to be of type that implements the Tables.jl interface using which the returned DataFrame is materialized.\n\nIf two positional arguments are passed, where the second argument is an AbstractVector, then the first argument is taken to be a table as described in the previous paragraph, and columns names of the resulting data frame are taken from the vector passed as the second positional argument.\n\nFinally it is allowed to construct a DataFrame from a DataFrameRow or a GroupedDataFrame. In the latter case the keepkeys keyword argument specifies whether the resulting DataFrame should contain the grouping columns of the passed GroupedDataFrame and the order of rows in the result follows the order of groups in the GroupedDataFrame passed.\n\nNotes\n\nThe DataFrame constructor by default copies all columns vectors passed to it. Pass the copycols=false keyword argument (where supported) to reuse vectors without copying them.\n\nBy default an error will be raised if duplicates in column names are found. Pass makeunique=true keyword argument (where supported) to accept duplicate names, in which case they will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf an AbstractRange is passed to a DataFrame constructor as a column it is always collected to a Vector (even if copycols=false). As a general rule AbstractRange values are always materialized to a Vector by all functions in DataFrames.jl before being stored in a DataFrame.\n\nDataFrame can store only columns that use 1-based indexing. Attempting to store a vector using non-standard indexing raises an error.\n\nThe DataFrame type is designed to allow column types to vary and to be dynamically changed also after it is constructed. Therefore DataFrames are not type stable. For performance-critical code that requires type-stability either use the functionality provided by select/transform/combine functions, use Tables.columntable and Tables.namedtupleiterator functions, use barrier functions, or provide type assertions to the variables that hold columns extracted from a DataFrame.\n\nMetadata: this function preserves all table and column-level metadata. As a special case if a GroupedDataFrame is passed then only :note-style metadata from parent of the GroupedDataFrame is preserved.\n\nExamples\n\njulia> DataFrame((a=[1, 2], b=[3, 4])) # Tables.jl table constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> DataFrame([(a=1, b=0), (a=2, b=0)]) # Tables.jl table constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame(\"a\" => 1:2, \"b\" => 0) # Pair constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([:a => 1:2, :b => 0]) # vector of Pairs constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame(Dict(:a => 1:2, :b => 0)) # dictionary constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame(a=1:2, b=0) # keyword argument constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([[1, 2], [0, 0]], [:a, :b]) # vector of vectors constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([1 0; 2 0], :auto) # matrix constructor\n2×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameRow","page":"Types","title":"DataFrames.DataFrameRow","text":"DataFrameRow{<:AbstractDataFrame, <:AbstractIndex}\n\nA view of one row of an AbstractDataFrame.\n\nA DataFrameRow is returned by getindex or view functions when one row and a selection of columns are requested, or when iterating the result of the call to the eachrow function.\n\nThe DataFrameRow constructor can also be called directly:\n\nDataFrameRow(parent::AbstractDataFrame, row::Integer, cols=:)\n\nA DataFrameRow supports the iteration interface and can therefore be passed to functions that expect a collection as an argument. Its element type is always Any.\n\nIndexing is one-dimensional like specifying a column of a DataFrame. You can also access the data in a DataFrameRow using the getproperty and setproperty! functions and convert it to a Tuple, NamedTuple, or Vector using the corresponding functions.\n\nIf the selection of columns in a parent data frame is passed as : (a colon) then DataFrameRow will always have all columns from the parent, even if they are added or removed after its creation.\n\nExamples\n\njulia> df = DataFrame(a=repeat([1, 2], outer=[2]),\n                      b=repeat([\"a\", \"b\"], inner=[2]),\n                      c=1:4)\n4×3 DataFrame\n Row │ a      b       c\n     │ Int64  String  Int64\n─────┼──────────────────────\n   1 │     1  a           1\n   2 │     2  a           2\n   3 │     1  b           3\n   4 │     2  b           4\n\njulia> df[1, :]\nDataFrameRow\n Row │ a      b       c\n     │ Int64  String  Int64\n─────┼──────────────────────\n   1 │     1  a           1\n\njulia> @view df[end, [:a]]\nDataFrameRow\n Row │ a\n     │ Int64\n─────┼───────\n   4 │     2\n\njulia> eachrow(df)[1]\nDataFrameRow\n Row │ a      b       c\n     │ Int64  String  Int64\n─────┼──────────────────────\n   1 │     1  a           1\n\njulia> Tuple(df[1, :])\n(1, \"a\", 1)\n\njulia> NamedTuple(df[1, :])\n(a = 1, b = \"a\", c = 1)\n\njulia> Vector(df[1, :])\n3-element Vector{Any}:\n 1\n  \"a\"\n 1\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.GroupedDataFrame","page":"Types","title":"DataFrames.GroupedDataFrame","text":"GroupedDataFrame\n\nThe result of a groupby operation on an AbstractDataFrame; a view into the AbstractDataFrame grouped by rows.\n\nNot meant to be constructed directly, see groupby.\n\nOne can get the names of columns used to create GroupedDataFrame using the groupcols function. Similarly the groupindices function returns a vector of group indices for each row of the parent data frame.\n\nAfter its creation, a GroupedDataFrame reflects the grouping of rows that was valid at its creation time. Therefore grouping columns of its parent data frame must not be mutated, and rows must not be added nor removed from it. To safeguard the user against such cases, if the number of rows in the parent data frame changes then trying to use GroupedDataFrame will throw an error. However, one can add or remove columns to the parent data frame without invalidating the GroupedDataFrame provided that columns used for grouping are not changed.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.GroupKey","page":"Types","title":"DataFrames.GroupKey","text":"GroupKey{T<:GroupedDataFrame}\n\nKey for one of the groups of a GroupedDataFrame. Contains the values of the corresponding grouping columns and behaves similarly to a NamedTuple, but using it to index its GroupedDataFrame is more efficient than using the equivalent Tuple and NamedTuple, and much more efficient than using the equivalent AbstractDict.\n\nInstances of this type are returned by keys(::GroupedDataFrame) and are not meant to be constructed directly.\n\nIndexing fields of GroupKey is allowed using an integer, a Symbol, or a string. It is also possible to access the data in a GroupKey using the getproperty function. A GroupKey can be converted to a Tuple, NamedTuple, a Vector, or a Dict. When converted to a Dict, the keys of the Dict are Symbols.\n\nSee keys(::GroupedDataFrame) for more information.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.GroupKeys","page":"Types","title":"DataFrames.GroupKeys","text":"GroupKeys{T<:GroupedDataFrame} <: AbstractVector{GroupKey{T}}\n\nA vector containing all GroupKey objects for a given GroupedDataFrame.\n\nSee keys(::GroupedDataFrame) for more information.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.SubDataFrame","page":"Types","title":"DataFrames.SubDataFrame","text":"SubDataFrame{<:AbstractDataFrame, <:AbstractIndex, <:AbstractVector{Int}} <: AbstractDataFrame\n\nA view of an AbstractDataFrame. It is returned by a call to the view function on an AbstractDataFrame if a collections of rows and columns are specified.\n\nA SubDataFrame is an AbstractDataFrame, so expect that most DataFrame functions should work. Such methods include describe, summary, nrow, size, by, stack, and join.\n\nIf the selection of columns in a parent data frame is passed as : (a colon) then SubDataFrame will always have all columns from the parent, even if they are added or removed after its creation.\n\nExamples\n\njulia> df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),\n                      b=repeat([2, 1], outer=[4]),\n                      c=1:8)\n8×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     2      1      2\n   3 │     3      2      3\n   4 │     4      1      4\n   5 │     1      2      5\n   6 │     2      1      6\n   7 │     3      2      7\n   8 │     4      1      8\n\njulia> sdf1 = view(df, :, 2:3) # column subsetting\n8×2 SubDataFrame\n Row │ b      c\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      1\n   2 │     1      2\n   3 │     2      3\n   4 │     1      4\n   5 │     2      5\n   6 │     1      6\n   7 │     2      7\n   8 │     1      8\n\njulia> sdf2 = @view df[end:-1:1, [1, 3]]  # row and column subsetting\n8×2 SubDataFrame\n Row │ a      c\n     │ Int64  Int64\n─────┼──────────────\n   1 │     4      8\n   2 │     3      7\n   3 │     2      6\n   4 │     1      5\n   5 │     4      4\n   6 │     3      3\n   7 │     2      2\n   8 │     1      1\n\njulia> sdf3 = groupby(df, :a)[1]  # indexing a GroupedDataFrame returns a SubDataFrame\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      2      5\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameRows","page":"Types","title":"DataFrames.DataFrameRows","text":"DataFrameRows{D<:AbstractDataFrame} <: AbstractVector{DataFrameRow}\n\nIterator over rows of an AbstractDataFrame, with each row represented as a DataFrameRow.\n\nA value of this type is returned by the eachrow function.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameColumns","page":"Types","title":"DataFrames.DataFrameColumns","text":"DataFrameColumns{<:AbstractDataFrame}\n\nA vector-like object that allows iteration over columns of an AbstractDataFrame.\n\nIndexing into DataFrameColumns objects using integer, Symbol or string returns the corresponding column (without copying). Indexing into DataFrameColumns objects using a multiple column selector returns a subsetted DataFrameColumns object with a new parent containing only the selected columns (without copying).\n\nDataFrameColumns supports most of the AbstractVector API. The key differences are that it is read-only and that the keys function returns a vector of Symbols (and not integers as for normal vectors).\n\nIn particular findnext, findprev, findfirst, findlast, and findall functions are supported, and in findnext and findprev functions it is allowed to pass an integer, string, or Symbol as a reference index.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.RepeatedVector","page":"Types","title":"DataFrames.RepeatedVector","text":"RepeatedVector{T} <: AbstractVector{T}\n\nAn AbstractVector that is a view into another AbstractVector with repeated elements\n\nNOTE: Not exported.\n\nConstructor\n\nRepeatedVector(parent::AbstractVector, inner::Int, outer::Int)\n\nArguments\n\nparent : the AbstractVector that's repeated\ninner : the number of times each element is repeated\nouter : the number of times the whole vector is repeated after expanded by inner\n\ninner and outer have the same meaning as similarly named arguments to repeat.\n\nExamples\n\nRepeatedVector([1, 2], 3, 1)   # [1, 1, 1, 2, 2, 2]\nRepeatedVector([1, 2], 1, 3)   # [1, 2, 1, 2, 1, 2]\nRepeatedVector([1, 2], 2, 2)   # [1, 1, 2, 2, 1, 1, 2, 2]\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.StackedVector","page":"Types","title":"DataFrames.StackedVector","text":"StackedVector <: AbstractVector\n\nAn AbstractVector that is a linear, concatenated view into another set of AbstractVectors\n\nNOTE: Not exported.\n\nConstructor\n\nStackedVector(d::AbstractVector)\n\nArguments\n\nd... : one or more AbstractVectors\n\nExamples\n\nStackedVector(Any[[1, 2], [9, 10], [11, 12]])  # [1, 2, 9, 10, 11, 12]\n\n\n\n\n\n","category":"type"},{"location":"man/joins/#数据库风格的连接","page":"Joins","title":"数据库风格的连接","text":"","category":"section"},{"location":"man/joins/#连接的介绍","page":"Joins","title":"连接的介绍","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"我们经常需要将两个或更多的数据集合并在一起，以提供我们正在研究的主题的完整画面。例如，假设我们有以下两个数据集：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> using DataFrames\n\njulia> people = DataFrame(ID=[20, 40], Name=[\"John Doe\", \"Jane Doe\"])\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │    20  John Doe\n   2 │    40  Jane Doe\n\njulia> jobs = DataFrame(ID=[20, 40], Job=[\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │    20  Lawyer\n   2 │    40  Doctor","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"我们可能希望使用一个包含每个ID的姓名和工作的更大的数据集。我们可以使用innerjoin函数做到这一点：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> innerjoin(people, jobs, on = :ID)\n2×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String    String\n─────┼─────────────────────────\n   1 │    20  John Doe  Lawyer\n   2 │    40  Jane Doe  Doctor","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"在关系数据库理论中，这种操作通常被称为连接。用于确定在连接过程中应该合并哪些行的列被称为键。","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"以下函数提供了执行七种类型的连接：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"innerjoin：输出包含在所有传入的数据框中存在的键值的行。\nleftjoin：输出包含在第一个（左）参数中存在的键值的行，无论该值是否在第二个（右）参数中存在。\nrightjoin：输出包含在第二个（右）参数中存在的键值的行，无论该值是否在第一个（左）参数中存在。\nouterjoin：输出包含在任何传入的数据框中存在的键值的行。\nsemijoin：类似于内连接，但输出仅限于来自第一个（左）参数的列。\nantijoin：输出包含在第一个（左）但不在第二个（右）参数中存在的键值的行。与semijoin一样，输出仅限于来自第一个（左）参数的列。\ncrossjoin：输出是来自所有传入数据框的行的笛卡尔积。","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"有关更多信息，请参见SQL连接的维基百科页面。","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"以下是不同类型的连接的例子：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> jobs = DataFrame(ID=[20, 60], Job=[\"Lawyer\", \"Astronaut\"])\n2×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼──────────────────\n   1 │    20  Lawyer\n   2 │    60  Astronaut\n\njulia> innerjoin(people, jobs, on = :ID)\n1×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String    String\n─────┼─────────────────────────\n   1 │    20  John Doe  Lawyer\n\njulia> leftjoin(people, jobs, on = :ID)\n2×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String    String?\n─────┼──────────────────────────\n   1 │    20  John Doe  Lawyer\n   2 │    40  Jane Doe  missing\n\njulia> rightjoin(people, jobs, on = :ID)\n2×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String?   String\n─────┼────────────────────────────\n   1 │    20  John Doe  Lawyer\n   2 │    60  missing   Astronaut\n\njulia> outerjoin(people, jobs, on = :ID)\n3×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String?   String?\n─────┼────────────────────────────\n   1 │    20  John Doe  Lawyer\n   2 │    40  Jane Doe  missing\n   3 │    60  missing   Astronaut\n\njulia> semijoin(people, jobs, on = :ID)\n1×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │    20  John Doe\n\njulia> antijoin(people, jobs, on = :ID)\n1×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │    40  Jane Doe","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"交叉连接是唯一一种不使用on键的连接：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> crossjoin(people, jobs, makeunique = true)\n4×4 DataFrame\n Row │ ID     Name      ID_1   Job\n     │ Int64  String    Int64  String\n─────┼───────────────────────────────────\n   1 │    20  John Doe     20  Lawyer\n   2 │    20  John Doe     60  Astronaut\n   3 │    40  Jane Doe     20  Lawyer\n   4 │    40  Jane Doe     60  Astronaut","category":"page"},{"location":"man/joins/#键值比较和浮点值","page":"Joins","title":"键值比较和浮点值","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"两个或更多数据框的键值使用isequal函数进行比较。这与Julia Base中的Set和Dict类型保持一致。","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"不建议使用浮点数作为键：浮点比较可能会出现令人惊讶和不可预测的结果。如果你确实使用了浮点键，请注意，默认情况下，当键包含-0.0（负零）或NaN值时，会引发错误。以下是一个例子：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> innerjoin(DataFrame(id=[-0.0]), DataFrame(id=[0.0]), on=:id)\nERROR: ArgumentError: Currently for numeric values `NaN` and `-0.0` in their real or imaginary components are not allowed. Such value was found in column :id in left data frame. Use CategoricalArrays.jl to wrap these values in a CategoricalVector to perform the requested join.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"可以通过将键值包装在categorical向量中来覆盖这一点。","category":"page"},{"location":"man/joins/#基于不同名称的关键列进行连接","page":"Joins","title":"基于不同名称的关键列进行连接","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"为了在左表和右表中的关键字拥有不同名称的情况下连接数据框，你可以传递 left => right 对作为 on 参数：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> a = DataFrame(ID=[20, 40], Name=[\"John Doe\", \"Jane Doe\"])\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │    20  John Doe\n   2 │    40  Jane Doe\n\njulia> b = DataFrame(IDNew=[20, 40], Job=[\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n Row │ IDNew  Job\n     │ Int64  String\n─────┼───────────────\n   1 │    20  Lawyer\n   2 │    40  Doctor\n\njulia> innerjoin(a, b, on = :ID => :IDNew)\n2×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String    String\n─────┼─────────────────────────\n   1 │    20  John Doe  Lawyer\n   2 │    40  Jane Doe  Doctor","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"这是另一个包含多列的例子：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> a = DataFrame(City=[\"Amsterdam\", \"London\", \"London\", \"New York\", \"New York\"],\n                     Job=[\"Lawyer\", \"Lawyer\", \"Lawyer\", \"Doctor\", \"Doctor\"],\n                     Category=[1, 2, 3, 4, 5])\n5×3 DataFrame\n Row │ City       Job     Category\n     │ String     String  Int64\n─────┼─────────────────────────────\n   1 │ Amsterdam  Lawyer         1\n   2 │ London     Lawyer         2\n   3 │ London     Lawyer         3\n   4 │ New York   Doctor         4\n   5 │ New York   Doctor         5\n\njulia> b = DataFrame(Location=[\"Amsterdam\", \"London\", \"London\", \"New York\", \"New York\"],\n                     Work=[\"Lawyer\", \"Lawyer\", \"Lawyer\", \"Doctor\", \"Doctor\"],\n                     Name=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n5×3 DataFrame\n Row │ Location   Work    Name\n     │ String     String  String\n─────┼───────────────────────────\n   1 │ Amsterdam  Lawyer  a\n   2 │ London     Lawyer  b\n   3 │ London     Lawyer  c\n   4 │ New York   Doctor  d\n   5 │ New York   Doctor  e\n\njulia> innerjoin(a, b, on = [:City => :Location, :Job => :Work])\n9×4 DataFrame\n Row │ City       Job     Category  Name\n     │ String     String  Int64     String\n─────┼─────────────────────────────────────\n   1 │ Amsterdam  Lawyer         1  a\n   2 │ London     Lawyer         2  b\n   3 │ London     Lawyer         3  b\n   4 │ London     Lawyer         2  c\n   5 │ London     Lawyer         3  c\n   6 │ New York   Doctor         4  d\n   7 │ New York   Doctor         5  d\n   8 │ New York   Doctor         4  e\n   9 │ New York   Doctor         5  e","category":"page"},{"location":"man/joins/#处理重复键和追踪源数据框","page":"Joins","title":"处理重复键和追踪源数据框","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"此外，注意到在最后的连接中，第2行和第3行在两个被连接的 DataFrame 中的 on 变量上具有相同的值。在这种情况下，innerjoin，outerjoin，leftjoin 和 rightjoin 将生成所有匹配行的组合。在我们的示例中，第2行到第5行是作为结果创建的。对于两个被连接的 DataFrame 中的第4行和第5行，也可以观察到相同的行为。","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"为了检查作为 on 参数传递的列在每个输入数据框中定义了唯一键（根据 isequal），你可以将 validate 关键字参数设置为一个两元素的元组或一对 Bool 值，每个元素表示是否对相应的数据框运行检查。以下是上述连接操作的示例：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> innerjoin(a, b, on = [(:City => :Location), (:Job => :Work)], validate=(true, true))\nERROR: ArgumentError: Merge key(s) are not unique in both df1 and df2. df1 contains 2 duplicate keys: (City = \"London\", Job = \"Lawyer\") and (City = \"New York\", Job = \"Doctor\"). df2 contains 2 duplicate keys: (Location = \"London\", Work = \"Lawyer\") and (Location = \"New York\", Work = \"Doctor\").","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"最后，使用 source 关键字参数，你可以向结果数据框添加一列，指示给定行仅出现在左边，右边还是两个数据框中。这是一个例子：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> a = DataFrame(ID=[20, 40], Name=[\"John\", \"Jane\"])\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼───────────────\n   1 │    20  John\n   2 │    40  Jane\n\njulia> b = DataFrame(ID=[20, 60], Job=[\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │    20  Lawyer\n   2 │    60  Doctor\n\njulia> outerjoin(a, b, on=:ID, validate=(true, true), source=:source)\n3×4 DataFrame\n Row │ ID     Name     Job      source\n     │ Int64  String?  String?  String\n─────┼─────────────────────────────────────\n   1 │    20  John     Lawyer   both\n   2 │    40  Jane     missing  left_only\n   3 │    60  missing  Doctor   right_only","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"注意，这次我们也使用了 validate 关键字参数，它没有产生错误，因为在两个源数据框中定义的键都是唯一的。","category":"page"},{"location":"man/joins/#重命名连接的列","page":"Joins","title":"重命名连接的列","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"你经常需要追踪源数据框。这个特性可以通过 renamecols 关键字参数来实现：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> innerjoin(a, b, on=:ID, renamecols = \"_left\" => \"_right\")\n1×3 DataFrame\n Row │ ID     Name_left  Job_right\n     │ Int64  String     String\n─────┼─────────────────────────────\n   1 │    20  John       Lawyer","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"在上面的例子中，我们给左表的非键列添加了 \"_left\" 后缀，给右表的非键列添加了 \"_right\" 后缀。","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"另外，也可以传入一个用于转换列名的函数：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> innerjoin(a, b, on=:ID, renamecols = lowercase => uppercase)\n1×3 DataFrame\n Row │ ID     name    JOB\n     │ Int64  String  String\n─────┼───────────────────────\n   1 │    20  John    Lawyer\n","category":"page"},{"location":"man/joins/#在连接中匹配缺失值","page":"Joins","title":"在连接中匹配缺失值","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"默认情况下，当你尝试在一个有 missing 值的键上执行连接操作时，会出现错误：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> df1 = DataFrame(id=[1, missing, 3], a=1:3)\n3×2 DataFrame\n Row │ id       a\n     │ Int64?   Int64\n─────┼────────────────\n   1 │       1      1\n   2 │ missing      2\n   3 │       3      3\n\njulia> df2 = DataFrame(id=[1, 2, missing], b=1:3)\n3×2 DataFrame\n Row │ id       b\n     │ Int64?   Int64\n─────┼────────────────\n   1 │       1      1\n   2 │       2      2\n   3 │ missing      3\n\njulia> innerjoin(df1, df2, on=:id)\nERROR: ArgumentError: Missing values in key columns are not allowed when matchmissing == :error. `missing` found in column :id in left data frame.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"如果你希望 missing 值被视为相等，可以传入 matchmissing=:equal 关键字参数：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> innerjoin(df1, df2, on=:id, matchmissing=:equal)\n2×3 DataFrame\n Row │ id       a      b\n     │ Int64?   Int64  Int64\n─────┼───────────────────────\n   1 │       1      1      1\n   2 │ missing      2      3","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"或者你可能希望删除所有包含 missing 值的行。在这种情况下，传入 matchmissing=:notequal：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> innerjoin(df1, df2, on=:id, matchmissing=:notequal)\n1×3 DataFrame\n Row │ id      a      b\n     │ Int64?  Int64  Int64\n─────┼──────────────────────\n   1 │      1      1      1","category":"page"},{"location":"man/joins/#指定连接结果中的行顺序","page":"Joins","title":"指定连接结果中的行顺序","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"默认情况下，连接操作产生的行顺序是未定义的：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> df_left = DataFrame(id=[1, 2, 4, 5], left=1:4)\n4×2 DataFrame\n Row │ id     left\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     4      3\n   4 │     5      4\n\njulia> df_right = DataFrame(id=[2, 1, 3, 6, 7], right=1:5)\n5×2 DataFrame\n Row │ id     right\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      1\n   2 │     1      2\n   3 │     3      3\n   4 │     6      4\n   5 │     7      5\n\njulia> outerjoin(df_left, df_right, on=:id)\n7×3 DataFrame\n Row │ id     left     right\n     │ Int64  Int64?   Int64?\n─────┼─────────────────────────\n   1 │     2        2        1\n   2 │     1        1        2\n   3 │     4        3  missing\n   4 │     5        4  missing\n   5 │     3  missing        3\n   6 │     6  missing        4\n   7 │     7  missing        5","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"如果你希望结果保持左表的行顺序，可以传入 order=:left 关键字参数：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> outerjoin(df_left, df_right, on=:id, order=:left)\n7×3 DataFrame\n Row │ id     left     right\n     │ Int64  Int64?   Int64?\n─────┼─────────────────────────\n   1 │     1        1        2\n   2 │     2        2        1\n   3 │     4        3  missing\n   4 │     5        4  missing\n   5 │     3  missing        3\n   6 │     6  missing        4\n   7 │     7  missing        5","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"注意，在这种情况下，左表中缺失的键会被放在存在的键之后。","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"类似地，order=:right 会保持右表的顺序（并将不在其中的键放在末尾）：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> outerjoin(df_left, df_right, on=:id, order=:right)\n7×3 DataFrame\n Row │ id     left     right\n     │ Int64  Int64?   Int64?\n─────┼─────────────────────────\n   1 │     2        2        1\n   2 │     1        1        2\n   3 │     3  missing        3\n   4 │     6  missing        4\n   5 │     7  missing        5\n   6 │     4        3  missing\n   7 │     5        4  missing","category":"page"},{"location":"man/joins/#原地左连接","page":"Joins","title":"原地左连接","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"一个常见的操作是从参考表中添加数据到主表。可以使用 leftjoin! 函数进行此类原地更新。在这种情况下，左表会通过右表中的匹配行进行原地更新。","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> main = DataFrame(id=1:4, main=1:4)\n4×2 DataFrame\n Row │ id     main\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     4      4\n\njulia> leftjoin!(main, DataFrame(id=[2, 4], info=[\"a\", \"b\"]), on=:id);\n\njulia> main\n4×3 DataFrame\n Row │ id     main   info\n     │ Int64  Int64  String?\n─────┼───────────────────────\n   1 │     1      1  missing\n   2 │     2      2  a\n   3 │     3      3  missing\n   4 │     4      4  b","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"请注意，在这种情况下，左表的行顺序和数量不会改变。因此，特别的，右表中不允许有重复的键：","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> leftjoin!(main, DataFrame(id=[2, 2], info_bad=[\"a\", \"b\"]), on=:id)\nERROR: ArgumentError: duplicate rows found in right table","category":"page"},{"location":"lib/metadata/#Metadata","page":"Metadata","title":"Metadata","text":"","category":"section"},{"location":"lib/metadata/#Design-of-metadata-support","page":"Metadata","title":"Design of metadata support","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DataFrames.jl allows you to store and retrieve metadata on table and column level. This is supported using the functions defined by the DataAPI.jl interface:","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"for table-level metadata: metadata, metadatakeys, metadata!, deletemetadata!, emptymetadata!;\nfor column-level metadata: colmetadata, colmetadatakeys, colmetadata!, deletecolmetadata!, emptycolmetadata!.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"Additionally you might find the TableMetadataTools.jl package useful. This package defines several convenience functions for performing typical metadata operations.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"Assume that we work with a data frame-like object df that has a column col (referred to either via a Symbol, a string or an integer index).","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"Table-level metadata are key-value pairs that are attached to df. Column-level metadata are key-value pairs that are attached to a specific column col of df data frame.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"To check whether some key key is present in table-level metadata of data frame df you can write key in metadatakeys(df). Similarly to check whether key key is present in column-level metadata of data frame df for column col write key in colmetadatakeys(df, col).","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"Additionally each metadata key-value pair has a style information attached to it. In DataFrames.jl the metadata style influences how metadata is propagated when df is transformed. The following metadata styles are supported:","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":":default: Metadata having this style is considered to be attached to a concrete state of df. This means that any operation on this data frame invalidates such metadata and it is dropped in the result of such operation. Note that this happens even if the operation eventually does not change the data frame: the rule is that calling a function that might alter a data frame drops such metadata; in this way it is possible to statically determine whether metadata of styles other than :note is dropped after a function call. Only two functions are exceptions that keep non-:note-style metadata, as these operations are specifically designed to create an identical copy of the source data frame:\nDataFrame constructor;\ncopy of a data frame;\n:note: Metadata having this style is considered to be an annotation of a table or a column that should be propagated under transformations (exact propagation rules of such metadata are described below).\nAll other metadata styles are allowed but they are currently treated as having :default-style (this might change in the future if other standard metadata styles are defined).","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"All DataAPI.jl metadata functions work with DataFrame, SubDataFrame, DataFrameRow objects, and objects returned by eachrow and eachcol functions. In this section collectively these objects will be called data frame-like, and follow the rules:","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"objects returned by eachrow and eachcol functions have the same metadata as their parent AbstractDataFrame;\nSubDataFrame and DataFrameRow only expose metadata from their parent DataFrame whose style is :note.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"Notably, metadata is not supported for GroupedDataFrame and you can't add, modify, nor view metadata through the GroupedDataFrame itself. It is possible only through its parent.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"note: Note\nDataFrames.jl allows users to extract out columns of a data frame and perform operations on them. Such operations will not affect metadata. Therefore, even if some metadata has :default style it might no longer correctly describe the column's contents if the user mutates columns directly.","category":"page"},{"location":"lib/metadata/#DataFrames.jl-specific-design-principles-for-use-of-metadata","page":"Metadata","title":"DataFrames.jl-specific design principles for use of metadata","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DataFrames.jl supports storing any object as metadata values. However, it is recommended to use strings as values of the metadata, as some storage formats, like for example Apache Arrow, only support strings.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"For all functions that operate on column-level metadata, an ArgumentError is thrown if passed column is not present in a data frame.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"If metadata! or colmetadata! is used to add metadata to a SubDataFrame or a DataFrameRow then:","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"using metadata that has style other than :note throws an error;\ntrying to add key-value pair for which a mapping for key already exists with style other than :note in the parent data frame throws an error.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DataFrames.jl is designed so that there is no performance overhead due to metadata support when there is no metadata in a data frame. Therefore if you need maximum performance of operations that do not rely on metadata call emptymetadata! and emptycolmetadata! before running these operations.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"Processing metadata for SubDataFrame and DataFrameRow has more overhead than for other types defined in DataFrames.jl that support metadata, because they have a more complex logic of handling it (they support only :note-style metadata, which means that other metadata needs to be filtered-out).","category":"page"},{"location":"lib/metadata/#Examples","page":"Metadata","title":"Examples","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"Here is a simple example how you can work with metadata in DataFrames.jl:","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"julia> using DataFrames\n\njulia> df = DataFrame(name=[\"Jan Krzysztof Duda\", \"Jan Krzysztof Duda\",\n                            \"Radosław Wojtaszek\", \"Radosław Wojtaszek\"],\n                      date=[\"2022-Jun\", \"2021-Jun\", \"2022-Jun\", \"2021-Jun\"],\n                      rating=[2750, 2729, 2708, 2687])\n4×3 DataFrame\n Row │ name                date      rating\n     │ String              String    Int64\n─────┼──────────────────────────────────────\n   1 │ Jan Krzysztof Duda  2022-Jun    2750\n   2 │ Jan Krzysztof Duda  2021-Jun    2729\n   3 │ Radosław Wojtaszek  2022-Jun    2708\n   4 │ Radosław Wojtaszek  2021-Jun    2687\n\njulia> metadatakeys(df)\n()\n\njulia> metadata!(df, \"caption\", \"ELO ratings of chess players\", style=:note);\n\njulia> collect(metadatakeys(df))\n1-element Vector{String}:\n \"caption\"\n\njulia> \"caption\" in metadatakeys(df)\ntrue\n\njulia> metadata(df, \"caption\")\n\"ELO ratings of chess players\"\n\njulia> metadata(df, \"caption\", style=true)\n(\"ELO ratings of chess players\", :note)\n\njulia> emptymetadata!(df);\n\njulia> metadatakeys(df)\n()\n\njulia> colmetadatakeys(df)\n()\n\njulia> colmetadata!(df, :name, \"label\", \"First and last name of a player\", style=:note);\n\njulia> colmetadata!(df, :date, \"label\", \"Rating date in yyyy-u format\", style=:note);\n\njulia> colmetadata!(df, :rating, \"label\", \"ELO rating in classical time control\", style=:note);\n\njulia> \"label\" in colmetadatakeys(df, :rating)\ntrue\n\njulia> colmetadata(df, :rating, \"label\")\n\"ELO rating in classical time control\"\n\njulia> colmetadata(df, :rating, \"label\", style=true)\n(\"ELO rating in classical time control\", :note)\n\njulia> collect(colmetadatakeys(df))\n3-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:\n   :date => [\"label\"]\n :rating => [\"label\"]\n   :name => [\"label\"]\n\njulia> [only(names(df, col)) =>\n        [key => colmetadata(df, col, key) for key in metakeys] for\n        (col, metakeys) in colmetadatakeys(df)]\n3-element Vector{Pair{String, Vector{Pair{String, String}}}}:\n   \"date\" => [\"label\" => \"Rating date in yyyy-u format\"]\n \"rating\" => [\"label\" => \"ELO rating in classical time control\"]\n   \"name\" => [\"label\" => \"First and last name of a player\"]\n\njulia> emptycolmetadata!(df);\n\njulia> colmetadatakeys(df)\n()","category":"page"},{"location":"lib/metadata/#Propagation-of-:note-style-metadata","page":"Metadata","title":"Propagation of :note-style metadata","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"An important design feature of :note-style metadata is how it is handled when data frames are transformed.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"note: Note\nThe provided rules might slightly change in the future. Any change to :note-style metadata propagation rules will not be considered as breaking and can be done in any minor release of DataFrames.jl. Such changes might be made based on users' feedback about what metadata propagation rules are most convenient in practice.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"The general design rules for propagation of :note-style metadata are as follows.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"For operations that take a single data frame as an input:","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"Table level metadata is propagated to the returned data frame object.\nFor column-level metadata:\nin all cases when a single column is transformed to a single column and the name of the column does not change (or is automatically changed e.g. to de-duplicate column names or via column renaming in joins) column-level metadata is preserved (example operations of this kind are getindex, subset, joins, mapcols).\nin all cases when a single column is transformed with identity or copy to a single column, column-level metadata is preserved even if column name is changed (example operations of this kind are rename, or the :x => :y or :x => copy => :y operation specification in select).","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"For operations that take multiple data frames as their input two cases are distinguished:","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"When there is a natural main table in the operation (append!, prepend!, leftjoin, leftjoin!, rightjoin, semijoin, antijoin, setindex!):\ntable-level metadata is taken from the main table;\ncolumn-level metadata for columns from the main table is taken from main table;\ncolumn-level metadata for columns from the non-main table is taken only for columns not present in the main table.\nWhen all tables are equivalent (hcat, vcat, innerjoin, outerjoin):\ntable-level metadata is preserved only for keys which are defined in all passed tables and have the same value;\ncolumn-level metadata is preserved only for keys which are defined in all passed tables that contain this column and have the same value.","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"In all these operations when metadata is preserved the values in the key-value pairs are not copied (this is relevant in case of mutable values).","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"note: Note\nThe rules for column-level :note-style metadata propagation are designed to make the right decision in common cases. In particular, they assume that if source and target column name is the same then the metadata for the column is not changed. While this is valid for many operations, it is not always true in general. For example the :x => ByRow(log) => :x transformation might invalidate metadata if it contained unit of measure of the variable. In such cases user must either use a different name for the output column, set metadata style to :default before the operation, or manually drop or update such metadata from the :x column after the transformation.","category":"page"},{"location":"lib/metadata/#Operations-that-preserve-:note-style-metadata","page":"Metadata","title":"Operations that preserve :note-style metadata","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"Most of the functions in DataFrames.jl only preserve table and column metadata whose style is :note. Some functions use a more complex logic, even if they follow the general rules described above (in particular under any transformation all non-:note-style metadata is always dropped). These are:","category":"page"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"describe drops all metadata.\nhcat: propagates table-level metadata only for keys which are defined in all passed tables and have the same value; column-level metadata is preserved.\nvcat: propagates table-level metadata only for keys which are defined in all passed tables and have the same value; column-level metadata is preserved only for keys which are defined in all passed tables that contain this column and have the same value;\nstack: propagates table-level metadata and column-level metadata for identifier columns.\nunstack: propagates table-level metadata and column-level metadata for row keys columns.\npermutedims: propagates table-level metadata and drops column-level  metadata.\nbroadcasted assignment does not change target metadata; under Julia earlier than 1.7 operation of kind df.a .= s does not drop non-:note-style metadata; under Julia 1.7 or later this operation preserves only :note-style metadata\nbroadcasting propagates table-level metadata if some key is present in all passed data frames and value associated with it is identical in all passed data frames; column-level metadata is propagated for columns if some key for a given column is present in all passed data frames and value associated with it is identical in all passed data frames.\ngetindex preserves table-level metadata and column-level metadata for selected columns\nsetindex! does not affect table-level and column-level metadata\npush!, pushfirst!, insert! do not affect table-level nor column-level metadata (even if they add new columns and pushed row is a DataFrameRow or other value supporting metadata interface)\nappend! and prepend! do not change table and column-level metadata of the destination data frame, except that if new columns are added and these columns have metadata in the appended/prepended table then this metadata is preserved.\nleftjoin!, leftjoin: table and column-level metadata is taken from the left table except for non-key columns from right table for which metadata is taken from right table;\nrightjoin: table and column-level metadata is taken from the right table except for non-key columns from left table for which metadata is taken from left table;\ninnerjoin, outerjoin: propagates table-level metadata only for keys that are defined in all passed data frames and have the same value; column-level metadata is propagated for all columns except for key columns, for which it is propagated only for keys that are defined in all passed data frames and have the same value.\nsemijoin, antijoin: table and column-level metadata is taken from the left table.\ncrossjoin: propagates table-level metadata only for keys that are defined in both passed data frames and have the same value; propagates column-level metadata from both passed data frames.\nselect, select!, transform, transform!, combine: propagate table-level metadata; column-level metadata is propagated if: a) a single column is transformed to a single column and the name of the column does not change    (this includes all column selection operations), or b) a single column is transformed with identity or copy to a single column    even if column name is changed (this includes column renaming).","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"lib/functions/#Multithreading-support","page":"Functions","title":"Multithreading support","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"By default, selected operations in DataFrames.jl automatically use multiple threads when available. Multi-threading is task-based and implemented using the @spawn macro from Julia Base. Tasks are therefore scheduled on the :default threadpool. Functions that take user-defined functions and may run it in parallel accept a threads keyword argument which allows disabling multithreading when the provided function requires serial execution or is not thread-safe.","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"This is a list of operations that currently make use of multi-threading:","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"DataFrame constructor with copycols=true; also recursively all functions that call this constructor, e.g. copy.\ngetindex when multiple columns are selected.\ngroupby (both when hashing is required and when fast path using DataAPI.refpool is used).\n*join functions for composing output data frame (but currently not for finding matching rows in joined data frames).\ncombine, select[!], and transform[!] on GroupedDataFrame when either of the conditions below is met:\nmultiple transformations are performed (each transformation is spawned in a separate task)\na transformation produces one row per group and the passed transformation is a custom function (i.e. not for standard reductions, which use optimized single-threaded methods).\ndropmissing when the provided data frame has more than 1 column and view=false  (subsetting of individual columns is spawned in separate tasks).","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"In general at least Julia 1.4 is required to ensure that multi-threading is used and the Julia process must be started with more than one thread. Some operations turn on multi-threading only if enough rows in the processed data frame are present (the exact threshold when multi-threading is enabled is considered to be undefined and might change in the future).","category":"page"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"Except for the list above, where multi-threading is used automatically, all functions provided by DataFrames.jl that update a data frame are not thread safe. This means that while they can be called from any thread, the caller is responsible for ensuring that a given DataFrame object is never modified by one thread while others are using it (either for reading or writing). Using the same DataFrame at the same time from different threads is safe as long as it is not modified.","category":"page"},{"location":"lib/functions/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"lib/functions/#Constructing-data-frames","page":"Functions","title":"Constructing data frames","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"allcombinations\ncopy\nsimilar","category":"page"},{"location":"lib/functions/#DataAPI.allcombinations","page":"Functions","title":"DataAPI.allcombinations","text":"allcombinations(DataFrame, pairs::Pair...)\nallcombinations(DataFrame; kwargs...)\n\nCreate a DataFrame from all combinations of values in passed arguments. The first passed values vary fastest.\n\nArguments associating a column name with values to expand can be specified either as Pairs passed as positional arguments, or as keyword arguments. Column names must be Symbols or strings and must be unique.\n\nColumn value can be a vector which is consumed as is or an object of any other type (except AbstractArray). In the latter case the passed value is treated as having length one for expansion. As a particular rule values stored in a Ref or a 0-dimensional AbstractArray are unwrapped and treated as having length one.\n\nSee also: crossjoin can be used to get the cartesian product of rows from passed data frames.\n\nExamples\n\njulia> allcombinations(DataFrame, a=1:2, b='a':'c')\n6×2 DataFrame\n Row │ a      b\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n   2 │     2  a\n   3 │     1  b\n   4 │     2  b\n   5 │     1  c\n   6 │     2  c\n\njulia> allcombinations(DataFrame, \"a\" => 1:2, \"b\" => 'a':'c', \"c\" => \"const\")\n6×3 DataFrame\n Row │ a      b     c\n     │ Int64  Char  String\n─────┼─────────────────────\n   1 │     1  a     const\n   2 │     2  a     const\n   3 │     1  b     const\n   4 │     2  b     const\n   5 │     1  c     const\n   6 │     2  c     const\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.copy","page":"Functions","title":"Base.copy","text":"copy(df::DataFrame; copycols::Bool=true)\n\nCopy data frame df. If copycols=true (the default), return a new  DataFrame holding copies of column vectors in df. If copycols=false, return a new DataFrame sharing column vectors with df.\n\nMetadata: this function preserves all table-level and column-level metadata.\n\n\n\n\n\ncopy(dfr::DataFrameRow)\n\nConstruct a NamedTuple with the same contents as the DataFrameRow. This method returns a NamedTuple so that the returned object is not affected by changes to the parent data frame of which dfr is a view.\n\n\n\n\n\ncopy(key::GroupKey)\n\nConstruct a NamedTuple with the same contents as the GroupKey.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.similar","page":"Functions","title":"Base.similar","text":"similar(df::AbstractDataFrame, rows::Integer=nrow(df))\n\nCreate a new DataFrame with the same column names and column element types as df. An optional second argument can be provided to request a number of rows that is different than the number of rows present in df.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Summary-information","page":"Functions","title":"Summary information","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"describe\nisempty\nlength\nncol\nndims\nnrow\nrownumber\nshow\nsize","category":"page"},{"location":"lib/functions/#DataAPI.describe","page":"Functions","title":"DataAPI.describe","text":"describe(df::AbstractDataFrame; cols=:)\ndescribe(df::AbstractDataFrame, stats::Union{Symbol, Pair}...; cols=:)\n\nReturn descriptive statistics for a data frame as a new DataFrame where each row represents a variable and each column a summary statistic.\n\nArguments\n\ndf : the AbstractDataFrame\nstats::Union{Symbol, Pair}... : the summary statistics to report. Arguments can be:\nA symbol from the list :mean, :std, :min, :q25, :median, :q75, :max, :sum, :eltype, :nunique, :nuniqueall, :first, :last, :nnonmissing, and :nmissing. The default statistics used are :mean, :min, :median, :max, :nmissing, and :eltype.\n:detailed as the only Symbol argument to return all statistics except :first, :last, :sum, :nuniqueall, and :nnonmissing.\n:all as the only Symbol argument to return all statistics.\nA function => name pair where name is a Symbol or string. This will create a column of summary statistics with the provided name.\ncols : a keyword argument allowing to select only a subset or transformation of columns from df to describe. Can be any column selector or transformation accepted by select.\n\nDetails\n\nFor Real columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from Real, describe will attempt to calculate all statistics, using nothing as a fall-back in the case of an error.\n\nWhen stats contains :nunique, describe will report the number of unique values in a column. If a column's base type derives from Real, :nunique will return nothings. Use :nuniqueall to report the number of unique values in all columns.\n\nMissing values are filtered in the calculation of all statistics, however the column :nmissing will report the number of missing values of that variable and :nnonmissing the number of non-missing values.\n\nIf custom functions are provided, they are called repeatedly with the vector corresponding to each column as the only argument. For columns allowing for missing values, the vector is wrapped in a call to skipmissing: custom functions must therefore support such objects (and not only vectors), and cannot access missing values.\n\nMetadata: this function drops all metadata.\n\nExamples\n\njulia> df = DataFrame(i=1:10, x=0.1:0.1:1.0, y='a':'j');\n\njulia> describe(df)\n3×7 DataFrame\n Row │ variable  mean    min  median  max  nmissing  eltype\n     │ Symbol    Union…  Any  Union…  Any  Int64     DataType\n─────┼────────────────────────────────────────────────────────\n   1 │ i         5.5     1    5.5     10          0  Int64\n   2 │ x         0.55    0.1  0.55    1.0         0  Float64\n   3 │ y                 a            j           0  Char\n\njulia> describe(df, :min, :max)\n3×3 DataFrame\n Row │ variable  min  max\n     │ Symbol    Any  Any\n─────┼────────────────────\n   1 │ i         1    10\n   2 │ x         0.1  1.0\n   3 │ y         a    j\n\njulia> describe(df, :min, sum => :sum)\n3×3 DataFrame\n Row │ variable  min  sum\n     │ Symbol    Any  Union…\n─────┼───────────────────────\n   1 │ i         1    55\n   2 │ x         0.1  5.5\n   3 │ y         a\n\njulia> describe(df, :min, sum => :sum, cols=:x)\n1×3 DataFrame\n Row │ variable  min      sum\n     │ Symbol    Float64  Float64\n─────┼────────────────────────────\n   1 │ x             0.1      5.5\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.isempty","page":"Functions","title":"Base.isempty","text":"isempty(df::AbstractDataFrame)\n\nReturn true if data frame df has zero rows, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.length","page":"Functions","title":"Base.length","text":"length(dfr::DataFrameRow)\n\nReturn the number of elements of dfr.\n\nSee also: size\n\nExamples\n\njulia> dfr = DataFrame(a=1:3, b='a':'c')[1, :]\nDataFrameRow\n Row │ a      b\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n\njulia> length(dfr)\n2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.ncol","page":"Functions","title":"DataAPI.ncol","text":"ncol(df::AbstractDataFrame)\n\nReturn the number of columns in an AbstractDataFrame df.\n\nSee also nrow, size.\n\nExamples\n\njulia> df = DataFrame(i=1:10, x=rand(10), y=rand([\"a\", \"b\", \"c\"], 10));\n\njulia> ncol(df)\n3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.ndims","page":"Functions","title":"Base.ndims","text":"ndims(::AbstractDataFrame)\nndims(::Type{<:AbstractDataFrame})\n\nReturn the number of dimensions of a data frame, which is always 2.\n\n\n\n\n\nndims(::DataFrameRow)\nndims(::Type{<:DataFrameRow})\n\nReturn the number of dimensions of a data frame row, which is always 1.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.nrow","page":"Functions","title":"DataAPI.nrow","text":"nrow(df::AbstractDataFrame)\n\nReturn the number of rows in an AbstractDataFrame df.\n\nSee also: ncol, size.\n\nExamples\n\njulia> df = DataFrame(i=1:10, x=rand(10), y=rand([\"a\", \"b\", \"c\"], 10));\n\njulia> nrow(df)\n10\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.rownumber","page":"Functions","title":"DataAPI.rownumber","text":"rownumber(dfr::DataFrameRow)\n\nReturn a row number in the AbstractDataFrame that dfr was created from.\n\nNote that this differs from the first element in the tuple returned by parentindices. The latter gives the row number in the parent(dfr), which is the source DataFrame where data that dfr gives access to is stored.\n\nExamples\n\njulia> df = DataFrame(reshape(1:12, 3, 4), :auto)\n3×4 DataFrame\n Row │ x1     x2     x3     x4\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      4      7     10\n   2 │     2      5      8     11\n   3 │     3      6      9     12\n\njulia> dfr = df[2, :]\nDataFrameRow\n Row │ x1     x2     x3     x4\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   2 │     2      5      8     11\n\njulia> rownumber(dfr)\n2\n\njulia> parentindices(dfr)\n(2, Base.OneTo(4))\n\njulia> parent(dfr)\n3×4 DataFrame\n Row │ x1     x2     x3     x4\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      4      7     10\n   2 │     2      5      8     11\n   3 │     3      6      9     12\n\njulia> dfv = @view df[2:3, 1:3]\n2×3 SubDataFrame\n Row │ x1     x2     x3\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      5      8\n   2 │     3      6      9\n\njulia> dfrv = dfv[2, :]\nDataFrameRow\n Row │ x1     x2     x3\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   3 │     3      6      9\n\njulia> rownumber(dfrv)\n2\n\njulia> parentindices(dfrv)\n(3, 1:3)\n\njulia> parent(dfrv)\n3×4 DataFrame\n Row │ x1     x2     x3     x4\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      4      7     10\n   2 │     2      5      8     11\n   3 │     3      6      9     12\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.show","page":"Functions","title":"Base.show","text":"show([io::IO, ]df::AbstractDataFrame;\n     allrows::Bool = !get(io, :limit, false),\n     allcols::Bool = !get(io, :limit, false),\n     allgroups::Bool = !get(io, :limit, false),\n     rowlabel::Symbol = :Row,\n     summary::Bool = true,\n     eltypes::Bool = true,\n     truncate::Int = 32,\n     kwargs...)\n\nRender a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.\n\nIf io is omitted, the result is printed to stdout, and allrows, allcols and allgroups default to false.\n\nArguments\n\nio::IO: The I/O stream to which df will be printed.\ndf::AbstractDataFrame: The data frame to print.\nallrows::Bool: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if io does not have the IOContext property limit set.\nallcols::Bool: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if io does not have the IOContext property limit set.\nallgroups::Bool: Whether to print all groups rather than the first and last, when df is a GroupedDataFrame. By default this is the case only if io does not have the IOContext property limit set.\nrowlabel::Symbol = :Row: The label to use for the column containing row numbers.\nsummary::Bool = true: Whether to print a brief string summary of the data frame.\neltypes::Bool = true: Whether to print the column types under column names.\ntruncate::Int = 32: the maximal display width the output can use before being truncated (in the textwidth sense, excluding …). If truncate is 0 or less, no truncation is applied.\nkwargs...: Any keyword argument supported by the function pretty_table of PrettyTables.jl can be passed here to customize the output.\n\nExamples\n\njulia> using DataFrames\n\njulia> df = DataFrame(A=1:3, B=[\"x\", \"y\", \"z\"]);\n\njulia> show(df, show_row_number=false)\n3×2 DataFrame\n A      B\n Int64  String\n───────────────\n     1  x\n     2  y\n     3  z\n\n\n\n\n\nshow(io::IO, mime::MIME, df::AbstractDataFrame)\n\nRender a data frame to an I/O stream in MIME type mime.\n\nArguments\n\nio::IO: The I/O stream to which df will be printed.\nmime::MIME: supported MIME types are: \"text/plain\", \"text/html\", \"text/latex\", \"text/csv\", \"text/tab-separated-values\" (the last two MIME types do not support  showing #undef values)\ndf::AbstractDataFrame: The data frame to print.\n\nAdditionally selected MIME types support passing the following keyword arguments:\n\nMIME type \"text/plain\" accepts all listed keyword arguments and their behavior is identical as for show(::IO, ::AbstractDataFrame)\nMIME type \"text/html\" accepts the following keyword arguments:\neltypes::Bool = true: Whether to print the column types under column names.\nsummary::Bool = true: Whether to print a brief string summary of the data frame.\nmax_column_width::AbstractString = \"\": The maximum column width. It must     be a string containing a valid CSS length. For example, passing     \"100px\" will limit the width of all columns to 100 pixels. If empty,     the columns will be rendered without limits.\nkwargs...: Any keyword argument supported by the function pretty_table of PrettyTables.jl can be passed here to customize the output.\n\nExamples\n\njulia> show(stdout, MIME(\"text/latex\"), DataFrame(A=1:3, B=[\"x\", \"y\", \"z\"]))\n\\begin{tabular}{r|cc}\n\t& A & B\\\\\n\t\\hline\n\t& Int64 & String\\\\\n\t\\hline\n\t1 & 1 & x \\\\\n\t2 & 2 & y \\\\\n\t3 & 3 & z \\\\\n\\end{tabular}\n14\n\njulia> show(stdout, MIME(\"text/csv\"), DataFrame(A=1:3, B=[\"x\", \"y\", \"z\"]))\n\"A\",\"B\"\n1,\"x\"\n2,\"y\"\n3,\"z\"\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.size","page":"Functions","title":"Base.size","text":"size(df::AbstractDataFrame[, dim])\n\nReturn a tuple containing the number of rows and columns of df. Optionally a dimension dim can be specified, where 1 corresponds to rows and 2 corresponds to columns.\n\nSee also: nrow, ncol\n\nExamples\n\njulia> df = DataFrame(a=1:3, b='a':'c');\n\njulia> size(df)\n(3, 2)\n\njulia> size(df, 1)\n3\n\n\n\n\n\nsize(dfr::DataFrameRow[, dim])\n\nReturn a 1-tuple containing the number of elements of dfr. If an optional dimension dim is specified, it must be 1, and the number of elements is returned directly as a number.\n\nSee also: length\n\nExamples\n\njulia> dfr = DataFrame(a=1:3, b='a':'c')[1, :]\nDataFrameRow\n Row │ a      b\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n\njulia> size(dfr)\n(2,)\n\njulia> size(dfr, 1)\n2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Working-with-column-names","page":"Functions","title":"Working with column names","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"names\npropertynames\nrename\nrename!","category":"page"},{"location":"lib/functions/#Base.names","page":"Functions","title":"Base.names","text":"names(df::AbstractDataFrame, cols=:)\nnames(df::DataFrameRow, cols=:)\nnames(df::GroupedDataFrame, cols=:)\nnames(df::DataFrameRows, cols=:)\nnames(df::DataFrameColumns, cols=:)\nnames(df::GroupKey)\n\nReturn a freshly allocated Vector{String} of names of columns contained in df.\n\nIf cols is passed then restrict returned column names to those matching the selector (this is useful in particular with regular expressions, Cols, Not, and Between). cols can be:\n\nany column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers); these column selectors are documented in the General rules section of the Indexing part of the DataFrames.jl manual\na Type, in which case names of columns whose eltype is a subtype of T are returned\na Function predicate taking the column name as a string and returning true for columns that should be kept\n\nSee also propertynames which returns a Vector{Symbol}.\n\nExamples\n\njulia> df = DataFrame(x1=[1, missing, missing], x2=[3, 2, 4], x3=[3, missing, 2], x4=Union{Int, Missing}[2, 4, 4])\n3×4 DataFrame\n Row │ x1       x2     x3       x4\n     │ Int64?   Int64  Int64?   Int64?\n─────┼─────────────────────────────────\n   1 │       1      3        3       2\n   2 │ missing      2  missing       4\n   3 │ missing      4        2       4\n\njulia> names(df)\n4-element Vector{String}:\n \"x1\"\n \"x2\"\n \"x3\"\n \"x4\"\n\njulia> names(df, Int) # pick columns whose element type is Int\n1-element Vector{String}:\n \"x2\"\n\njulia> names(df, x -> x[end] == '2') # pick columns for which last character in their name is '2'\n1-element Vector{String}:\n \"x2\"\n\njulia> fun(col) = sum(skipmissing(col)) >= 10\nfun (generic function with 1 method)\n\njulia> names(df, fun.(eachcol(df))) # pick columns for which sum of their elements is at least 10\n1-element Vector{String}:\n \"x4\"\n\njulia> names(df, eltype.(eachcol(df)) .>: Missing) # pick columns that allow missing values\n3-element Vector{String}:\n \"x1\"\n \"x3\"\n \"x4\"\n\njulia> names(df, any.(ismissing, eachcol(df))) # pick columns that contain missing values\n2-element Vector{String}:\n \"x1\"\n \"x3\"\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.propertynames","page":"Functions","title":"Base.propertynames","text":"propertynames(df::AbstractDataFrame)\n\nReturn a freshly allocated Vector{Symbol} of names of columns contained in df.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.rename","page":"Functions","title":"DataFrames.rename","text":"rename(df::AbstractDataFrame, vals::AbstractVector{Symbol};\n       makeunique::Bool=false)\nrename(df::AbstractDataFrame, vals::AbstractVector{<:AbstractString};\n       makeunique::Bool=false)\nrename(df::AbstractDataFrame, (from => to)::Pair...)\nrename(df::AbstractDataFrame, d::AbstractDict)\nrename(df::AbstractDataFrame, d::AbstractVector{<:Pair})\nrename(f::Function, df::AbstractDataFrame; cols=All())\n\nCreate a new data frame that is a copy of df with changed column names. Each name is changed at most once. Permutation of names is allowed.\n\nArguments\n\ndf : the AbstractDataFrame; if it is a SubDataFrame then renaming is only allowed if it was created using : as a column selector.\nd : an AbstractDict or an AbstractVector of Pairs that maps the original names or column numbers to new names\nf : a function which for each column selected by the cols keyword argument takes the old name as a String and returns the new name that gets converted to a Symbol; the cols column selector can be any value accepted as column selector by the names function\nvals : new column names as a vector of Symbols or AbstractStrings of the same length as the number of columns in df\nmakeunique : if false (the default), an error will be raised if duplicate names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf pairs are passed to rename (as positional arguments or in a dictionary or a vector) then:\n\nfrom value can be a Symbol, an AbstractString or an Integer;\nto value can be a Symbol or an AbstractString.\n\nMixing symbols and strings in to and from is not allowed.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nColumn-level :note-style metadata is considered to be attached to column number: when a column is renamed, its :note-style metadata becomes associated to its new name.\n\nSee also: rename!\n\nExamples\n\njulia> df = DataFrame(i=1, x=2, y=3)\n1×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(df, [:a, :b, :c])\n1×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(df, :i => \"A\", :x => \"X\")\n1×3 DataFrame\n Row │ A      X      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(df, :x => :y, :y => :x)\n1×3 DataFrame\n Row │ i      y      x\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(df, [1 => :A, 2 => :X])\n1×3 DataFrame\n Row │ A      X      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(df, Dict(\"i\" => \"A\", \"x\" => \"X\"))\n1×3 DataFrame\n Row │ A      X      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(uppercase, df)\n1×3 DataFrame\n Row │ I      X      Y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename(uppercase, df, cols=contains('x'))\n1×3 DataFrame\n Row │ i      X      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.rename!","page":"Functions","title":"DataFrames.rename!","text":"rename!(df::AbstractDataFrame, vals::AbstractVector{Symbol};\n        makeunique::Bool=false)\nrename!(df::AbstractDataFrame, vals::AbstractVector{<:AbstractString};\n        makeunique::Bool=false)\nrename!(df::AbstractDataFrame, (from => to)::Pair...)\nrename!(df::AbstractDataFrame, d::AbstractDict)\nrename!(df::AbstractDataFrame, d::AbstractVector{<:Pair})\nrename!(f::Function, df::AbstractDataFrame; cols=All())\n\nRename columns of df in-place. Each name is changed at most once. Permutation of names is allowed.\n\nArguments\n\ndf : the AbstractDataFrame\nd : an AbstractDict or an AbstractVector of Pairs that maps the original names or column numbers to new names\nf : a function which for each column selected by the cols keyword argument takes the old name as a String and returns the new name that gets converted to a Symbol; the cols column selector can be any value accepted as column selector by the names function\nvals : new column names as a vector of Symbols or AbstractStrings of the same length as the number of columns in df\nmakeunique : if false (the default), an error will be raised if duplicate names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf pairs are passed to rename! (as positional arguments or in a dictionary or a vector) then:\n\nfrom value can be a Symbol, an AbstractString or an Integer;\nto value can be a Symbol or an AbstractString.\n\nMixing symbols and strings in to and from is not allowed.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nMetadata having other styles is dropped (from parent data frame when df is a SubDataFrame). Column-level :note-style metadata is considered to be attached to column number: when a column is renamed, its :note-style metadata becomes associated to its new name.\n\nSee also: rename\n\nExamples\n\njulia> df = DataFrame(i=1, x=2, y=3)\n1×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename!(df, Dict(:i => \"A\", :x => \"X\"))\n1×3 DataFrame\n Row │ A      X      y\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename!(df, [:a, :b, :c])\n1×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename!(df, [:a, :b, :a])\nERROR: ArgumentError: Duplicate variable names: :a. Pass makeunique=true to make them unique using a suffix automatically.\n\njulia> rename!(df, [:a, :b, :a], makeunique=true)\n1×3 DataFrame\n Row │ a      b      a_1\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename!(uppercase, df)\n1×3 DataFrame\n Row │ A      B      A_1\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\njulia> rename!(lowercase, df, cols=contains('A'))\n1×3 DataFrame\n Row │ a      B      a_1\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Mutating-and-transforming-data-frames-and-grouped-data-frames","page":"Functions","title":"Mutating and transforming data frames and grouped data frames","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"append!\ncombine\nfillcombinations\nflatten\nhcat\ninsert!\ninsertcols\ninsertcols!\ninvpermute!\nmapcols\nmapcols!\npermute!\nprepend!\npush!\npushfirst!\nreduce\nrepeat\nrepeat!\nreverse\nreverse!\nselect\nselect!\nshuffle\nshuffle!\ntable_transformation\ntransform\ntransform!\nvcat","category":"page"},{"location":"lib/functions/#Base.append!","page":"Functions","title":"Base.append!","text":"append!(df::DataFrame, tables...; cols::Symbol=:setequal,\n        promote::Bool=(cols in [:union, :subset]))\n\nAdd the rows of tables passed as tables to the end of df. If the table is not an AbstractDataFrame then it is converted using DataFrame(table, copycols=false) before being appended.\n\nThe exact behavior of append! depends on the cols argument:\n\nIf cols == :setequal (this is the default) then df2 must contain exactly the same columns as df (but possibly in a different order).\nIf cols == :orderequal then df2 must contain the same columns in the same order (for AbstractDict this option requires that keys(row) matches propertynames(df) to allow for support of ordered dicts; however, if df2 is a Dict an error is thrown as it is an unordered collection).\nIf cols == :intersect then df2 may contain more columns than df, but all column names that are present in df must be present in df2 and only these are used.\nIf cols == :subset then append! behaves like for :intersect but if some column is missing in df2 then a missing value is pushed to df.\nIf cols == :union then append! adds columns missing in df that are present in df2, for columns present in df but missing in df2 a missing value is pushed.\n\nIf promote=true and element type of a column present in df does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in df. If promote=false an error is thrown.\n\nThe above rule has the following exceptions:\n\nIf df has no columns then copies of columns from df2 are added to it.\nIf df2 has no columns then calling append! leaves df unchanged.\n\nPlease note that append! must not be used on a DataFrame that contains columns that are aliases (equal when compared with ===).\n\nMetadata: table-level :note-style metadata and column-level :note-style metadata for columns present in df are preserved. If new columns are added their :note-style metadata is copied from the appended table. Other metadata is dropped.\n\nSee also: use push! to add individual rows to a data frame, prepend! to add a table at the beginning, and vcat to vertically concatenate data frames.\n\nExamples\n\njulia> df1 = DataFrame(A=1:3, B=1:3)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n\njulia> df2 = DataFrame(A=4.0:6.0, B=4:6)\n3×2 DataFrame\n Row │ A        B\n     │ Float64  Int64\n─────┼────────────────\n   1 │     4.0      4\n   2 │     5.0      5\n   3 │     6.0      6\n\njulia> append!(df1, df2);\n\njulia> df1\n6×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     4      4\n   5 │     5      5\n   6 │     6      6\n\njulia> append!(df2, DataFrame(A=1), (; C=1:2), cols=:union)\n6×3 DataFrame\n Row │ A          B        C\n     │ Float64?   Int64?   Int64?\n─────┼─────────────────────────────\n   1 │       4.0        4  missing\n   2 │       5.0        5  missing\n   3 │       6.0        6  missing\n   4 │       1.0  missing  missing\n   5 │ missing    missing        1\n   6 │ missing    missing        2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.combine","page":"Functions","title":"DataFrames.combine","text":"combine(df::AbstractDataFrame, args...;\n        renamecols::Bool=true, threads::Bool=true)\ncombine(f::Callable, df::AbstractDataFrame;\n        renamecols::Bool=true, threads::Bool=true)\ncombine(gd::GroupedDataFrame, args...;\n        keepkeys::Bool=true, ungroup::Bool=true,\n        renamecols::Bool=true, threads::Bool=true)\ncombine(f::Base.Callable, gd::GroupedDataFrame;\n        keepkeys::Bool=true, ungroup::Bool=true,\n        renamecols::Bool=true, threads::Bool=true)\n\nCreate a new data frame that contains columns from df or gd specified by args and return it. The result can have any number of rows that is determined by the values returned by passed transformations.\n\nBelow detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.\n\nAll these operations are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.\n\nIn order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.\n\nOperations can then be applied on each group using one of the following functions:\n\ncombine: does not put restrictions on number of rows returned per group; the returned values are vertically concatenated following order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group; for GroupedDataFrame if grouping columns are kept they are put as first columns in the result;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select; for GroupedDataFrame if grouping columns are kept they are put as first columns in the result;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform; existing columns in the source data frame are put as first columns in the result;\n\nAs a special case, if a GroupedDataFrame that has zero groups is passed then the result of the operation is determined by performing a single call to the transformation function with a 0-row argument passed to it. The output of this operation is only used to identify the number and type of produced columns, but the result has zero rows.\n\nAll these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:\n\nstandard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns, which must be a single name (as a Symbol or a string), a vector of names or AsTable. Additionally it can be a Function which takes a string or a vector of strings as an argument containing names of columns selected by cols, and returns the target columns names (all accepted types except AsTable are allowed).\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\ncolumn-independent operations function => target_cols or just function for specific functions where the input columns are omitted; without target_cols the new column has the same name as function, otherwise it must be single name (as a Symbol or a string). Supported functions are:\nnrow to efficiently compute the number of rows in each group.\nproprow to efficiently compute the proportion of rows in each group.\neachindex to return a vector holding the number of each row within each group.\ngroupindices to return the group number.\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group if a GroupedDataFrame is processed, or with the data frame itself if an AbstractDataFrame is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)\n\nNote! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.\n\nNote! If cols or target_cols are one of All, Cols, Between, or Not, broadcasting using .=> is supported and is equivalent to broadcasting the result of names(df, cols) or names(df, target_cols). This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.\n\nAll functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).\n\nAs a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function. The documentation of DataFrames.table_transformation provides more information about this functionality, in particular covering performance considerations.\n\nWhat is allowed for function to return is determined by the target_cols value:\n\nIf both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, Tables.AbstractRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.\n\nIn all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.\n\nselect/select! and transform/transform! always return a data frame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).\n\nFor combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.\n\nIt is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.\n\nTo apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.\n\nIf a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nIn general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: :x1, [:x1, :x2], :x1 => :x2, :x1 => identity => :x2, or :x1 => (x -> @view x[inds]) (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the copycols keyword argument:\n\nif copycols=true then results of such transformations always perform a copy of the source column or its view;\nif copycols=false then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using ===, which excludes views of source columns) performs a copy;\n\nNote that performing transform! or select! assumes that copycols=false.\n\nIf df is a SubDataFrame and copycols=true then a DataFrame is returned and the same copying rules apply as for a DataFrame input: this means in particular that selected columns will be copied. If copycols=false, a SubDataFrame is returned without copying columns and in this case transforming or renaming columns is not allowed.\n\nIf a GroupedDataFrame is passed and threads=true (the default), a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions must therefore not modify global variables (i.e. they must be pure), use locks to control parallel accesses, or threads=false must be passed to disable multithreading. In the future, parallelism may be extended to other cases, so this requirement also holds for DataFrame inputs.\n\nIn order to improve the performance of the operations some transformations invoke optimized implementation, see DataFrames.table_transformation for details.\n\nKeyword arguments\n\nrenamecols::Bool=true : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.\nkeepkeys::Bool=true : whether grouping columns of gd should be kept in the returned data frame.\nungroup::Bool=true : whether the return value of the operation on gd should be a data frame or a GroupedDataFrame.\nthreads::Bool=true : whether transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to false if some transformations require serial execution or are not thread-safe.\n\nMetadata: this function propagates table-level :note-style metadata. Column-level :note-style metadata is propagated if: a) a single column is transformed to a single column and the name of the column   does not change (this includes all column selection operations), or b) a single column is transformed with identity or copy to a single column    even if column name is changed (this includes column renaming).    As a special case for GroupedDataFrame if the output has the same name    as a grouping column and keepkeys=true, metadata is taken from    original grouping column.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> combine(df, :a => sum, nrow, renamecols=false)\n1×2 DataFrame\n Row │ a      nrow\n     │ Int64  Int64\n─────┼──────────────\n   1 │     6      3\n\njulia> combine(df, :a => ByRow(sin) => :c, :b)\n3×2 DataFrame\n Row │ c         b\n     │ Float64   Int64\n─────┼─────────────────\n   1 │ 0.841471      4\n   2 │ 0.909297      5\n   3 │ 0.14112       6\n\njulia> combine(df, :, [:a, :b] => (a, b) -> a .+ b .- sum(b)/length(b))\n3×3 DataFrame\n Row │ a      b      a_b_function\n     │ Int64  Int64  Float64\n─────┼────────────────────────────\n   1 │     1      4           0.0\n   2 │     2      5           2.0\n   3 │     3      6           4.0\n\njulia> combine(df, All() .=> [minimum maximum])\n1×4 DataFrame\n Row │ a_minimum  b_minimum  a_maximum  b_maximum\n     │ Int64      Int64      Int64      Int64\n─────┼────────────────────────────────────────────\n   1 │         1          4          3          6\n\njulia> using Statistics\n\njulia> combine(df, AsTable(:) => ByRow(mean), renamecols=false)\n3×1 DataFrame\n Row │ a_b\n     │ Float64\n─────┼─────────\n   1 │     2.5\n   2 │     3.5\n   3 │     4.5\n\njulia> combine(df, AsTable(:) => ByRow(mean) => x -> join(x, \"_\"))\n3×1 DataFrame\n Row │ a_b\n     │ Float64\n─────┼─────────\n   1 │     2.5\n   2 │     3.5\n   3 │     4.5\n\njulia> combine(first, df)\n1×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n\njulia> df = DataFrame(a=1:3, b=4:6, c=7:9)\n3×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      4      7\n   2 │     2      5      8\n   3 │     3      6      9\n\njulia> combine(df, AsTable(:) => ByRow(x -> (mean=mean(x), std=std(x))) => :stats,\n               AsTable(:) => ByRow(x -> (mean=mean(x), std=std(x))) => AsTable)\n3×3 DataFrame\n Row │ stats                    mean     std\n     │ NamedTup…                Float64  Float64\n─────┼───────────────────────────────────────────\n   1 │ (mean = 4.0, std = 3.0)      4.0      3.0\n   2 │ (mean = 5.0, std = 3.0)      5.0      3.0\n   3 │ (mean = 6.0, std = 3.0)      6.0      3.0\n\njulia> df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),\n                      b=repeat([2, 1], outer=[4]),\n                      c=1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> combine(gd, :c => sum, nrow)\n4×3 DataFrame\n Row │ a      c_sum  nrow\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      6      2\n   2 │     2      8      2\n   3 │     3     10      2\n   4 │     4     12      2\n\njulia> combine(gd, :c => sum, nrow, ungroup=false)\nGroupedDataFrame with 4 groups based on key: a\nFirst Group (1 row): a = 1\n Row │ a      c_sum  nrow\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      6      2\n⋮\nLast Group (1 row): a = 4\n Row │ a      c_sum  nrow\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     4     12      2\n\njulia> combine(gd) do d # do syntax for the slower variant\n           sum(d.c)\n       end\n4×2 DataFrame\n Row │ a      x1\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      6\n   2 │     2      8\n   3 │     3     10\n   4 │     4     12\n\njulia> combine(gd, :c => (x -> sum(log, x)) => :sum_log_c) # specifying a name for target column\n4×2 DataFrame\n Row │ a      sum_log_c\n     │ Int64  Float64\n─────┼──────────────────\n   1 │     1    1.60944\n   2 │     2    2.48491\n   3 │     3    3.04452\n   4 │     4    3.46574\n\njulia> combine(gd, [:b, :c] .=> sum) # passing a vector of pairs\n4×3 DataFrame\n Row │ a      b_sum  c_sum\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      4      6\n   2 │     2      2      8\n   3 │     3      4     10\n   4 │     4      2     12\n\njulia> combine(gd) do sdf # dropping group when DataFrame() is returned\n          sdf.c[1] != 1 ? sdf : DataFrame()\n       end\n6×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      1      2\n   2 │     2      1      6\n   3 │     3      2      3\n   4 │     3      2      7\n   5 │     4      1      4\n   6 │     4      1      8\n\nauto-splatting, renaming and keepkeys\n\njulia> df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),\n                      b=repeat([2, 1], outer=[4]),\n                      c=1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> combine(gd, :b => :b1, :c => :c1, [:b, :c] => +, keepkeys=false)\n8×3 DataFrame\n Row │ b1     c1     b_c_+\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      1      3\n   2 │     2      5      7\n   3 │     1      2      3\n   4 │     1      6      7\n   5 │     2      3      5\n   6 │     2      7      9\n   7 │     1      4      5\n   8 │     1      8      9\n\nbroadcasting and column expansion\n\njulia> df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),\n                      b=repeat([2, 1], outer=[4]),\n                      c=1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> combine(gd, :b, AsTable([:b, :c]) => ByRow(extrema) => [:min, :max])\n8×4 DataFrame\n Row │ a      b      min    max\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      1      2\n   2 │     1      2      2      5\n   3 │     2      1      1      2\n   4 │     2      1      1      6\n   5 │     3      2      2      3\n   6 │     3      2      2      7\n   7 │     4      1      1      4\n   8 │     4      1      1      8\n\njulia> combine(gd, [:b, :c] .=> Ref) # preventing vector from being spread across multiple rows\n4×3 DataFrame\n Row │ a      b_Ref      c_Ref\n     │ Int64  SubArray…  SubArray…\n─────┼─────────────────────────────\n   1 │     1  [2, 2]     [1, 5]\n   2 │     2  [1, 1]     [2, 6]\n   3 │     3  [2, 2]     [3, 7]\n   4 │     4  [1, 1]     [4, 8]\n\njulia> combine(gd, AsTable(Not(:a)) => Ref) # protecting result\n4×2 DataFrame\n Row │ a      b_c_Ref\n     │ Int64  NamedTup…\n─────┼─────────────────────────────────\n   1 │     1  (b = [2, 2], c = [1, 5])\n   2 │     2  (b = [1, 1], c = [2, 6])\n   3 │     3  (b = [2, 2], c = [3, 7])\n   4 │     4  (b = [1, 1], c = [4, 8])\n\njulia> combine(gd, :, AsTable(Not(:a)) => sum, renamecols=false)\n8×4 DataFrame\n Row │ a      b      c      b_c\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      1      3\n   2 │     1      2      5      7\n   3 │     2      1      2      3\n   4 │     2      1      6      7\n   5 │     3      2      3      5\n   6 │     3      2      7      9\n   7 │     4      1      4      5\n   8 │     4      1      8      9\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.fillcombinations","page":"Functions","title":"DataFrames.fillcombinations","text":"fillcombinations(df::AbstractDataFrame, indexcols;\n                     allowduplicates::Bool=false,\n                     fill=missing)\n\nGenerate all combinations of levels of column(s) indexcols in data frame df. Levels and their order are determined by the levels function (i.e. unique values sorted lexicographically by default, or a custom set of levels for e.g. CategoricalArray columns), in addition to missing if present.\n\nFor combinations of indexcols not present in df these columns are filled with the fill value (missing by default).\n\nIf allowduplicates=false (the default) indexcols may only contain unique combinations of indexcols values. If allowduplicates=true duplicates are allowed.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(x=1:2, y='a':'b', z=[\"x\", \"y\"])\n2×3 DataFrame\n Row │ x      y     z\n     │ Int64  Char  String\n─────┼─────────────────────\n   1 │     1  a     x\n   2 │     2  b     y\n\njulia> fillcombinations(df, [:x, :y])\n4×3 DataFrame\n Row │ x      y     z\n     │ Int64  Char  String?\n─────┼──────────────────────\n   1 │     1  a     x\n   2 │     2  a     missing\n   3 │     1  b     missing\n   4 │     2  b     y\n\njulia> fillcombinations(df, [:y, :z], fill=0)\n4×3 DataFrame\n Row │ x       y     z\n     │ Int64?  Char  String\n─────┼──────────────────────\n   1 │      1  a     x\n   2 │      0  b     x\n   3 │      0  a     y\n   4 │      2  b     y\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.flatten","page":"Functions","title":"DataFrames.flatten","text":"flatten(df::AbstractDataFrame, cols; scalar::Type=Union{})\n\nWhen columns cols of data frame df have iterable elements that define length (for example a Vector of Vectors), return a DataFrame where each element of each col in cols is flattened, meaning the column corresponding to col becomes a longer vector where the original entries are concatenated. Elements of row i of df in columns other than cols will be repeated according to the length of df[i, col]. These lengths must therefore be the same for each col in cols, or else an error is raised. Note that these elements are not copied, and thus if they are mutable changing them in the returned DataFrame will affect df.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf scalar is passed then values that have this type in flattened columns are treated as scalars and broadcasted as many times as is needed to match lengths of values stored in other columns. If all values in a row are scalars, a single row is produced.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df1 = DataFrame(a=[1, 2], b=[[1, 2], [3, 4]], c=[[5, 6], [7, 8]])\n2×3 DataFrame\n Row │ a      b       c\n     │ Int64  Array…  Array…\n─────┼───────────────────────\n   1 │     1  [1, 2]  [5, 6]\n   2 │     2  [3, 4]  [7, 8]\n\njulia> flatten(df1, :b)\n4×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Array…\n─────┼──────────────────────\n   1 │     1      1  [5, 6]\n   2 │     1      2  [5, 6]\n   3 │     2      3  [7, 8]\n   4 │     2      4  [7, 8]\n\njulia> flatten(df1, [:b, :c])\n4×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      1      5\n   2 │     1      2      6\n   3 │     2      3      7\n   4 │     2      4      8\n\njulia> df2 = DataFrame(a=[1, 2], b=[(\"p\", \"q\"), (\"r\", \"s\")])\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Tuple…\n─────┼───────────────────\n   1 │     1  (\"p\", \"q\")\n   2 │     2  (\"r\", \"s\")\n\njulia> flatten(df2, :b)\n4×2 DataFrame\n Row │ a      b\n     │ Int64  String\n─────┼───────────────\n   1 │     1  p\n   2 │     1  q\n   3 │     2  r\n   4 │     2  s\n\njulia> df3 = DataFrame(a=[1, 2], b=[[1, 2], [3, 4]], c=[[5, 6], [7]])\n2×3 DataFrame\n Row │ a      b       c\n     │ Int64  Array…  Array…\n─────┼───────────────────────\n   1 │     1  [1, 2]  [5, 6]\n   2 │     2  [3, 4]  [7]\n\njulia> flatten(df3, [:b, :c])\nERROR: ArgumentError: Lengths of iterables stored in columns :b and :c are not the same in row 2\n\njulia> df4 = DataFrame(a=[1, 2, 3],\n                       b=[[1, 2], missing, missing],\n                       c=[[5, 6], missing, [7, 8]])\n3×3 DataFrame\n Row │ a      b        c\n     │ Int64  Array…?  Array…?\n─────┼─────────────────────────\n   1 │     1  [1, 2]   [5, 6]\n   2 │     2  missing  missing\n   3 │     3  missing  [7, 8]\n\njulia> flatten(df4, [:b, :c], scalar=Missing)\n5×3 DataFrame\n Row │ a      b        c\n     │ Int64  Int64?   Int64?\n─────┼─────────────────────────\n   1 │     1        1        5\n   2 │     1        2        6\n   3 │     2  missing  missing\n   4 │     3  missing        7\n   5 │     3  missing        8\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.hcat","page":"Functions","title":"Base.hcat","text":"hcat(df::AbstractDataFrame...;\n     makeunique::Bool=false, copycols::Bool=true)\n\nHorizontally concatenate data frames.\n\nIf makeunique=false (the default) column names of passed objects must be unique. If makeunique=true then duplicate column names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf copycols=true (the default) then the DataFrame returned by hcat will contain copied columns from the source data frames. If copycols=false then it will contain columns as they are stored in the source (without copying). This option should be used with caution as mutating either the columns in sources or in the returned DataFrame might lead to the corruption of the other object.\n\nMetadata: hcat propagates table-level :note-style metadata for keys that are present in all passed data frames and have the same value; it propagates column-level :note-style metadata.\n\nExample\n\njulia> df1 = DataFrame(A=1:3, B=1:3)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n\njulia> df2 = DataFrame(A=4:6, B=4:6)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     4      4\n   2 │     5      5\n   3 │     6      6\n\njulia> df3 = hcat(df1, df2, makeunique=true)\n3×4 DataFrame\n Row │ A      B      A_1    B_1\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      1      4      4\n   2 │     2      2      5      5\n   3 │     3      3      6      6\n\njulia> df3.A === df1.A\nfalse\n\njulia> df3 = hcat(df1, df2, makeunique=true, copycols=false);\n\njulia> df3.A === df1.A\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.insert!","page":"Functions","title":"Base.insert!","text":"insert!(df::DataFrame, index::Integer, row::Union{Tuple, AbstractArray};\n        cols::Symbol=:setequal, promote::Bool=false)\ninsert!(df::DataFrame, index::Integer, row::Union{DataFrameRow, NamedTuple,\n                                                  AbstractDict, Tables.AbstractRow};\n        cols::Symbol=:setequal, promote::Bool=(cols in [:union, :subset]))\n\nAdd one row to df at position index in-place, taking the values from row. index must be a integer between 1 and nrow(df)+1.\n\nColumn types of df are preserved, and new values are converted if necessary. An error is thrown if conversion fails.\n\nIf row is neither a DataFrameRow, NamedTuple nor AbstractDict then it must be a Tuple or an AbstractArray and columns are matched by order of appearance. In this case row must contain the same number of elements as the number of columns in df.\n\nIf row is a DataFrameRow, NamedTuple, AbstractDict, or Tables.AbstractRow then values in row are matched to columns in df based on names. The exact behavior depends on the cols argument value in the following way:\n\nIf cols == :setequal (this is the default) then row must contain exactly the same columns as df (but possibly in a different order).\nIf cols == :orderequal then row must contain the same columns in the same order (for AbstractDict this option requires that keys(row) matches propertynames(df) to allow for support of ordered dicts; however, if row is a Dict an error is thrown as it is an unordered collection).\nIf cols == :intersect then row may contain more columns than df, but all column names that are present in df must be present in row and only they are used to populate a new row in df.\nIf cols == :subset then the behavior is like for :intersect but if some column is missing in row then a missing value is pushed to df.\nIf cols == :union then columns missing in df that are present in row are added to df (using missing for existing rows) and a missing value is pushed to columns missing in row that are present in df.\n\nIf row is not a DataFrameRow, NamedTuple, AbstractDict, or Tables.AbstractRow the cols keyword argument must be :setequal (the default), because such rows do not provide column name information.\n\nIf promote=true and element type of a column present in df does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in df. If promote=false an error is thrown.\n\nAs a special case, if df has no columns and row is a NamedTuple, DataFrameRow, or Tables.AbstractRow, columns are created for all values in row, using their names and order.\n\nPlease note that this function must not be used on a DataFrame that contains columns that are aliases (equal when compared with ===).\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nSee also: push!, pushfirst!\n\nExamples\n\njulia> df = DataFrame(A='a':'c', B=1:3)\n3×2 DataFrame\n Row │ A     B\n     │ Char  Int64\n─────┼─────────────\n   1 │ a         1\n   2 │ b         2\n   3 │ c         3\n\njulia> insert!(df, 2, (true, false), promote=true)\n4×2 DataFrame\n Row │ A     B\n     │ Any   Int64\n─────┼─────────────\n   1 │ a         1\n   2 │ true      0\n   3 │ b         2\n   4 │ c         3\n\njulia> insert!(df, 5, df[1, :])\n5×2 DataFrame\n Row │ A     B\n     │ Any   Int64\n─────┼─────────────\n   1 │ a         1\n   2 │ true      0\n   3 │ b         2\n   4 │ c         3\n   5 │ a         1\n\njulia> insert!(df, 1, (C=\"something\", A=11, B=12), cols=:intersect)\n6×2 DataFrame\n Row │ A     B\n     │ Any   Int64\n─────┼─────────────\n   1 │ 11       12\n   2 │ a         1\n   3 │ true      0\n   4 │ b         2\n   5 │ c         3\n   6 │ a         1\n\njulia> insert!(df, 7, Dict(:A=>1.0, :C=>1.0), cols=:union)\n7×3 DataFrame\n Row │ A     B        C\n     │ Any   Int64?   Float64?\n─────┼──────────────────────────\n   1 │ 11         12  missing\n   2 │ a           1  missing\n   3 │ true        0  missing\n   4 │ b           2  missing\n   5 │ c           3  missing\n   6 │ a           1  missing\n   7 │ 1.0   missing        1.0\n\njulia> insert!(df, 3, NamedTuple(), cols=:subset)\n8×3 DataFrame\n Row │ A        B        C\n     │ Any      Int64?   Float64?\n─────┼─────────────────────────────\n   1 │ 11            12  missing\n   2 │ a              1  missing\n   3 │ missing  missing  missing\n   4 │ true           0  missing\n   5 │ b              2  missing\n   6 │ c              3  missing\n   7 │ a              1  missing\n   8 │ 1.0      missing        1.0\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.insertcols","page":"Functions","title":"DataFrames.insertcols","text":"insertcols(df::AbstractDataFrame[, col], (name=>val)::Pair...;\n           after::Bool=false, makeunique::Bool=false, copycols::Bool=true)\n\nInsert a column into a copy of df data frame using the insertcols! function and return the newly created data frame.\n\nIf col is omitted it is set to ncol(df)+1 (the column is inserted as the last column).\n\nArguments\n\ndf : the data frame to which we want to add columns\ncol : a position at which we want to insert a column, passed as an integer or a column name (a string or a Symbol); the column selected with col and columns following it are shifted to the right in df after the operation\nname : the name of the new column\nval : an AbstractVector giving the contents of the new column or a value of any type other than AbstractArray which will be repeated to fill a new vector; As a particular rule a values stored in a Ref or a 0-dimensional AbstractArray are unwrapped and treated in the same way\nafter : if true columns are inserted after col\nmakeunique : defines what to do if name already exists in df; if it is false an error will be thrown; if it is true a new unique name will be generated by adding a suffix\ncopycols : whether vectors passed as columns should be copied\n\nIf val is an AbstractRange then the result of collect(val) is inserted.\n\nIf df is a SubDataFrame then it must have been created with : as column selector (otherwise an error is thrown). In this case the copycols keyword argument is ignored (i.e. the added column is always copied) and the parent data frame's column is filled with missing in rows that are filtered out by df.\n\nIf df isa DataFrame that has no columns and only values other than AbstractVector are passed then it is used to create a one-element column. If df isa DataFrame that has no columns and at least one AbstractVector is passed then its length is used to determine the number of elements in all created columns. In all other cases the number of rows in all created columns must match nrow(df).\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nSee also insertcols!.\n\nExamples\n\njulia> df = DataFrame(a=1:3)\n3×1 DataFrame\n Row │ a\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> insertcols(df, 1, :b => 'a':'c')\n3×2 DataFrame\n Row │ b     a\n     │ Char  Int64\n─────┼─────────────\n   1 │ a         1\n   2 │ b         2\n   3 │ c         3\n\njulia> insertcols(df, :c => 2:4, :c => 3:5, makeunique=true)\n3×3 DataFrame\n Row │ a      c      c_1\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      3\n   2 │     2      3      4\n   3 │     3      4      5\n\njulia> insertcols(df, :a, :d => 7:9, after=true)\n3×2 DataFrame\n Row │ a      d\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      7\n   2 │     2      8\n   3 │     3      9\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.insertcols!","page":"Functions","title":"DataFrames.insertcols!","text":"insertcols!(df::AbstractDataFrame[, col], (name=>val)::Pair...;\n            after::Bool=false, makeunique::Bool=false, copycols::Bool=true)\n\nInsert a column into a data frame in place. Return the updated data frame.\n\nIf col is omitted it is set to ncol(df)+1 (the column is inserted as the last column).\n\nArguments\n\ndf : the data frame to which we want to add columns\ncol : a position at which we want to insert a column, passed as an integer or a column name (a string or a Symbol); the column selected with col and columns following it are shifted to the right in df after the operation\nname : the name of the new column\nval : an AbstractVector giving the contents of the new column or a value of any type other than AbstractArray which will be repeated to fill a new vector; As a particular rule a values stored in a Ref or a 0-dimensional AbstractArray are unwrapped and treated in the same way\nafter : if true columns are inserted after col\nmakeunique : defines what to do if name already exists in df; if it is false an error will be thrown; if it is true a new unique name will be generated by adding a suffix\ncopycols : whether vectors passed as columns should be copied\n\nIf val is an AbstractRange then the result of collect(val) is inserted.\n\nIf df is a SubDataFrame then it must have been created with : as column selector (otherwise an error is thrown). In this case the copycols keyword argument is ignored (i.e. the added column is always copied) and the parent data frame's column is filled with missing in rows that are filtered out by df.\n\nIf df isa DataFrame that has no columns and only values other than AbstractVector are passed then it is used to create a one-element column. If df isa DataFrame that has no columns and at least one AbstractVector is passed then its length is used to determine the number of elements in all created columns. In all other cases the number of rows in all created columns must match nrow(df).\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nMetadata having other styles is dropped (from parent data frame when df is a SubDataFrame).\n\nSee also insertcols.\n\nExamples\n\njulia> df = DataFrame(a=1:3)\n3×1 DataFrame\n Row │ a\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> insertcols!(df, 1, :b => 'a':'c')\n3×2 DataFrame\n Row │ b     a\n     │ Char  Int64\n─────┼─────────────\n   1 │ a         1\n   2 │ b         2\n   3 │ c         3\n\njulia> insertcols!(df, 2, :c => 2:4, :c => 3:5, makeunique=true)\n3×4 DataFrame\n Row │ b     c      c_1    a\n     │ Char  Int64  Int64  Int64\n─────┼───────────────────────────\n   1 │ a         2      3      1\n   2 │ b         3      4      2\n   3 │ c         4      5      3\n\njulia> insertcols!(df, :b, :d => 7:9, after=true)\n3×5 DataFrame\n Row │ b     d      c      c_1    a\n     │ Char  Int64  Int64  Int64  Int64\n─────┼──────────────────────────────────\n   1 │ a         7      2      3      1\n   2 │ b         8      3      4      2\n   3 │ c         9      4      5      3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.invpermute!","page":"Functions","title":"Base.invpermute!","text":"invpermute!(df::AbstractDataFrame, p)\n\nLike permute!, but the inverse of the given permutation is applied.\n\ninvpermute! will produce a correct result even if some columns of passed data frame or permutation p are identical (checked with ===). Otherwise, if two columns share some part of memory but are not identical (e.g. are different views of the same parent vector) then invpermute! result might be incorrect.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nMetadata having other styles is dropped (from parent data frame when df is a SubDataFrame).\n\nExamples\n\njulia> df = DataFrame(a=1:5, b=6:10, c=11:15)\n5×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      6     11\n   2 │     2      7     12\n   3 │     3      8     13\n   4 │     4      9     14\n   5 │     5     10     15\n\njulia> permute!(df, [5, 3, 1, 2, 4])\n5×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     5     10     15\n   2 │     3      8     13\n   3 │     1      6     11\n   4 │     2      7     12\n   5 │     4      9     14\n\njulia> invpermute!(df, [5, 3, 1, 2, 4])\n5×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      6     11\n   2 │     2      7     12\n   3 │     3      8     13\n   4 │     4      9     14\n   5 │     5     10     15\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.mapcols","page":"Functions","title":"DataFrames.mapcols","text":"mapcols(f::Union{Function, Type}, df::AbstractDataFrame; cols=All())\n\nReturn a DataFrame where each column of df selected by cols (by default, all columns) is transformed using function f. Columns not selected by cols are copied.\n\nf must return AbstractVector objects all with the same length or scalars (all values other than AbstractVector are considered to be a scalar).\n\nThe cols column selector can be any value accepted as column selector by the names function.\n\nNote that mapcols guarantees not to reuse the columns from df in the returned DataFrame. If f returns its argument then it gets copied before being stored.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> mapcols(x -> x.^2, df)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1    121\n   2 │     4    144\n   3 │     9    169\n   4 │    16    196\n\njulia> mapcols(x -> x.^2, df, cols=r\"y\")\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1    121\n   2 │     2    144\n   3 │     3    169\n   4 │     4    196\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.mapcols!","page":"Functions","title":"DataFrames.mapcols!","text":"mapcols!(f::Union{Function, Type}, df::DataFrame; cols=All())\n\nUpdate a DataFrame in-place where each column of df selected by cols (by default, all columns) is transformed using function f. Columns not selected by cols are left unchanged.\n\nf must return AbstractVector objects all with the same length or scalars (all values other than AbstractVector are considered to be a scalar).\n\nNote that mapcols! reuses the columns from df if they are returned by f.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> mapcols!(x -> x.^2, df);\n\njulia> df\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1    121\n   2 │     4    144\n   3 │     9    169\n   4 │    16    196\n\njulia> mapcols!(x -> 2 * x, df, cols=r\"x\");\n\njulia> df\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2    121\n   2 │     8    144\n   3 │    18    169\n   4 │    32    196\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.permute!","page":"Functions","title":"Base.permute!","text":"permute!(df::AbstractDataFrame, p)\n\nPermute data frame df in-place, according to permutation p. Throws ArgumentError if p is not a permutation.\n\nTo return a new data frame instead of permuting df in-place, use df[p, :].\n\npermute! will produce a correct result even if some columns of passed data frame or permutation p are identical (checked with ===). Otherwise, if two columns share some part of memory but are not identical (e.g. are different views of the same parent vector) then permute! result might be incorrect.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nMetadata having other styles is dropped (from parent data frame when df is a SubDataFrame).\n\nExamples\n\njulia> df = DataFrame(a=1:5, b=6:10, c=11:15)\n5×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      6     11\n   2 │     2      7     12\n   3 │     3      8     13\n   4 │     4      9     14\n   5 │     5     10     15\n\njulia> permute!(df, [5, 3, 1, 2, 4])\n5×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     5     10     15\n   2 │     3      8     13\n   3 │     1      6     11\n   4 │     2      7     12\n   5 │     4      9     14\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.prepend!","page":"Functions","title":"Base.prepend!","text":"prepend!(df::DataFrame, tables...; cols::Symbol=:setequal,\n         promote::Bool=(cols in [:union, :subset]))\n\nAdd the rows of tables passed as tables to the beginning of df. If the table is not an AbstractDataFrame then it is converted using DataFrame(table, copycols=false) before being appended.\n\nAdd the rows of df2 to the beginning of df. If the second argument table is not an AbstractDataFrame then it is converted using DataFrame(table, copycols=false) before being prepended.\n\nThe exact behavior of prepend! depends on the cols argument:\n\nIf cols == :setequal (this is the default) then df2 must contain exactly the same columns as df (but possibly in a different order).\nIf cols == :orderequal then df2 must contain the same columns in the same order (for AbstractDict this option requires that keys(row) matches propertynames(df) to allow for support of ordered dicts; however, if df2 is a Dict an error is thrown as it is an unordered collection).\nIf cols == :intersect then df2 may contain more columns than df, but all column names that are present in df must be present in df2 and only these are used.\nIf cols == :subset then append! behaves like for :intersect but if some column is missing in df2 then a missing value is pushed to df.\nIf cols == :union then append! adds columns missing in df that are present in df2, for columns present in df but missing in df2 a missing value is pushed.\n\nIf promote=true and element type of a column present in df does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in df. If promote=false an error is thrown.\n\nThe above rule has the following exceptions:\n\nIf df has no columns then copies of columns from df2 are added to it.\nIf df2 has no columns then calling prepend! leaves df unchanged.\n\nPlease note that prepend! must not be used on a DataFrame that contains columns that are aliases (equal when compared with ===).\n\nMetadata: table-level :note-style metadata and column-level :note-style metadata for columns present in df are preserved. If new columns are added their :note-style metadata is copied from the appended table. Other metadata is dropped.\n\nSee also: use pushfirst! to add individual rows at the beginning of a data frame, append! to add a table at the end, and vcat to vertically concatenate data frames.\n\nExamples\n\njulia> df1 = DataFrame(A=1:3, B=1:3)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n\njulia> df2 = DataFrame(A=4.0:6.0, B=4:6)\n3×2 DataFrame\n Row │ A        B\n     │ Float64  Int64\n─────┼────────────────\n   1 │     4.0      4\n   2 │     5.0      5\n   3 │     6.0      6\n\njulia> prepend!(df1, df2);\n\njulia> df1\n6×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     4      4\n   2 │     5      5\n   3 │     6      6\n   4 │     1      1\n   5 │     2      2\n   6 │     3      3\n\njulia> prepend!(df2, DataFrame(A=1), (; C=1:2), cols=:union)\n6×3 DataFrame\n Row │ A          B        C\n     │ Float64?   Int64?   Int64?\n─────┼─────────────────────────────\n   1 │       1.0  missing  missing\n   2 │ missing    missing        1\n   3 │ missing    missing        2\n   4 │       4.0        4  missing\n   5 │       5.0        5  missing\n   6 │       6.0        6  missing\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.push!","page":"Functions","title":"Base.push!","text":"push!(df::DataFrame, row::Union{Tuple, AbstractArray}...;\n      cols::Symbol=:setequal, promote::Bool=false)\npush!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict,\n                                Tables.AbstractRow}...;\n      cols::Symbol=:setequal, promote::Bool=(cols in [:union, :subset]))\n\nAdd one row at the end of df in-place, taking the values from row. Several rows can be added by passing them as separate arguments.\n\nColumn types of df are preserved, and new values are converted if necessary. An error is thrown if conversion fails.\n\nIf row is neither a DataFrameRow, NamedTuple nor AbstractDict then it must be a Tuple or an AbstractArray and columns are matched by order of appearance. In this case row must contain the same number of elements as the number of columns in df.\n\nIf row is a DataFrameRow, NamedTuple, AbstractDict, or Tables.AbstractRow then values in row are matched to columns in df based on names. The exact behavior depends on the cols argument value in the following way:\n\nIf cols == :setequal (this is the default) then row must contain exactly the same columns as df (but possibly in a different order).\nIf cols == :orderequal then row must contain the same columns in the same order (for AbstractDict this option requires that keys(row) matches propertynames(df) to allow for support of ordered dicts; however, if row is a Dict an error is thrown as it is an unordered collection).\nIf cols == :intersect then row may contain more columns than df, but all column names that are present in df must be present in row and only they are used to populate a new row in df.\nIf cols == :subset then the behavior is like for :intersect but if some column is missing in row then a missing value is pushed to df.\nIf cols == :union then columns missing in df that are present in row are added to df (using missing for existing rows) and a missing value is pushed to columns missing in row that are present in df.\n\nIf row is not a DataFrameRow, NamedTuple, AbstractDict, or Tables.AbstractRow the cols keyword argument must be :setequal (the default), because such rows do not provide column name information.\n\nIf promote=true and element type of a column present in df does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in df. If promote=false an error is thrown.\n\nAs a special case, if df has no columns and row is a NamedTuple, DataFrameRow, or Tables.AbstractRow, columns are created for all values in row, using their names and order.\n\nPlease note that this function must not be used on a DataFrame that contains columns that are aliases (equal when compared with ===).\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nSee also: pushfirst!, insert!\n\nExamples\n\njulia> df = DataFrame(A='a':'c', B=1:3)\n3×2 DataFrame\n Row │ A     B\n     │ Char  Int64\n─────┼─────────────\n   1 │ a         1\n   2 │ b         2\n   3 │ c         3\n\njulia> push!(df, (true, false), promote=true)\n4×2 DataFrame\n Row │ A     B\n     │ Any   Int64\n─────┼─────────────\n   1 │ a         1\n   2 │ b         2\n   3 │ c         3\n   4 │ true      0\n\njulia> push!(df, df[1, :])\n5×2 DataFrame\n Row │ A     B\n     │ Any   Int64\n─────┼─────────────\n   1 │ a         1\n   2 │ b         2\n   3 │ c         3\n   4 │ true      0\n   5 │ a         1\n\njulia> push!(df, (C=\"something\", A=11, B=12), cols=:intersect)\n6×2 DataFrame\n Row │ A     B\n     │ Any   Int64\n─────┼─────────────\n   1 │ a         1\n   2 │ b         2\n   3 │ c         3\n   4 │ true      0\n   5 │ a         1\n   6 │ 11       12\n\njulia> push!(df, Dict(:A=>1.0, :C=>1.0), cols=:union)\n7×3 DataFrame\n Row │ A     B        C\n     │ Any   Int64?   Float64?\n─────┼──────────────────────────\n   1 │ a           1  missing\n   2 │ b           2  missing\n   3 │ c           3  missing\n   4 │ true        0  missing\n   5 │ a           1  missing\n   6 │ 11         12  missing\n   7 │ 1.0   missing        1.0\n\njulia> push!(df, NamedTuple(), cols=:subset)\n8×3 DataFrame\n Row │ A        B        C\n     │ Any      Int64?   Float64?\n─────┼─────────────────────────────\n   1 │ a              1  missing\n   2 │ b              2  missing\n   3 │ c              3  missing\n   4 │ true           0  missing\n   5 │ a              1  missing\n   6 │ 11            12  missing\n   7 │ 1.0      missing        1.0\n   8 │ missing  missing  missing\n\njulia> push!(DataFrame(a=1, b=2), (3, 4), (5, 6))\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     3      4\n   3 │     5      6\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.pushfirst!","page":"Functions","title":"Base.pushfirst!","text":"pushfirst!(df::DataFrame, row::Union{Tuple, AbstractArray}...;\n           cols::Symbol=:setequal, promote::Bool=false)\npushfirst!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict,\n                                     Tables.AbstractRow}...;\n           cols::Symbol=:setequal, promote::Bool=(cols in [:union, :subset]))\n\nAdd one row at the beginning of df in-place, taking the values from row. Several rows can be added by passing them as separate arguments.\n\nColumn types of df are preserved, and new values are converted if necessary. An error is thrown if conversion fails.\n\nIf row is neither a DataFrameRow, NamedTuple nor AbstractDict then it must be a Tuple or an AbstractArray and columns are matched by order of appearance. In this case row must contain the same number of elements as the number of columns in df.\n\nIf row is a DataFrameRow, NamedTuple, AbstractDict, or Tables.AbstractRow then values in row are matched to columns in df based on names. The exact behavior depends on the cols argument value in the following way:\n\nIf cols == :setequal (this is the default) then row must contain exactly the same columns as df (but possibly in a different order).\nIf cols == :orderequal then row must contain the same columns in the same order (for AbstractDict this option requires that keys(row) matches propertynames(df) to allow for support of ordered dicts; however, if row is a Dict an error is thrown as it is an unordered collection).\nIf cols == :intersect then row may contain more columns than df, but all column names that are present in df must be present in row and only they are used to populate a new row in df.\nIf cols == :subset then the behavior is like for :intersect but if some column is missing in row then a missing value is pushed to df.\nIf cols == :union then columns missing in df that are present in row are added to df (using missing for existing rows) and a missing value is pushed to columns missing in row that are present in df.\n\nIf row is not a DataFrameRow, NamedTuple, AbstractDict, or Tables.AbstractRow the cols keyword argument must be :setequal (the default), because such rows do not provide column name information.\n\nIf promote=true and element type of a column present in df does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in df. If promote=false an error is thrown.\n\nAs a special case, if df has no columns and row is a NamedTuple, DataFrameRow, or Tables.AbstractRow, columns are created for all values in row, using their names and order.\n\nPlease note that this function must not be used on a DataFrame that contains columns that are aliases (equal when compared with ===).\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nSee also: push!, insert!\n\nExamples\n\njulia> df = DataFrame(A='a':'c', B=1:3)\n3×2 DataFrame\n Row │ A     B\n     │ Char  Int64\n─────┼─────────────\n   1 │ a         1\n   2 │ b         2\n   3 │ c         3\n\njulia> pushfirst!(df, (true, false), promote=true)\n4×2 DataFrame\n Row │ A     B\n     │ Any   Int64\n─────┼─────────────\n   1 │ true      0\n   2 │ a         1\n   3 │ b         2\n   4 │ c         3\n\njulia> pushfirst!(df, df[1, :])\n5×2 DataFrame\n Row │ A     B\n     │ Any   Int64\n─────┼─────────────\n   1 │ true      0\n   2 │ true      0\n   3 │ a         1\n   4 │ b         2\n   5 │ c         3\n\njulia> pushfirst!(df, (C=\"something\", A=11, B=12), cols=:intersect)\n6×2 DataFrame\n Row │ A     B\n     │ Any   Int64\n─────┼─────────────\n   1 │ 11       12\n   2 │ true      0\n   3 │ true      0\n   4 │ a         1\n   5 │ b         2\n   6 │ c         3\n\njulia> pushfirst!(df, Dict(:A=>1.0, :C=>1.0), cols=:union)\n7×3 DataFrame\n Row │ A     B        C\n     │ Any   Int64?   Float64?\n─────┼──────────────────────────\n   1 │ 1.0   missing        1.0\n   2 │ 11         12  missing\n   3 │ true        0  missing\n   4 │ true        0  missing\n   5 │ a           1  missing\n   6 │ b           2  missing\n   7 │ c           3  missing\n\njulia> pushfirst!(df, NamedTuple(), cols=:subset)\n8×3 DataFrame\n Row │ A        B        C\n     │ Any      Int64?   Float64?\n─────┼─────────────────────────────\n   1 │ missing  missing  missing\n   2 │ 1.0      missing        1.0\n   3 │ 11            12  missing\n   4 │ true           0  missing\n   5 │ true           0  missing\n   6 │ a              1  missing\n   7 │ b              2  missing\n   8 │ c              3  missing\n\njulia> pushfirst!(DataFrame(a=1, b=2), (3, 4), (5, 6))\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     3      4\n   2 │     5      6\n   3 │     1      2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.reduce","page":"Functions","title":"Base.reduce","text":"reduce(::typeof(vcat),\n       dfs::Union{AbstractVector{<:AbstractDataFrame},\n                  Tuple{AbstractDataFrame, Vararg{AbstractDataFrame}}};\n       cols::Union{Symbol, AbstractVector{Symbol},\n                   AbstractVector{<:AbstractString}}=:setequal,\n       source::Union{Nothing, Symbol, AbstractString,\n                     Pair{<:Union{Symbol, AbstractString}, <:AbstractVector}}=nothing,\n       init::AbstractDataFrame=DataFrame())\n\nEfficiently reduce the given vector or tuple of AbstractDataFrames with vcat.\n\nSee the vcat docstring for a description of keyword arguments cols and source.\n\nThe keyword argument init is the initial value to use in the reductions. It must be a data frame that has zero rows. It is not taken into account when computing the value of the source column nor when determining metadata of the produced data frame.\n\nThe column order, names, and types of the resulting DataFrame, and the behavior of cols and source keyword arguments follow the rules specified for vcat of AbstractDataFrames.\n\nMetadata: vcat propagates table-level :note-style metadata for keys that are present in all passed data frames and have the same value. vcat propagates column-level :note-style metadata for keys that are present in all passed data frames that contain this column and have the same value.\n\nExample\n\njulia> df1 = DataFrame(A=1:3, B=1:3)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n\njulia> df2 = DataFrame(A=4:6, B=4:6)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     4      4\n   2 │     5      5\n   3 │     6      6\n\njulia> df3 = DataFrame(A=7:9, C=7:9)\n3×2 DataFrame\n Row │ A      C\n     │ Int64  Int64\n─────┼──────────────\n   1 │     7      7\n   2 │     8      8\n   3 │     9      9\n\njulia> reduce(vcat, (df1, df2))\n6×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     4      4\n   5 │     5      5\n   6 │     6      6\n\njulia> reduce(vcat, [df1, df2, df3], cols=:union, source=:source)\n9×4 DataFrame\n Row │ A      B        C        source\n     │ Int64  Int64?   Int64?   Int64\n─────┼─────────────────────────────────\n   1 │     1        1  missing       1\n   2 │     2        2  missing       1\n   3 │     3        3  missing       1\n   4 │     4        4  missing       2\n   5 │     5        5  missing       2\n   6 │     6        6  missing       2\n   7 │     7  missing        7       3\n   8 │     8  missing        8       3\n   9 │     9  missing        9       3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.repeat","page":"Functions","title":"Base.repeat","text":"repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)\n\nConstruct a data frame by repeating rows in df. inner specifies how many times each row is repeated, and outer specifies how many times the full set of rows is repeated.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExample\n\njulia> df = DataFrame(a=1:2, b=3:4)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> repeat(df, inner=2, outer=3)\n12×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     1      3\n   3 │     2      4\n   4 │     2      4\n   5 │     1      3\n   6 │     1      3\n   7 │     2      4\n   8 │     2      4\n   9 │     1      3\n  10 │     1      3\n  11 │     2      4\n  12 │     2      4\n\n\n\n\n\nrepeat(df::AbstractDataFrame, count::Integer)\n\nConstruct a data frame by repeating each row in df the number of times specified by count.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExample\n\njulia> df = DataFrame(a=1:2, b=3:4)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> repeat(df, 2)\n4×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n   3 │     1      3\n   4 │     2      4\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.repeat!","page":"Functions","title":"DataFrames.repeat!","text":"repeat!(df::DataFrame; inner::Integer=1, outer::Integer=1)\n\nUpdate a data frame df in-place by repeating its rows. inner specifies how many times each row is repeated, and outer specifies how many times the full set of rows is repeated. Columns of df are freshly allocated.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExample\n\njulia> df = DataFrame(a=1:2, b=3:4)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> repeat!(df, inner=2, outer=3);\n\njulia> df\n12×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     1      3\n   3 │     2      4\n   4 │     2      4\n   5 │     1      3\n   6 │     1      3\n   7 │     2      4\n   8 │     2      4\n   9 │     1      3\n  10 │     1      3\n  11 │     2      4\n  12 │     2      4\n\n\n\n\n\nrepeat!(df::DataFrame, count::Integer)\n\nUpdate a data frame df in-place by repeating its rows the number of times specified by count. Columns of df are freshly allocated.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExample\n\njulia> df = DataFrame(a=1:2, b=3:4)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> repeat(df, 2)\n4×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n   3 │     1      3\n   4 │     2      4\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.reverse","page":"Functions","title":"Base.reverse","text":"reverse(df::AbstractDataFrame, start=1, stop=nrow(df))\n\nReturn a data frame containing the rows in df in reversed order. If start and stop are provided, only rows in the start:stop range are affected.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(a=1:5, b=6:10, c=11:15)\n5×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      6     11\n   2 │     2      7     12\n   3 │     3      8     13\n   4 │     4      9     14\n   5 │     5     10     15\n\njulia> reverse(df)\n5×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     5     10     15\n   2 │     4      9     14\n   3 │     3      8     13\n   4 │     2      7     12\n   5 │     1      6     11\n\njulia> reverse(df, 2, 3)\n5×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      6     11\n   2 │     3      8     13\n   3 │     2      7     12\n   4 │     4      9     14\n   5 │     5     10     15\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.reverse!","page":"Functions","title":"Base.reverse!","text":"reverse!(df::AbstractDataFrame, start=1, stop=nrow(df))\n\nMutate data frame in-place to reverse its row order. If start and stop are provided, only rows in the start:stop range are affected.\n\nreverse! will produce a correct result even if some columns of passed data frame are identical (checked with ===). Otherwise, if two columns share some part of memory but are not identical (e.g. are different views of the same parent vector) then reverse! result might be incorrect.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nMetadata having other styles is dropped (from parent data frame when df is a SubDataFrame).\n\nExamples\n\njulia> df = DataFrame(a=1:5, b=6:10, c=11:15)\n5×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      6     11\n   2 │     2      7     12\n   3 │     3      8     13\n   4 │     4      9     14\n   5 │     5     10     15\n\njulia> reverse!(df)\n5×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     5     10     15\n   2 │     4      9     14\n   3 │     3      8     13\n   4 │     2      7     12\n   5 │     1      6     11\n\njulia> reverse!(df, 2, 3)\n5×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     5     10     15\n   2 │     3      8     13\n   3 │     4      9     14\n   4 │     2      7     12\n   5 │     1      6     11\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.select","page":"Functions","title":"DataFrames.select","text":"select(df::AbstractDataFrame, args...;\n       copycols::Bool=true, renamecols::Bool=true, threads::Bool=true)\nselect(args::Callable, df::DataFrame;\n       renamecols::Bool=true, threads::Bool=true)\nselect(gd::GroupedDataFrame, args...;\n       copycols::Bool=true, keepkeys::Bool=true, ungroup::Bool=true,\n       renamecols::Bool=true, threads::Bool=true)\nselect(f::Base.Callable, gd::GroupedDataFrame;\n       copycols::Bool=true, keepkeys::Bool=true, ungroup::Bool=true,\n       renamecols::Bool=true, threads::Bool=true)\n\nCreate a new data frame that contains columns from df or gd specified by args and return it. The result is guaranteed to have the same number of rows as df, except when no columns are selected (in which case the result has zero rows).\n\nBelow detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.\n\nAll these operations are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.\n\nIn order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.\n\nOperations can then be applied on each group using one of the following functions:\n\ncombine: does not put restrictions on number of rows returned per group; the returned values are vertically concatenated following order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group; for GroupedDataFrame if grouping columns are kept they are put as first columns in the result;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select; for GroupedDataFrame if grouping columns are kept they are put as first columns in the result;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform; existing columns in the source data frame are put as first columns in the result;\n\nAs a special case, if a GroupedDataFrame that has zero groups is passed then the result of the operation is determined by performing a single call to the transformation function with a 0-row argument passed to it. The output of this operation is only used to identify the number and type of produced columns, but the result has zero rows.\n\nAll these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:\n\nstandard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns, which must be a single name (as a Symbol or a string), a vector of names or AsTable. Additionally it can be a Function which takes a string or a vector of strings as an argument containing names of columns selected by cols, and returns the target columns names (all accepted types except AsTable are allowed).\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\ncolumn-independent operations function => target_cols or just function for specific functions where the input columns are omitted; without target_cols the new column has the same name as function, otherwise it must be single name (as a Symbol or a string). Supported functions are:\nnrow to efficiently compute the number of rows in each group.\nproprow to efficiently compute the proportion of rows in each group.\neachindex to return a vector holding the number of each row within each group.\ngroupindices to return the group number.\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group if a GroupedDataFrame is processed, or with the data frame itself if an AbstractDataFrame is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)\n\nNote! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.\n\nNote! If cols or target_cols are one of All, Cols, Between, or Not, broadcasting using .=> is supported and is equivalent to broadcasting the result of names(df, cols) or names(df, target_cols). This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.\n\nAll functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).\n\nAs a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function. The documentation of DataFrames.table_transformation provides more information about this functionality, in particular covering performance considerations.\n\nWhat is allowed for function to return is determined by the target_cols value:\n\nIf both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, Tables.AbstractRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.\n\nIn all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.\n\nselect/select! and transform/transform! always return a data frame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).\n\nFor combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.\n\nIt is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.\n\nTo apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.\n\nIf a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nIn general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: :x1, [:x1, :x2], :x1 => :x2, :x1 => identity => :x2, or :x1 => (x -> @view x[inds]) (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the copycols keyword argument:\n\nif copycols=true then results of such transformations always perform a copy of the source column or its view;\nif copycols=false then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using ===, which excludes views of source columns) performs a copy;\n\nNote that performing transform! or select! assumes that copycols=false.\n\nIf df is a SubDataFrame and copycols=true then a DataFrame is returned and the same copying rules apply as for a DataFrame input: this means in particular that selected columns will be copied. If copycols=false, a SubDataFrame is returned without copying columns and in this case transforming or renaming columns is not allowed.\n\nIf a GroupedDataFrame is passed and threads=true (the default), a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions must therefore not modify global variables (i.e. they must be pure), use locks to control parallel accesses, or threads=false must be passed to disable multithreading. In the future, parallelism may be extended to other cases, so this requirement also holds for DataFrame inputs.\n\nIn order to improve the performance of the operations some transformations invoke optimized implementation, see DataFrames.table_transformation for details.\n\nKeyword arguments\n\ncopycols::Bool=true : whether columns of the source data frame should be copied if no transformation is applied to them.\nrenamecols::Bool=true : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.\nkeepkeys::Bool=true : whether grouping columns of gd should be kept in the returned data frame.\nungroup::Bool=true : whether the return value of the operation on gd should be a data frame or a GroupedDataFrame.\nthreads::Bool=true : whether transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to false if some transformations require serial execution or are not thread-safe.\n\nMetadata: this function propagates table-level :note-style metadata. Column-level :note-style metadata is propagated if: a) a single column is transformed to a single column and the name of the column   does not change (this includes all column selection operations), or b) a single column is transformed with identity or copy to a single column    even if column name is changed (this includes column renaming).    As a special case for GroupedDataFrame if the output has the same name    as a grouping column and keepkeys=true, metadata is taken from    original grouping column.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> select(df, 2)\n3×1 DataFrame\n Row │ b\n     │ Int64\n─────┼───────\n   1 │     4\n   2 │     5\n   3 │     6\n\njulia> select(df, :a => ByRow(sin) => :c, :b)\n3×2 DataFrame\n Row │ c         b\n     │ Float64   Int64\n─────┼─────────────────\n   1 │ 0.841471      4\n   2 │ 0.909297      5\n   3 │ 0.14112       6\n\njulia> select(df, :, [:a, :b] => (a, b) -> a .+ b .- sum(b)/length(b))\n3×3 DataFrame\n Row │ a      b      a_b_function\n     │ Int64  Int64  Float64\n─────┼────────────────────────────\n   1 │     1      4           0.0\n   2 │     2      5           2.0\n   3 │     3      6           4.0\n\njulia> select(df, All() .=> [minimum maximum])\n3×4 DataFrame\n Row │ a_minimum  b_minimum  a_maximum  b_maximum\n     │ Int64      Int64      Int64      Int64\n─────┼────────────────────────────────────────────\n   1 │         1          4          3          6\n   2 │         1          4          3          6\n   3 │         1          4          3          6\n\njulia> using Statistics\n\njulia> select(df, AsTable(:) => ByRow(mean), renamecols=false)\n3×1 DataFrame\n Row │ a_b\n     │ Float64\n─────┼─────────\n   1 │     2.5\n   2 │     3.5\n   3 │     4.5\n\njulia> select(df, AsTable(:) => ByRow(mean) => x -> join(x, \"_\"))\n3×1 DataFrame\n Row │ a_b\n     │ Float64\n─────┼─────────\n   1 │     2.5\n   2 │     3.5\n   3 │     4.5\n\njulia> select(first, df)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     1      4\n   3 │     1      4\n\njulia> df = DataFrame(a=1:3, b=4:6, c=7:9)\n3×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      4      7\n   2 │     2      5      8\n   3 │     3      6      9\n\njulia> select(df, AsTable(:) => ByRow(x -> (mean=mean(x), std=std(x))) => :stats,\n              AsTable(:) => ByRow(x -> (mean=mean(x), std=std(x))) => AsTable)\n3×3 DataFrame\n Row │ stats                    mean     std\n     │ NamedTup…                Float64  Float64\n─────┼───────────────────────────────────────────\n   1 │ (mean = 4.0, std = 3.0)      4.0      3.0\n   2 │ (mean = 5.0, std = 3.0)      5.0      3.0\n   3 │ (mean = 6.0, std = 3.0)      6.0      3.0\n\njulia> df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],\n                      b=repeat([2, 1], outer=[4]),\n                      c=1:8)\n8×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      1      2\n   3 │     1      2      3\n   4 │     2      1      4\n   5 │     2      2      5\n   6 │     1      1      6\n   7 │     1      2      7\n   8 │     2      1      8\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 2 groups based on key: a\nFirst Group (5 rows): a = 1\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      1      2\n   3 │     1      2      3\n   4 │     1      1      6\n   5 │     1      2      7\n⋮\nLast Group (3 rows): a = 2\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      1      4\n   2 │     2      2      5\n   3 │     2      1      8\n\nspecifying a name for target column\n\njulia> df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],\n                      b=repeat([2, 1], outer=[4]),\n                      c=1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> select(gd, :c => (x -> sum(log, x)) => :sum_log_c)\n8×2 DataFrame\n Row │ a      sum_log_c\n     │ Int64  Float64\n─────┼──────────────────\n   1 │     1    5.52943\n   2 │     1    5.52943\n   3 │     1    5.52943\n   4 │     2    5.07517\n   5 │     2    5.07517\n   6 │     1    5.52943\n   7 │     1    5.52943\n   8 │     2    5.07517\n\njulia> select(gd, [:b, :c] .=> sum) # passing a vector of pairs\n8×3 DataFrame\n Row │ a      b_sum  c_sum\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      8     19\n   2 │     1      8     19\n   3 │     1      8     19\n   4 │     2      4     17\n   5 │     2      4     17\n   6 │     1      8     19\n   7 │     1      8     19\n   8 │     2      4     17\n\nmultiple arguments, renaming and keepkeys\n\njulia> df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],\n                      b=repeat([2, 1], outer=[4]),\n                      c=1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> select(gd, :b => :b1, :c => :c1, [:b, :c] => +, keepkeys=false)\n8×3 DataFrame\n Row │ b1     c1     b_c_+\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      1      3\n   2 │     1      2      3\n   3 │     2      3      5\n   4 │     1      4      5\n   5 │     2      5      7\n   6 │     1      6      7\n   7 │     2      7      9\n   8 │     1      8      9\n\nbroadcasting and column expansion\n\njulia> df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],\n                      b=repeat([2, 1], outer=[4]),\n                      c=1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> select(gd, :b, AsTable([:b, :c]) => ByRow(extrema) => [:min, :max])\n8×4 DataFrame\n Row │ a      b      min    max\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      1      2\n   2 │     1      1      1      2\n   3 │     1      2      2      3\n   4 │     2      1      1      4\n   5 │     2      2      2      5\n   6 │     1      1      1      6\n   7 │     1      2      2      7\n   8 │     2      1      1      8\n\njulia> select(gd, :, AsTable(Not(:a)) => sum, renamecols=false)\n8×4 DataFrame\n Row │ a      b      c      b_c\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      1      3\n   2 │     1      1      2      3\n   3 │     1      2      3      5\n   4 │     2      1      4      5\n   5 │     2      2      5      7\n   6 │     1      1      6      7\n   7 │     1      2      7      9\n   8 │     2      1      8      9\n\ncolumn-independent operations\n\njulia> df = DataFrame(a=[1, 1, 1, 2, 2, 1, 1, 2],\n                      b=repeat([2, 1], outer=[4]),\n                      c=1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> select(gd, nrow, proprow, groupindices, eachindex)\n8×5 DataFrame\n Row │ a      nrow   proprow  groupindices  eachindex\n     │ Int64  Int64  Float64  Int64         Int64\n─────┼────────────────────────────────────────────────\n   1 │     1      5    0.625             1          1\n   2 │     1      5    0.625             1          2\n   3 │     1      5    0.625             1          3\n   4 │     2      3    0.375             2          1\n   5 │     2      3    0.375             2          2\n   6 │     1      5    0.625             1          4\n   7 │     1      5    0.625             1          5\n   8 │     2      3    0.375             2          3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.select!","page":"Functions","title":"DataFrames.select!","text":"select!(df::AbstractDataFrame, args...;\n        renamecols::Bool=true, threads::Bool=true)\nselect!(args::Base.Callable, df::DataFrame;\n        renamecols::Bool=true, threads::Bool=true)\nselect!(gd::GroupedDataFrame, args...; ungroup::Bool=true,\n        renamecols::Bool=true, threads::Bool=true)\nselect!(f::Base.Callable, gd::GroupedDataFrame; ungroup::Bool=true,\n        renamecols::Bool=true, threads::Bool=true)\n\nMutate df or gd in place to retain only columns or transformations specified by args... and return it. The result is guaranteed to have the same number of rows as df or parent of gd, except when no columns are selected (in which case the result has zero rows).\n\nIf a SubDataFrame or GroupedDataFrame{SubDataFrame} is passed, the parent data frame is updated using columns generated by args..., following the same rules as indexing:\n\nfor existing columns filtered-out rows are filled with values present in the old columns\nfor new columns (which is only allowed if SubDataFrame was created with : as column selector) filtered-out rows are filled with missing\ndropped columns (which are only allowed if SubDataFrame was created with : as column selector) are removed\nif SubDataFrame was not created with : as column selector then select! is only allowed if the transformations keep exactly the same sequence of column names as is in the passed df\n\nIf a GroupedDataFrame is passed then it is updated to reflect the new rows of its updated parent. If there are independent GroupedDataFrame objects constructed using the same parent data frame they might get corrupt.\n\nBelow detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.\n\nAll these operations are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.\n\nIn order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.\n\nOperations can then be applied on each group using one of the following functions:\n\ncombine: does not put restrictions on number of rows returned per group; the returned values are vertically concatenated following order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group; for GroupedDataFrame if grouping columns are kept they are put as first columns in the result;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select; for GroupedDataFrame if grouping columns are kept they are put as first columns in the result;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform; existing columns in the source data frame are put as first columns in the result;\n\nAs a special case, if a GroupedDataFrame that has zero groups is passed then the result of the operation is determined by performing a single call to the transformation function with a 0-row argument passed to it. The output of this operation is only used to identify the number and type of produced columns, but the result has zero rows.\n\nAll these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:\n\nstandard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns, which must be a single name (as a Symbol or a string), a vector of names or AsTable. Additionally it can be a Function which takes a string or a vector of strings as an argument containing names of columns selected by cols, and returns the target columns names (all accepted types except AsTable are allowed).\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\ncolumn-independent operations function => target_cols or just function for specific functions where the input columns are omitted; without target_cols the new column has the same name as function, otherwise it must be single name (as a Symbol or a string). Supported functions are:\nnrow to efficiently compute the number of rows in each group.\nproprow to efficiently compute the proportion of rows in each group.\neachindex to return a vector holding the number of each row within each group.\ngroupindices to return the group number.\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group if a GroupedDataFrame is processed, or with the data frame itself if an AbstractDataFrame is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)\n\nNote! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.\n\nNote! If cols or target_cols are one of All, Cols, Between, or Not, broadcasting using .=> is supported and is equivalent to broadcasting the result of names(df, cols) or names(df, target_cols). This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.\n\nAll functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).\n\nAs a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function. The documentation of DataFrames.table_transformation provides more information about this functionality, in particular covering performance considerations.\n\nWhat is allowed for function to return is determined by the target_cols value:\n\nIf both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, Tables.AbstractRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.\n\nIn all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.\n\nselect/select! and transform/transform! always return a data frame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).\n\nFor combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.\n\nIt is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.\n\nTo apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.\n\nIf a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nIn general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: :x1, [:x1, :x2], :x1 => :x2, :x1 => identity => :x2, or :x1 => (x -> @view x[inds]) (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the copycols keyword argument:\n\nif copycols=true then results of such transformations always perform a copy of the source column or its view;\nif copycols=false then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using ===, which excludes views of source columns) performs a copy;\n\nNote that performing transform! or select! assumes that copycols=false.\n\nIf df is a SubDataFrame and copycols=true then a DataFrame is returned and the same copying rules apply as for a DataFrame input: this means in particular that selected columns will be copied. If copycols=false, a SubDataFrame is returned without copying columns and in this case transforming or renaming columns is not allowed.\n\nIf a GroupedDataFrame is passed and threads=true (the default), a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions must therefore not modify global variables (i.e. they must be pure), use locks to control parallel accesses, or threads=false must be passed to disable multithreading. In the future, parallelism may be extended to other cases, so this requirement also holds for DataFrame inputs.\n\nIn order to improve the performance of the operations some transformations invoke optimized implementation, see DataFrames.table_transformation for details.\n\nKeyword arguments\n\nrenamecols::Bool=true : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.\nungroup::Bool=true : whether the return value of the operation on gd should be a data frame or a GroupedDataFrame.\nthreads::Bool=true : whether transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to false if some transformations require serial execution or are not thread-safe.\n\nMetadata: this function propagates table-level :note-style metadata. Column-level :note-style metadata is propagated if: a) a single column is transformed to a single column and the name of the column   does not change (this includes all column selection operations), or b) a single column is transformed with identity or copy to a single column    even if column name is changed (this includes column renaming).    As a special case for GroupedDataFrame if the output has the same name    as a grouping column and keepkeys=true, metadata is taken from    original grouping column.\n\nSee select for examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Random.shuffle","page":"Functions","title":"Random.shuffle","text":"shuffle([rng=GLOBAL_RNG,] df::AbstractDataFrame)\n\nReturn a copy of df with randomly permuted rows. The optional rng argument specifies a random number generator.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> using Random\n\njulia> rng = MersenneTwister(1234);\n\njulia> shuffle(rng, DataFrame(a=1:5, b=1:5))\n5×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      2\n   2 │     1      1\n   3 │     4      4\n   4 │     3      3\n   5 │     5      5\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Random.shuffle!","page":"Functions","title":"Random.shuffle!","text":"shuffle!([rng=GLOBAL_RNG,] df::AbstractDataFrame)\n\nRandomly permute rows of df in-place. The optional rng argument specifies a random number generator.\n\nshuffle! will produce a correct result even if some columns of passed data frame are identical (checked with ===). Otherwise, if two columns share some part of memory but are not identical (e.g. are different views of the same parent vector) then shuffle! result might be incorrect.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nMetadata having other styles is dropped (from parent data frame when df is a SubDataFrame).\n\nExamples\n\njulia> using Random\n\njulia> rng = MersenneTwister(1234);\n\njulia> shuffle!(rng, DataFrame(a=1:5, b=1:5))\n5×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      2\n   2 │     1      1\n   3 │     4      4\n   4 │     3      3\n   5 │     5      5\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.table_transformation","page":"Functions","title":"DataFrames.table_transformation","text":"table_transformation(df_sel::AbstractDataFrame, fun)\n\nThis is the function called when AsTable(...) => fun is requested. The df_sel argument is a data frame storing columns selected by the AsTable(...) selector.\n\nBy default it calls default_table_transformation. However, it is allowed to add special methods for specific types of fun, as long as the result matches what would be produced by default_table_transformation, except that it is allowed to perform eltype conversion of the resulting vectors or value type promotions that are consistent with promote_type.\n\nIt is guaranteed that df_sel has at least one column.\n\nThe main use of special table_transformation methods is to provide more efficient than the default implementations of requested fun transformation.\n\nThis function might become a part of the public API of DataFrames.jl in the future, currently it should be considered experimental.\n\nFast paths are implemented within DataFrames.jl for the following functions fun:\n\nsum, ByRow(sum), ByRow(sum∘skipmissing)\nlength, ByRow(length), ByRow(length∘skipmissing)\nmean, ByRow(mean), ByRow(mean∘skipmissing)\nByRow(var), ByRow(var∘skipmissing)\nByRow(std), ByRow(std∘skipmissing)\nByRow(median), ByRow(median∘skipmissing)\nminimum, ByRow(minimum), ByRow(minimum∘skipmissing)\nmaximum, ByRow(maximum), ByRow(maximum∘skipmissing)\nfun∘collect and ByRow(fun∘collect) where fun is any function\n\nNote that in order to improve the performance ByRow(sum), ByRow(sum∘skipmissing), ByRow(mean), and ByRow(mean∘skipmissing) perform all operations in the target element type. In some very rare cases (like mixing very large Int64 values and Float64 values) it can lead to a result different from the one that would be obtained by calling the function outside of DataFrames.jl. The way to avoid this precision loss is to use an anonymous function, e.g. instead of ByRow(sum) use ByRow(x -> sum(x)). However, in general for such scenarios even standard aggregation functions should not be considered to provide reliable output, and users are recommended to switch to higher precision calculations. An example of a case when standard sum is affected by the situation discussed is:\n\njulia> sum(Any[typemax(Int), typemax(Int), 1.0])\n-1.0\n\njulia> sum(Any[1.0, typemax(Int), typemax(Int)])\n1.8446744073709552e19\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.transform","page":"Functions","title":"DataFrames.transform","text":"transform(df::AbstractDataFrame, args...;\n          copycols::Bool=true, renamecols::Bool=true, threads::Bool=true)\ntransform(f::Callable, df::DataFrame;\n          renamecols::Bool=true, threads::Bool=true)\ntransform(gd::GroupedDataFrame, args...;\n          copycols::Bool=true, keepkeys::Bool=true, ungroup::Bool=true,\n          renamecols::Bool=true, threads::Bool=true)\ntransform(f::Base.Callable, gd::GroupedDataFrame;\n          copycols::Bool=true, keepkeys::Bool=true, ungroup::Bool=true,\n          renamecols::Bool=true, threads::Bool=true)\n\nCreate a new data frame that contains columns from df or gd plus columns specified by args and return it. The result is guaranteed to have the same number of rows as df. Equivalent to select(df, :, args...) or select(gd, :, args...).\n\nBelow detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.\n\nAll these operations are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.\n\nIn order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.\n\nOperations can then be applied on each group using one of the following functions:\n\ncombine: does not put restrictions on number of rows returned per group; the returned values are vertically concatenated following order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group; for GroupedDataFrame if grouping columns are kept they are put as first columns in the result;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select; for GroupedDataFrame if grouping columns are kept they are put as first columns in the result;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform; existing columns in the source data frame are put as first columns in the result;\n\nAs a special case, if a GroupedDataFrame that has zero groups is passed then the result of the operation is determined by performing a single call to the transformation function with a 0-row argument passed to it. The output of this operation is only used to identify the number and type of produced columns, but the result has zero rows.\n\nAll these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:\n\nstandard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns, which must be a single name (as a Symbol or a string), a vector of names or AsTable. Additionally it can be a Function which takes a string or a vector of strings as an argument containing names of columns selected by cols, and returns the target columns names (all accepted types except AsTable are allowed).\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\ncolumn-independent operations function => target_cols or just function for specific functions where the input columns are omitted; without target_cols the new column has the same name as function, otherwise it must be single name (as a Symbol or a string). Supported functions are:\nnrow to efficiently compute the number of rows in each group.\nproprow to efficiently compute the proportion of rows in each group.\neachindex to return a vector holding the number of each row within each group.\ngroupindices to return the group number.\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group if a GroupedDataFrame is processed, or with the data frame itself if an AbstractDataFrame is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)\n\nNote! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.\n\nNote! If cols or target_cols are one of All, Cols, Between, or Not, broadcasting using .=> is supported and is equivalent to broadcasting the result of names(df, cols) or names(df, target_cols). This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.\n\nAll functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).\n\nAs a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function. The documentation of DataFrames.table_transformation provides more information about this functionality, in particular covering performance considerations.\n\nWhat is allowed for function to return is determined by the target_cols value:\n\nIf both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, Tables.AbstractRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.\n\nIn all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.\n\nselect/select! and transform/transform! always return a data frame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).\n\nFor combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.\n\nIt is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.\n\nTo apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.\n\nIf a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nIn general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: :x1, [:x1, :x2], :x1 => :x2, :x1 => identity => :x2, or :x1 => (x -> @view x[inds]) (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the copycols keyword argument:\n\nif copycols=true then results of such transformations always perform a copy of the source column or its view;\nif copycols=false then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using ===, which excludes views of source columns) performs a copy;\n\nNote that performing transform! or select! assumes that copycols=false.\n\nIf df is a SubDataFrame and copycols=true then a DataFrame is returned and the same copying rules apply as for a DataFrame input: this means in particular that selected columns will be copied. If copycols=false, a SubDataFrame is returned without copying columns and in this case transforming or renaming columns is not allowed.\n\nIf a GroupedDataFrame is passed and threads=true (the default), a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions must therefore not modify global variables (i.e. they must be pure), use locks to control parallel accesses, or threads=false must be passed to disable multithreading. In the future, parallelism may be extended to other cases, so this requirement also holds for DataFrame inputs.\n\nIn order to improve the performance of the operations some transformations invoke optimized implementation, see DataFrames.table_transformation for details.\n\nKeyword arguments\n\ncopycols::Bool=true : whether columns of the source data frame should be copied if no transformation is applied to them.\nrenamecols::Bool=true : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.\nkeepkeys::Bool=true : whether grouping columns of gd should be kept in the returned data frame.\nungroup::Bool=true : whether the return value of the operation on gd should be a data frame or a GroupedDataFrame.\nthreads::Bool=true : whether transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to false if some transformations require serial execution or are not thread-safe.\n\nNote that when the first argument is a GroupedDataFrame, keepkeys=false is needed to be able to return a different value for the grouping column:\n\nMetadata: this function propagates table-level :note-style metadata. Column-level :note-style metadata is propagated if: a) a single column is transformed to a single column and the name of the column   does not change (this includes all column selection operations), or b) a single column is transformed with identity or copy to a single column    even if column name is changed (this includes column renaming).    As a special case for GroupedDataFrame if the output has the same name    as a grouping column and keepkeys=true, metadata is taken from    original grouping column.\n\nExamples\n\njulia> gdf = groupby(DataFrame(x=1:2), :x)\nGroupedDataFrame with 2 groups based on key: x\nFirst Group (1 row): x = 1\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     1\n⋮\nLast Group (1 row): x = 2\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     2\n\njulia> transform(gdf, x -> (x=10,), keepkeys=false)\n2×1 DataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │    10\n   2 │    10\n\njulia> transform(gdf, x -> (x=10,), keepkeys=true)\nERROR: ArgumentError: column :x in returned data frame is not equal to grouping key :x\n\nSee select for more examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.transform!","page":"Functions","title":"DataFrames.transform!","text":"transform!(df::AbstractDataFrame, args...;\n           renamecols::Bool=true, threads::Bool=true)\ntransform!(args::Callable, df::AbstractDataFrame;\n           renamecols::Bool=true, threads::Bool=true)\ntransform!(gd::GroupedDataFrame, args...;\n           ungroup::Bool=true, renamecols::Bool=true, threads::Bool=true)\ntransform!(f::Base.Callable, gd::GroupedDataFrame;\n           ungroup::Bool=true, renamecols::Bool=true, threads::Bool=true)\n\nMutate df or gd in place to add columns specified by args... and return it. The result is guaranteed to have the same number of rows as df. Equivalent to select!(df, :, args...) or select!(gd, :, args...), except that column renaming performs a copy.\n\nBelow detailed common rules for all transformation functions supported by DataFrames.jl are explained and compared.\n\nAll these operations are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.\n\nIn order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.\n\nOperations can then be applied on each group using one of the following functions:\n\ncombine: does not put restrictions on number of rows returned per group; the returned values are vertically concatenated following order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group; for GroupedDataFrame if grouping columns are kept they are put as first columns in the result;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select; for GroupedDataFrame if grouping columns are kept they are put as first columns in the result;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform; existing columns in the source data frame are put as first columns in the result;\n\nAs a special case, if a GroupedDataFrame that has zero groups is passed then the result of the operation is determined by performing a single call to the transformation function with a 0-row argument passed to it. The output of this operation is only used to identify the number and type of produced columns, but the result has zero rows.\n\nAll these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:\n\nstandard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns, which must be a single name (as a Symbol or a string), a vector of names or AsTable. Additionally it can be a Function which takes a string or a vector of strings as an argument containing names of columns selected by cols, and returns the target columns names (all accepted types except AsTable are allowed).\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\ncolumn-independent operations function => target_cols or just function for specific functions where the input columns are omitted; without target_cols the new column has the same name as function, otherwise it must be single name (as a Symbol or a string). Supported functions are:\nnrow to efficiently compute the number of rows in each group.\nproprow to efficiently compute the proportion of rows in each group.\neachindex to return a vector holding the number of each row within each group.\ngroupindices to return the group number.\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group if a GroupedDataFrame is processed, or with the data frame itself if an AbstractDataFrame is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)\n\nNote! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.\n\nNote! If cols or target_cols are one of All, Cols, Between, or Not, broadcasting using .=> is supported and is equivalent to broadcasting the result of names(df, cols) or names(df, target_cols). This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.\n\nAll functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).\n\nAs a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function. The documentation of DataFrames.table_transformation provides more information about this functionality, in particular covering performance considerations.\n\nWhat is allowed for function to return is determined by the target_cols value:\n\nIf both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, Tables.AbstractRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.\n\nIn all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.\n\nselect/select! and transform/transform! always return a data frame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).\n\nFor combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.\n\nIt is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.\n\nTo apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.\n\nIf a collection of column names is passed then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nIn general columns returned by transformations are stored in the target data frame without copying. An exception to this rule is when columns from the source data frame are reused in the target data frame. This can happen via expressions like: :x1, [:x1, :x2], :x1 => :x2, :x1 => identity => :x2, or :x1 => (x -> @view x[inds]) (note that in the last case the source column is reused indirectly via a view). In such cases the behavior depends on the value of the copycols keyword argument:\n\nif copycols=true then results of such transformations always perform a copy of the source column or its view;\nif copycols=false then copies are only performed to avoid storing the same column several times in the target data frame; more precisely, no copy is made the first time a column is used, but each subsequent reuse of a source column (when compared using ===, which excludes views of source columns) performs a copy;\n\nNote that performing transform! or select! assumes that copycols=false.\n\nIf df is a SubDataFrame and copycols=true then a DataFrame is returned and the same copying rules apply as for a DataFrame input: this means in particular that selected columns will be copied. If copycols=false, a SubDataFrame is returned without copying columns and in this case transforming or renaming columns is not allowed.\n\nIf a GroupedDataFrame is passed and threads=true (the default), a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions must therefore not modify global variables (i.e. they must be pure), use locks to control parallel accesses, or threads=false must be passed to disable multithreading. In the future, parallelism may be extended to other cases, so this requirement also holds for DataFrame inputs.\n\nIn order to improve the performance of the operations some transformations invoke optimized implementation, see DataFrames.table_transformation for details.\n\nKeyword arguments\n\nrenamecols::Bool=true : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.\nungroup::Bool=true : whether the return value of the operation on gd should be a data frame or a GroupedDataFrame.\nthreads::Bool=true : whether transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to false if some transformations require serial execution or are not thread-safe.\n\nMetadata: this function propagates table-level :note-style metadata. Column-level :note-style metadata is propagated if: a) a single column is transformed to a single column and the name of the column   does not change (this includes all column selection operations), or b) a single column is transformed with identity or copy to a single column    even if column name is changed (this includes column renaming).    As a special case for GroupedDataFrame if the output has the same name    as a grouping column and keepkeys=true, metadata is taken from    original grouping column.\n\nSee select for examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.vcat","page":"Functions","title":"Base.vcat","text":"vcat(dfs::AbstractDataFrame...;\n     cols::Union{Symbol, AbstractVector{Symbol},\n                 AbstractVector{<:AbstractString}}=:setequal,\n     source::Union{Nothing, Symbol, AbstractString,\n                   Pair{<:Union{Symbol, AbstractString}, <:AbstractVector}}=nothing)\n\nVertically concatenate AbstractDataFrames.\n\nThe cols keyword argument determines the columns of the returned data frame:\n\n:setequal: require all data frames to have the same column names disregarding order. If they appear in different orders, the order of the first provided data frame is used.\n:orderequal: require all data frames to have the same column names and in the same order.\n:intersect: only the columns present in all provided data frames are kept. If the intersection is empty, an empty data frame is returned.\n:union: columns present in at least one of the provided data frames are kept. Columns not present in some data frames are filled with missing where necessary.\nA vector of Symbols or strings: only listed columns are kept. Columns not present in some data frames are filled with missing where necessary.\n\nThe source keyword argument, if not nothing (the default), specifies the additional column to be added in the last position in the resulting data frame that will identify the source data frame. It can be a Symbol or an AbstractString, in which case the identifier will be the number of the passed source data frame, or a Pair consisting of a Symbol or an AbstractString and of a vector specifying the data frame identifiers (which do not have to be unique). The name of the source column is not allowed to be present in any source data frame.\n\nThe order of columns is determined by the order they appear in the included data frames, searching through the header of the first data frame, then the second, etc.\n\nThe element types of columns are determined using promote_type, as with vcat for AbstractVectors.\n\nvcat ignores empty data frames when composing the result (except for metadata), making it possible to initialize an empty data frame at the beginning of a loop and vcat onto it.\n\nMetadata: vcat propagates table-level :note-style metadata for keys that are present in all passed data frames and have the same value. vcat propagates column-level :note-style metadata for keys that are present in all passed data frames that contain this column and have the same value.\n\nExample\n\njulia> df1 = DataFrame(A=1:3, B=1:3)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n\njulia> df2 = DataFrame(A=4:6, B=4:6)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     4      4\n   2 │     5      5\n   3 │     6      6\n\njulia> df3 = DataFrame(A=7:9, C=7:9)\n3×2 DataFrame\n Row │ A      C\n     │ Int64  Int64\n─────┼──────────────\n   1 │     7      7\n   2 │     8      8\n   3 │     9      9\n\njulia> df4 = DataFrame()\n0×0 DataFrame\n\njulia> vcat(df1, df2)\n6×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     4      4\n   5 │     5      5\n   6 │     6      6\n\njulia> vcat(df1, df3, cols=:union)\n6×3 DataFrame\n Row │ A      B        C\n     │ Int64  Int64?   Int64?\n─────┼─────────────────────────\n   1 │     1        1  missing\n   2 │     2        2  missing\n   3 │     3        3  missing\n   4 │     7  missing        7\n   5 │     8  missing        8\n   6 │     9  missing        9\n\njulia> vcat(df1, df3, cols=:intersect)\n6×1 DataFrame\n Row │ A\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n   4 │     7\n   5 │     8\n   6 │     9\n\njulia> vcat(df4, df1)\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n\njulia> vcat(df1, df2, df3, df4, cols=:union, source=\"source\")\n9×4 DataFrame\n Row │ A      B        C        source\n     │ Int64  Int64?   Int64?   Int64\n─────┼─────────────────────────────────\n   1 │     1        1  missing       1\n   2 │     2        2  missing       1\n   3 │     3        3  missing       1\n   4 │     4        4  missing       2\n   5 │     5        5  missing       2\n   6 │     6        6  missing       2\n   7 │     7  missing        7       3\n   8 │     8  missing        8       3\n   9 │     9  missing        9       3\n\njulia> vcat(df1, df2, df4, df3, cols=:union, source=:source => 'a':'d')\n9×4 DataFrame\n Row │ A      B        C        source\n     │ Int64  Int64?   Int64?   Char\n─────┼─────────────────────────────────\n   1 │     1        1  missing  a\n   2 │     2        2  missing  a\n   3 │     3        3  missing  a\n   4 │     4        4  missing  b\n   5 │     5        5  missing  b\n   6 │     6        6  missing  b\n   7 │     7  missing        7  d\n   8 │     8  missing        8  d\n   9 │     9  missing        9  d\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Reshaping-data-frames-between-tall-and-wide-formats","page":"Functions","title":"Reshaping data frames between tall and wide formats","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"stack\nunstack\npermutedims","category":"page"},{"location":"lib/functions/#Base.stack","page":"Functions","title":"Base.stack","text":"stack(df::AbstractDataFrame[, measure_vars[, id_vars] ];\n      variable_name=:variable, value_name=:value,\n      view::Bool=false, variable_eltype::Type=String)\n\nStack a data frame df, i.e. convert it from wide to long format.\n\nReturn the long-format DataFrame with: columns for each of the id_vars, column value_name (:value by default) holding the values of the stacked columns (measure_vars), and column variable_name (:variable by default) a vector holding the name of the corresponding measure_vars variable.\n\nIf view=true then return a stacked view of a data frame (long format). The result is a view because the columns are special AbstractVectors that return views into the original data frame.\n\nArguments\n\ndf : the AbstractDataFrame to be stacked\nmeasure_vars : the columns to be stacked (the measurement variables), as a column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). If neither measure_vars or id_vars are given, measure_vars defaults to all floating point columns.\nid_vars : the identifier columns that are repeated during stacking, as a column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). Defaults to all variables that are not measure_vars\nvariable_name : the name (Symbol or string) of the new stacked column that shall hold the names of each of measure_vars\nvalue_name : the name (Symbol or string) of the new stacked column containing the values from each of measure_vars\nview : whether the stacked data frame should be a view rather than contain freshly allocated vectors.\nvariable_eltype : determines the element type of column variable_name. By default a PooledArray{String} is created. If variable_eltype=Symbol a PooledVector{Symbol} is created, and if variable_eltype=CategoricalValue{String} a CategoricalArray{String} is produced (call using CategoricalArrays first if needed) Passing any other type T will produce a PooledVector{T} column as long as it supports conversion from String. When view=true, a RepeatedVector{T} is produced.\n\nMetadata: table-level :note-style metadata and column-level :note-style metadata for identifier columns are preserved.\n\nExamples\n\njulia> df = DataFrame(a=repeat(1:3, inner=2),\n                      b=repeat(1:2, inner=3),\n                      c=repeat(1:1, inner=6),\n                      d=repeat(1:6, inner=1),\n                      e=string.('a':'f'))\n6×5 DataFrame\n Row │ a      b      c      d      e\n     │ Int64  Int64  Int64  Int64  String\n─────┼────────────────────────────────────\n   1 │     1      1      1      1  a\n   2 │     1      1      1      2  b\n   3 │     2      1      1      3  c\n   4 │     2      2      1      4  d\n   5 │     3      2      1      5  e\n   6 │     3      2      1      6  f\n\njulia> stack(df, [:c, :d])\n12×5 DataFrame\n Row │ a      b      e       variable  value\n     │ Int64  Int64  String  String    Int64\n─────┼───────────────────────────────────────\n   1 │     1      1  a       c             1\n   2 │     1      1  b       c             1\n   3 │     2      1  c       c             1\n   4 │     2      2  d       c             1\n   5 │     3      2  e       c             1\n   6 │     3      2  f       c             1\n   7 │     1      1  a       d             1\n   8 │     1      1  b       d             2\n   9 │     2      1  c       d             3\n  10 │     2      2  d       d             4\n  11 │     3      2  e       d             5\n  12 │     3      2  f       d             6\n\njulia> stack(df, [:c, :d], [:a])\n12×3 DataFrame\n Row │ a      variable  value\n     │ Int64  String    Int64\n─────┼────────────────────────\n   1 │     1  c             1\n   2 │     1  c             1\n   3 │     2  c             1\n   4 │     2  c             1\n   5 │     3  c             1\n   6 │     3  c             1\n   7 │     1  d             1\n   8 │     1  d             2\n   9 │     2  d             3\n  10 │     2  d             4\n  11 │     3  d             5\n  12 │     3  d             6\n\njulia> stack(df, Not([:a, :b, :e]))\n12×5 DataFrame\n Row │ a      b      e       variable  value\n     │ Int64  Int64  String  String    Int64\n─────┼───────────────────────────────────────\n   1 │     1      1  a       c             1\n   2 │     1      1  b       c             1\n   3 │     2      1  c       c             1\n   4 │     2      2  d       c             1\n   5 │     3      2  e       c             1\n   6 │     3      2  f       c             1\n   7 │     1      1  a       d             1\n   8 │     1      1  b       d             2\n   9 │     2      1  c       d             3\n  10 │     2      2  d       d             4\n  11 │     3      2  e       d             5\n  12 │     3      2  f       d             6\n\njulia> stack(df, Not([:a, :b, :e]), variable_name=:somemeasure)\n12×5 DataFrame\n Row │ a      b      e       somemeasure  value\n     │ Int64  Int64  String  String       Int64\n─────┼──────────────────────────────────────────\n   1 │     1      1  a       c                1\n   2 │     1      1  b       c                1\n   3 │     2      1  c       c                1\n   4 │     2      2  d       c                1\n   5 │     3      2  e       c                1\n   6 │     3      2  f       c                1\n   7 │     1      1  a       d                1\n   8 │     1      1  b       d                2\n   9 │     2      1  c       d                3\n  10 │     2      2  d       d                4\n  11 │     3      2  e       d                5\n  12 │     3      2  f       d                6\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.unstack","page":"Functions","title":"DataFrames.unstack","text":"unstack(df::AbstractDataFrame, rowkeys, colkey, value;\n        renamecols::Function=identity, allowmissing::Bool=false,\n        combine=only, fill=missing, threads::Bool=true)\nunstack(df::AbstractDataFrame, colkey, value;\n        renamecols::Function=identity, allowmissing::Bool=false,\n        combine=only, fill=missing, threads::Bool=true)\nunstack(df::AbstractDataFrame;\n        renamecols::Function=identity, allowmissing::Bool=false,\n        combine=only, fill=missing, threads::Bool=true)\n\nUnstack data frame df, i.e. convert it from long to wide format.\n\nRow and column keys are ordered in the order of their first appearance.\n\nPositional arguments\n\ndf : the AbstractDataFrame to be unstacked\nrowkeys : the columns with a unique key for each row, if not given, find a key by grouping on anything not a colkey or value. Can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). If rowkeys contains no columns all rows are assumed to have the same key.\ncolkey : the column (Symbol, string or integer) holding the column names in wide format, defaults to :variable\nvalues : the column storing values (Symbol, string or integer), defaults to :value\n\nKeyword arguments\n\nrenamecols: a function called on each unique value in colkey; it must return the name of the column to be created (typically as a string or a Symbol). Duplicates in resulting names when converted to Symbol are not allowed. By default no transformation is performed.\nallowmissing: if false (the default) then an error is thrown if colkey contains missing values; if true then a column referring to missing value is created.\ncombine: if only (the default) then an error is thrown if combination of rowkeys and colkey contains duplicate entries. Otherwise the passed value must be a function that is called on a vector view containing all elements for each combination of rowkeys and colkey present in the data.\nfill: missing row/column combinations are filled with this value. The default is missing. If the value column is a CategoricalVector and fill is not missing then in order to keep unstacked value columns also CategoricalVector the fill must be passed as CategoricalValue\nthreads: whether combine function may be run in separate tasks which can execute in parallel (possibly being applied to multiple groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to false if combine requires serial execution or is not thread-safe.\n\nMetadata: table-level :note-style metadata and column-level :note-style metadata for row keys columns are preserved.\n\nDeprecations\n\nallowduplicates keyword argument is deprecated; instead use combine keyword argument; an equivalent to allowduplicates=true is combine=last and to allowduplicates=false is combine=only (the default);\n\nExamples\n\njulia> wide = DataFrame(id=1:6,\n                        a=repeat(1:3, inner=2),\n                        b=repeat(1.0:2.0, inner=3),\n                        c=repeat(1.0:1.0, inner=6),\n                        d=repeat(1.0:3.0, inner=2))\n6×5 DataFrame\n Row │ id     a      b        c        d\n     │ Int64  Int64  Float64  Float64  Float64\n─────┼─────────────────────────────────────────\n   1 │     1      1      1.0      1.0      1.0\n   2 │     2      1      1.0      1.0      1.0\n   3 │     3      2      1.0      1.0      2.0\n   4 │     4      2      2.0      1.0      2.0\n   5 │     5      3      2.0      1.0      3.0\n   6 │     6      3      2.0      1.0      3.0\n\njulia> long = stack(wide)\n18×4 DataFrame\n Row │ id     a      variable  value\n     │ Int64  Int64  String    Float64\n─────┼─────────────────────────────────\n   1 │     1      1  b             1.0\n   2 │     2      1  b             1.0\n   3 │     3      2  b             1.0\n   4 │     4      2  b             2.0\n   5 │     5      3  b             2.0\n   6 │     6      3  b             2.0\n   7 │     1      1  c             1.0\n   8 │     2      1  c             1.0\n  ⋮  │   ⋮      ⋮       ⋮         ⋮\n  12 │     6      3  c             1.0\n  13 │     1      1  d             1.0\n  14 │     2      1  d             1.0\n  15 │     3      2  d             2.0\n  16 │     4      2  d             2.0\n  17 │     5      3  d             3.0\n  18 │     6      3  d             3.0\n                         3 rows omitted\n\njulia> unstack(long)\n6×5 DataFrame\n Row │ id     a      b         c         d\n     │ Int64  Int64  Float64?  Float64?  Float64?\n─────┼────────────────────────────────────────────\n   1 │     1      1       1.0       1.0       1.0\n   2 │     2      1       1.0       1.0       1.0\n   3 │     3      2       1.0       1.0       2.0\n   4 │     4      2       2.0       1.0       2.0\n   5 │     5      3       2.0       1.0       3.0\n   6 │     6      3       2.0       1.0       3.0\n\njulia> unstack(long, :variable, :value)\n6×5 DataFrame\n Row │ id     a      b         c         d\n     │ Int64  Int64  Float64?  Float64?  Float64?\n─────┼────────────────────────────────────────────\n   1 │     1      1       1.0       1.0       1.0\n   2 │     2      1       1.0       1.0       1.0\n   3 │     3      2       1.0       1.0       2.0\n   4 │     4      2       2.0       1.0       2.0\n   5 │     5      3       2.0       1.0       3.0\n   6 │     6      3       2.0       1.0       3.0\n\njulia> unstack(long, :id, :variable, :value)\n6×4 DataFrame\n Row │ id     b         c         d\n     │ Int64  Float64?  Float64?  Float64?\n─────┼─────────────────────────────────────\n   1 │     1       1.0       1.0       1.0\n   2 │     2       1.0       1.0       1.0\n   3 │     3       1.0       1.0       2.0\n   4 │     4       2.0       1.0       2.0\n   5 │     5       2.0       1.0       3.0\n   6 │     6       2.0       1.0       3.0\n\njulia> unstack(long, [:id, :a], :variable, :value)\n6×5 DataFrame\n Row │ id     a      b         c         d\n     │ Int64  Int64  Float64?  Float64?  Float64?\n─────┼────────────────────────────────────────────\n   1 │     1      1       1.0       1.0       1.0\n   2 │     2      1       1.0       1.0       1.0\n   3 │     3      2       1.0       1.0       2.0\n   4 │     4      2       2.0       1.0       2.0\n   5 │     5      3       2.0       1.0       3.0\n   6 │     6      3       2.0       1.0       3.0\n\njulia> unstack(long, :id, :variable, :value, renamecols=x->Symbol(:_, x))\n6×4 DataFrame\n Row │ id     _b        _c        _d\n     │ Int64  Float64?  Float64?  Float64?\n─────┼─────────────────────────────────────\n   1 │     1       1.0       1.0       1.0\n   2 │     2       1.0       1.0       1.0\n   3 │     3       1.0       1.0       2.0\n   4 │     4       2.0       1.0       2.0\n   5 │     5       2.0       1.0       3.0\n   6 │     6       2.0       1.0       3.0\n\nNote that there are some differences between the widened results above.\n\njulia> df = DataFrame(id=[\"1\", \"1\", \"2\"],\n                      variable=[\"Var1\", \"Var2\", \"Var1\"],\n                      value=[1, 2, 3])\n3×3 DataFrame\n Row │ id      variable  value\n     │ String  String    Int64\n─────┼─────────────────────────\n   1 │ 1       Var1          1\n   2 │ 1       Var2          2\n   3 │ 2       Var1          3\n\njulia> unstack(df, :variable, :value, fill=0)\n2×3 DataFrame\n Row │ id      Var1   Var2\n     │ String  Int64  Int64\n─────┼──────────────────────\n   1 │ 1           1      2\n   2 │ 2           3      0\n\njulia> df = DataFrame(cols=[\"a\", \"a\", \"b\"], values=[1, 2, 4])\n3×2 DataFrame\n Row │ cols    values\n     │ String  Int64\n─────┼────────────────\n   1 │ a            1\n   2 │ a            2\n   3 │ b            4\n\njulia> unstack(df, :cols, :values, combine=copy)\n1×2 DataFrame\n Row │ a        b\n     │ Array…?  Array…?\n─────┼──────────────────\n   1 │ [1, 2]   [4]\n\njulia> unstack(df, :cols, :values, combine=sum)\n1×2 DataFrame\n Row │ a       b\n     │ Int64?  Int64?\n─────┼────────────────\n   1 │      3       4\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.permutedims","page":"Functions","title":"Base.permutedims","text":"permutedims(df::AbstractDataFrame,\n            [src_namescol::Union{Int, Symbol, AbstractString}],\n            [dest_namescol::Union{Symbol, AbstractString}];\n            makeunique::Bool=false, strict::Bool=true)\n\nTurn df on its side such that rows become columns and values in the column indexed by src_namescol become the names of new columns. In the resulting DataFrame, column names of df will become the first column with name specified by dest_namescol.\n\nArguments\n\ndf : the AbstractDataFrame\nsrc_namescol : the column that will become the new header.  If omitted then column names :x1, :x2, ... are generated automatically.\ndest_namescol : the name of the first column in the returned DataFrame. Defaults to the same name as src_namescol. Not supported when src_namescol is a vector or is omitted.\nmakeunique : if false (the default), an error will be raised if duplicate names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate). Not supported when src_namescol is omitted.\nstrict : if true (the default), an error will be raised if the values contained in the src_namescol are not all Symbol or all AbstractString, or can all be converted to String using convert. If false then any values are accepted and the will be changed to strings using the string function. Not supported when src_namescol is a vector or is omitted.\n\nNote: The element types of columns in resulting DataFrame (other than the first column if it is created from df column names, which always has element type String) will depend on the element types of all input columns based on the result of promote_type. That is, if the source data frame contains Int and Float64 columns, resulting columns will have element type Float64. If the source has Int and String columns, resulting columns will have element type Any.\n\nMetadata: table-level :note-style metadata is preserved and column-level metadata is dropped.\n\nExamples\n\njulia> df = DataFrame(a=1:2, b=3:4)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> permutedims(df)\n2×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     3      4\n\njulia> permutedims(df, [:p, :q])\n2×2 DataFrame\n Row │ p      q\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     3      4\n\njulia> df1 = DataFrame(a=[\"x\", \"y\"], b=[1.0, 2.0], c=[3, 4], d=[true, false])\n2×4 DataFrame\n Row │ a       b        c      d\n     │ String  Float64  Int64  Bool\n─────┼───────────────────────────────\n   1 │ x           1.0      3   true\n   2 │ y           2.0      4  false\n\njulia> permutedims(df1, 1) # note the column types\n3×3 DataFrame\n Row │ a       x        y\n     │ String  Float64  Float64\n─────┼──────────────────────────\n   1 │ b           1.0      2.0\n   2 │ c           3.0      4.0\n   3 │ d           1.0      0.0\n\njulia> df2 = DataFrame(a=[\"x\", \"y\"], b=[1, \"two\"], c=[3, 4], d=[true, false])\n2×4 DataFrame\n Row │ a       b    c      d\n     │ String  Any  Int64  Bool\n─────┼───────────────────────────\n   1 │ x       1        3   true\n   2 │ y       two      4  false\n\njulia> permutedims(df2, 1, \"different_name\")\n3×3 DataFrame\n Row │ different_name  x     y\n     │ String          Any   Any\n─────┼─────────────────────────────\n   1 │ b               1     two\n   2 │ c               3     4\n   3 │ d               true  false\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Sorting","page":"Functions","title":"Sorting","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"issorted\norder\nsort\nsort!\nsortperm","category":"page"},{"location":"lib/functions/#Base.issorted","page":"Functions","title":"Base.issorted","text":"issorted(df::AbstractDataFrame, cols=All();\n         lt::Union{Function, AbstractVector{<:Function}}=isless,\n         by::Union{Function, AbstractVector{<:Function}}=identity,\n         rev::Union{Bool, AbstractVector{Bool}}=false,\n         order::Union{Ordering, AbstractVector{<:Ordering}}=Forward,\n         checkunique::Bool=false)\n\nTest whether data frame df sorted by column(s) cols. Checking against multiple columns is done lexicographically.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). If cols selects no columns, check whether df is sorted on all columns (this behaviour is deprecated and will change in future versions).\n\nIf rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below).\n\nSince having repeated elements makes multiple sorting orders valid, the checkunique keyword allows for the situation to be caught. If checkunique is true and duplicate elements are found an error will be thrown. The use of the checkunique keyword is only supported when neither the by nor the lt keywords are being used. Similarly, the use of order(...) clauses that specify either by or lt are not supported, but specifying rev by itself is allowed.\n\nThe by keyword allows providing a function that will be applied to each cell before comparison; the lt keyword allows providing a custom \"less than\" function. If both by and lt are specified, the lt function is applied to the result of the by function.\n\nKeyword arguments specifying sorting order (rev, lt or by) can either be a single value, or a vector of length equal to the number of columns the operation is performed on. When a single value is passed, it applies to all columns. When a vector is passed, each entry applies to the column in the corresponding position in cols.\n\nExamples\n\njulia> df = DataFrame(a=[1, 2, 3, 4], b=[4, 3, 2, 1])\n4×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      3\n   3 │     3      2\n   4 │     4      1\n\njulia> issorted(df)\ntrue\n\njulia> issorted(df, :a)\ntrue\n\njulia> issorted(df, :b)\nfalse\n\njulia> issorted(df, :b, rev=true)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.order","page":"Functions","title":"DataFrames.order","text":"order(col::ColumnIndex; kwargs...)\n\nSpecify sorting order for a column col in a data frame. kwargs can be lt, by, rev, and order with values following the rules defined in sort!.\n\nSee also: sort!, sort\n\nExamples\n\njulia> df = DataFrame(x=[-3, -1, 0, 2, 4], y=1:5)\n5×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │    -3      1\n   2 │    -1      2\n   3 │     0      3\n   4 │     2      4\n   5 │     4      5\n\njulia> sort(df, order(:x, rev=true))\n5×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     4      5\n   2 │     2      4\n   3 │     0      3\n   4 │    -1      2\n   5 │    -3      1\n\njulia> sort(df, order(:x, by=abs))\n5×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     0      3\n   2 │    -1      2\n   3 │     2      4\n   4 │    -3      1\n   5 │     4      5\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.sort","page":"Functions","title":"Base.sort","text":"sort(df::AbstractDataFrame, cols=All();\n     alg::Union{Algorithm, Nothing}=nothing,\n     lt::Union{Function, AbstractVector{<:Function}}=isless,\n     by::Union{Function, AbstractVector{<:Function}}=identity,\n     rev::Union{Bool, AbstractVector{Bool}}=false,\n     order::Union{Ordering, AbstractVector{<:Ordering}}=Forward,\n     view::Bool=false,\n     checkunique::Bool=false)\n\nReturn a data frame containing the rows in df sorted by column(s) cols. Sorting on multiple columns is done lexicographically.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). If cols selects no columns, sort df on all columns (this behaviour is deprecated and will change in future versions).\n\nIf rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below).\n\nSince having repeated elements makes multiple sorting orders valid, the checkunique keyword allows for the situation to be caught. If checkunique is true and duplicate elements are found an error will be thrown. The use of the checkunique keyword is only supported when neither the by nor the lt keywords are being used. Similarly, the use of order(...) clauses that specify either by or lt are not supported, but specifying rev by itself is allowed.\n\nThe by keyword allows providing a function that will be applied to each cell before comparison; the lt keyword allows providing a custom \"less than\" function. If both by and lt are specified, the lt function is applied to the result of the by function.\n\nKeyword arguments specifying sorting order (rev, lt or by) can either be a single value, or a vector of length equal to the number of columns the operation is performed on. When a single value is passed, it applies to all columns. When a vector is passed, each entry applies to the column in the corresponding position in cols.\n\nIf alg is nothing (the default), the most appropriate algorithm is chosen automatically among TimSort, MergeSort and RadixSort depending on the type of the sorting columns and on the number of rows in df.\n\nIf view=false a freshly allocated DataFrame is returned. If view=true then a SubDataFrame view into df is returned.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(x=[3, 1, 2, 1], y=[\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     2  a\n   4 │     1  b\n\njulia> sort(df, :x)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  c\n   2 │     1  b\n   3 │     2  a\n   4 │     3  b\n\njulia> sort(df, [:x, :y])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  b\n   2 │     1  c\n   3 │     2  a\n   4 │     3  b\n\njulia> sort(df, [:x, :y], rev=true)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n   3 │     1  c\n   4 │     1  b\n\njulia> sort(df, [:x, order(:y, rev=true)])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  c\n   2 │     1  b\n   3 │     2  a\n   4 │     3  b\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.sort!","page":"Functions","title":"Base.sort!","text":"sort!(df::AbstractDataFrame, cols=All();\n      alg::Union{Algorithm, Nothing}=nothing,\n      lt::Union{Function, AbstractVector{<:Function}}=isless,\n      by::Union{Function, AbstractVector{<:Function}}=identity,\n      rev::Union{Bool, AbstractVector{Bool}}=false,\n      order::Union{Ordering, AbstractVector{<:Ordering}}=Forward,\n      checkunique::Bool=false)\n\nSort data frame df by column(s) cols by permuting its rows in-place. Sorting on multiple columns is done lexicographicallly.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). If cols selects no columns, sort df on all columns (this behaviour is deprecated and will change in future versions).\n\nIf rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below).\n\nSince having repeated elements makes multiple sorting orders valid, the checkunique keyword allows for the situation to be caught. If checkunique is true and duplicate elements are found an error will be thrown. The use of the checkunique keyword is only supported when neither the by nor the lt keywords are being used. Similarly, the use of order(...) clauses that specify either by or lt are not supported, but specifying rev by itself is allowed.\n\nThe by keyword allows providing a function that will be applied to each cell before comparison; the lt keyword allows providing a custom \"less than\" function. If both by and lt are specified, the lt function is applied to the result of the by function.\n\nKeyword arguments specifying sorting order (rev, lt or by) can either be a single value, or a vector of length equal to the number of columns the operation is performed on. When a single value is passed, it applies to all columns. When a vector is passed, each entry applies to the column in the corresponding position in cols.\n\nIf alg is nothing (the default), the most appropriate algorithm is chosen automatically among TimSort, MergeSort and RadixSort depending on the type of the sorting columns and on the number of rows in df.\n\nsort! will produce a correct result even if some columns of passed data frame are identical (checked with ===). Otherwise, if two columns share some part of memory but are not identical (e.g. are different views of the same parent vector) then sort! result might be incorrect.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nMetadata having other styles is dropped (from parent data frame when df is a SubDataFrame).\n\nExamples\n\njulia> df = DataFrame(x=[3, 1, 2, 1], y=[\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     2  a\n   4 │     1  b\n\njulia> sort!(df, :x)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  c\n   2 │     1  b\n   3 │     2  a\n   4 │     3  b\n\njulia> sort!(df, [:x, :y])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  b\n   2 │     1  c\n   3 │     2  a\n   4 │     3  b\n\njulia> sort!(df, [:x, :y], rev=true)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n   3 │     1  c\n   4 │     1  b\n\njulia> sort!(df, [:x, order(:y, rev=true)])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  c\n   2 │     1  b\n   3 │     2  a\n   4 │     3  b\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.sortperm","page":"Functions","title":"Base.sortperm","text":"sortperm(df::AbstractDataFrame, cols=All();\n         alg::Union{Algorithm, Nothing}=nothing,\n         lt::Union{Function, AbstractVector{<:Function}}=isless,\n         by::Union{Function, AbstractVector{<:Function}}=identity,\n         rev::Union{Bool, AbstractVector{Bool}}=false,\n         order::Union{Ordering, AbstractVector{<:Ordering}}=Forward,\n         checkunique::Bool=false)\n\nReturn a permutation vector of row indices of data frame df that puts them in sorted order according to column(s) cols. Order on multiple columns is computed lexicographically.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). If cols selects no columns, return permutation vector based on sorting all columns (this behaviour is deprecated and will change in future versions).\n\nIf rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below).\n\nSince having repeated elements makes multiple sorting orders valid, the checkunique keyword allows for the situation to be caught. If checkunique is true and duplicate elements are found an error will be thrown. The use of the checkunique keyword is only supported when neither the by nor the lt keywords are being used. Similarly, the use of order(...) clauses that specify either by or lt are not supported, but specifying rev by itself is allowed.\n\nThe by keyword allows providing a function that will be applied to each cell before comparison; the lt keyword allows providing a custom \"less than\" function. If both by and lt are specified, the lt function is applied to the result of the by function.\n\nKeyword arguments specifying sorting order (rev, lt or by) can either be a single value, or a vector of length equal to the number of columns the operation is performed on. When a single value is passed, it applies to all columns. When a vector is passed, each entry applies to the column in the corresponding position in cols.\n\nIf alg is nothing (the default), the most appropriate algorithm is chosen automatically among TimSort, MergeSort and RadixSort depending on the type of the sorting columns and on the number of rows in df.\n\nExamples\n\njulia> df = DataFrame(x=[3, 1, 2, 1], y=[\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     2  a\n   4 │     1  b\n\njulia> sortperm(df, :x)\n4-element Vector{Int64}:\n 2\n 4\n 3\n 1\n\njulia> sortperm(df, [:x, :y])\n4-element Vector{Int64}:\n 4\n 2\n 3\n 1\n\njulia> sortperm(df, [:x, :y], rev=true)\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4\n\njulia> sortperm(df, [:x, order(:y, rev=true)])\n4-element Vector{Int64}:\n 2\n 4\n 3\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Joining","page":"Functions","title":"Joining","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"antijoin\ncrossjoin\ninnerjoin\nleftjoin\nleftjoin!\nouterjoin\nrightjoin\nsemijoin","category":"page"},{"location":"lib/functions/#DataAPI.antijoin","page":"Functions","title":"DataAPI.antijoin","text":"antijoin(df1, df2; on, makeunique=false, validate=(false, false), matchmissing=:error)\n\nPerform an anti join of two data frame objects and return a DataFrame containing the result. An anti join returns the subset of rows of df1 that do not match with the keys in df2.\n\nThe order of rows in the result is kept from df1.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). A left=>right pair of names can be used instead of a name, for the case where a key has different names in df1 and df2 (it is allowed to mix names and name pairs in a vector). Key values are compared using isequal. on is a required argument.\nmakeunique : ignored as no columns are added to df1 columns (it is provided for consistency with other functions).\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; if equal to :notequal then missings are dropped in df2 on columns.\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nMetadata: table-level and column-level :note-style metadata are taken from df1.\n\nSee also: innerjoin, leftjoin, rightjoin,           outerjoin, semijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID=[1, 2, 3], Name=[\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> antijoin(name, job, on = :ID)\n1×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     3  Joe Blogs\n\njulia> job2 = DataFrame(identifier=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> antijoin(name, job2, on = :ID => :identifier)\n1×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     3  Joe Blogs\n\njulia> antijoin(name, job2, on = [:ID => :identifier])\n1×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     3  Joe Blogs\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.crossjoin","page":"Functions","title":"DataAPI.crossjoin","text":"crossjoin(df1::AbstractDataFrame, df2::AbstractDataFrame;\n          makeunique::Bool=false, renamecols=identity => identity)\ncrossjoin(df1, df2, dfs...; makeunique = false)\n\nPerform a cross join of two or more data frame objects and return a DataFrame containing the result. A cross join returns the cartesian product of rows from all passed data frames, where the first passed data frame is assigned to the dimension that changes the slowest and the last data frame is assigned to the dimension that changes the fastest.\n\nArguments\n\ndf1, df2, dfs... : the AbstractDataFrames to be joined\n\nKeyword Arguments\n\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nrenamecols : a Pair specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a Symbol can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a String.\n\nIf more than two data frames are passed, the join is performed recursively with left associativity.\n\nMetadata: table-level :note-style metadata is preserved only for keys which are defined in all passed tables and have the same value. Column-level :note-style metadata is preserved from both tables.\n\nSee also: innerjoin, leftjoin, rightjoin,           outerjoin, semijoin, antijoin.\n\nExamples\n\njulia> df1 = DataFrame(X=1:3)\n3×1 DataFrame\n Row │ X\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> df2 = DataFrame(Y=[\"a\", \"b\"])\n2×1 DataFrame\n Row │ Y\n     │ String\n─────┼────────\n   1 │ a\n   2 │ b\n\njulia> crossjoin(df1, df2)\n6×2 DataFrame\n Row │ X      Y\n     │ Int64  String\n─────┼───────────────\n   1 │     1  a\n   2 │     1  b\n   3 │     2  a\n   4 │     2  b\n   5 │     3  a\n   6 │     3  b\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.innerjoin","page":"Functions","title":"DataAPI.innerjoin","text":"innerjoin(df1, df2; on, makeunique=false, validate=(false, false),\n          renamecols=(identity => identity), matchmissing=:error,\n          order=:undefined)\ninnerjoin(df1, df2, dfs...; on, makeunique=false,\n          validate=(false, false), matchmissing=:error,\n          order=:undefined)\n\nPerform an inner join of two or more data frame objects and return a DataFrame containing the result. An inner join includes rows with keys that match in all passed data frames.\n\nIn the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in df1. This behavior may change in future releases.\n\nArguments\n\ndf1, df2, dfs...: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). When joining only two data frames, a left=>right pair of names can be used instead of a name, for the case where a key has different names in df1 and df2 (it is allowed to mix names and name pairs in a vector). Key values are compared using isequal. on is a required argument.\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nvalidate : whether to check that columns passed as the on argument define unique keys in each input data frame (according to isequal). Can be a tuple or a pair, with the first element indicating whether to run check for df1 and the second element for df2. By default no check is performed.\nrenamecols : a Pair specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a Symbol can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a String. Note that renamecols does not affect on columns, whose names are always taken from the left data frame and left unchanged.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; if equal to :notequal then missings are dropped in df1 and df2 on columns.\norder : if :undefined (the default) the order of rows in the result is  undefined and may change in future releases. If :left then the order of  rows from the left data frame is retained. If :right then the order of rows  from the right data frame is retained.\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nIf more than two data frames are passed, the join is performed recursively with left associativity. In this case the validate keyword argument is applied recursively with left associativity.\n\nMetadata: table-level :note-style metadata and column-level :note-style metadata for key columns is preserved only for keys which are defined in all passed tables and have the same value. Column-level :note-style metadata is preserved for all other columns.\n\nSee also: leftjoin, rightjoin, outerjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID=[1, 2, 3], Name=[\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> innerjoin(name, job, on = :ID)\n2×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String    String\n─────┼─────────────────────────\n   1 │     1  John Doe  Lawyer\n   2 │     2  Jane Doe  Doctor\n\njulia> job2 = DataFrame(identifier=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> innerjoin(name, job2, on = :ID => :identifier, renamecols = \"_left\" => \"_right\")\n2×3 DataFrame\n Row │ ID     Name_left  Job_right\n     │ Int64  String     String\n─────┼─────────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n\njulia> innerjoin(name, job2, on = [:ID => :identifier], renamecols = uppercase => lowercase)\n2×3 DataFrame\n Row │ ID     NAME      job\n     │ Int64  String    String\n─────┼─────────────────────────\n   1 │     1  John Doe  Lawyer\n   2 │     2  Jane Doe  Doctor\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.leftjoin","page":"Functions","title":"DataAPI.leftjoin","text":"leftjoin(df1, df2; on, makeunique=false, source=nothing, validate=(false, false),\n         renamecols=(identity => identity), matchmissing=:error, order=:undefined)\n\nPerform a left join of two data frame objects and return a DataFrame containing the result. A left join includes all rows from df1.\n\nIn the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in df1. This behavior may change in future releases.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). A left=>right pair of names can be used instead of a name, for the case where a key has different names in df1 and df2 (it is allowed to mix names and name pairs in a vector). Key values are compared using isequal. on is a required argument.\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nsource : Default: nothing. If a Symbol or string, adds indicator column with the given name, for whether a row appeared in only df1 (\"left_only\") or in both (\"both\"). If the name is already in use, the column name will be modified if makeunique=true.\nvalidate : whether to check that columns passed as the on argument define unique keys in each input data frame (according to isequal). Can be a tuple or a pair, with the first element indicating whether to run check for df1 and the second element for df2. By default no check is performed.\nrenamecols : a Pair specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a Symbol can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a String. Note that renamecols does not affect on columns, whose names are always taken from the left data frame and left unchanged.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; if equal to :notequal then missings are dropped in df2 on columns.\norder : if :undefined (the default) the order of rows in the result is  undefined and may change in future releases. If :left then the order of  rows from the left data frame is retained. If :right then the order of rows  from the right data frame is retained (non-matching rows are put at the end).\n\nAll columns of the returned data frame will support missing values.\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nMetadata: table-level and column-level :note-style metadata is taken from df1 (including key columns), except for columns added to it from df2, whose column-level :note-style metadata is taken from df2.\n\nSee also: innerjoin, rightjoin, outerjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID=[1, 2, 3], Name=[\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> leftjoin(name, job, on = :ID)\n3×3 DataFrame\n Row │ ID     Name       Job\n     │ Int64  String     String?\n─────┼───────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     3  Joe Blogs  missing\n\njulia> job2 = DataFrame(identifier=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> leftjoin(name, job2, on = :ID => :identifier, renamecols = \"_left\" => \"_right\")\n3×3 DataFrame\n Row │ ID     Name_left  Job_right\n     │ Int64  String     String?\n─────┼─────────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     3  Joe Blogs  missing\n\njulia> leftjoin(name, job2, on = [:ID => :identifier], renamecols = uppercase => lowercase)\n3×3 DataFrame\n Row │ ID     NAME       job\n     │ Int64  String     String?\n─────┼───────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     3  Joe Blogs  missing\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.leftjoin!","page":"Functions","title":"DataFrames.leftjoin!","text":"leftjoin!(df1, df2; on, makeunique=false, source=nothing,\n          matchmissing=:error)\n\nPerform a left join of two data frame objects by updating the df1 with the joined columns from df2.\n\nA left join includes all rows from df1 and leaves all rows and columns from df1 untouched. Note that each row in df1 must have at most one match in df2. Otherwise, this function would not be able to execute the join in-place since new rows would need to be added to df1.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). A left=>right pair of names can be used instead of a name, for the case where a key has different names in df1 and df2 (it is allowed to mix names and name pairs in a vector). Key values are compared using isequal. on is a required argument.\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nsource : Default: nothing. If a Symbol or string, adds indicator column with the given name, for whether a row appeared in only df1 (\"left_only\") or in both (\"both\"). If the name is already in use, the column name will be modified if makeunique=true.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; if equal to :notequal then missings are dropped in df2 on columns.\n\nThe columns added to df1 from df2 will support missing values.\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nMetadata: table-level and column-level :note-style metadata are taken from df1 (including key columns), except for columns added to it from df2, whose column-level :note-style metadata is taken from df2.\n\nSee also: leftjoin.\n\nExamples\n\njulia> name = DataFrame(ID=[1, 2, 3], Name=[\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> leftjoin!(name, job, on = :ID)\n3×3 DataFrame\n Row │ ID     Name       Job\n     │ Int64  String     String?\n─────┼───────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     3  Joe Blogs  missing\n\njulia> job2 = DataFrame(identifier=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> leftjoin!(name, job2, on = :ID => :identifier, makeunique=true, source=:source)\n3×5 DataFrame\n Row │ ID     Name       Job      Job_1    source\n     │ Int64  String     String?  String?  String\n─────┼───────────────────────────────────────────────\n   1 │     1  John Doe   Lawyer   Lawyer   both\n   2 │     2  Jane Doe   Doctor   Doctor   both\n   3 │     3  Joe Blogs  missing  missing  left_only\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.outerjoin","page":"Functions","title":"DataAPI.outerjoin","text":"outerjoin(df1, df2; on, makeunique=false, source=nothing, validate=(false, false),\n          renamecols=(identity => identity), matchmissing=:error, order=:undefined)\nouterjoin(df1, df2, dfs...; on, makeunique = false,\n          validate = (false, false), matchmissing=:error, order=:undefined)\n\nPerform an outer join of two or more data frame objects and return a DataFrame containing the result. An outer join includes rows with keys that appear in any of the passed data frames.\n\nThe order of rows in the result is undefined and may change in future releases.\n\nIn the returned data frame the type of the columns on which the data frames are joined is determined by the element type of these columns both df1 and df2. This behavior may change in future releases.\n\nArguments\n\ndf1, df2, dfs... : the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). When joining only two data frames, a left=>right pair of names can be used instead of a name, for the case where a key has different names in df1 and df2 (it is allowed to mix names and name pairs in a vector). Key values are compared using isequal. on is a required argument.\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nsource : Default: nothing. If a Symbol or string, adds indicator column with the given name for whether a row appeared in only df1 (\"left_only\"), only df2 (\"right_only\") or in both (\"both\"). If the name is already in use, the column name will be modified if makeunique=true. This argument is only supported when joining exactly two data frames.\nvalidate : whether to check that columns passed as the on argument define unique keys in each input data frame (according to isequal). Can be a tuple or a pair, with the first element indicating whether to run check for df1 and the second element for df2. By default no check is performed.\nrenamecols : a Pair specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a Symbol can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a String. Note that renamecols does not affect on columns, whose names are always taken from the left data frame and left unchanged.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched.\norder : if :undefined (the default) the order of rows in the result is  undefined and may change in future releases. If :left then the order of  rows from the left data frame is retained (non-matching rows are put at the end).  If :right then the order of rows from the right data frame is retained  (non-matching rows are put at the end).\n\nAll columns of the returned data frame will support missing values.\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nIf more than two data frames are passed, the join is performed recursively with left associativity. In this case the indicator keyword argument is not supported and validate keyword argument is applied recursively with left associativity.\n\nMetadata: table-level :note-style metadata and column-level :note-style metadata for key columns is preserved only for keys which are defined in all passed tables and have the same value. Column-level :note-style metadata is preserved for all other columns.\n\nSee also: innerjoin, leftjoin, rightjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID=[1, 2, 3], Name=[\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> outerjoin(name, job, on = :ID)\n4×3 DataFrame\n Row │ ID     Name       Job\n     │ Int64  String?    String?\n─────┼───────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     3  Joe Blogs  missing\n   4 │     4  missing    Farmer\n\njulia> job2 = DataFrame(identifier=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> outerjoin(name, job2, on = :ID => :identifier, renamecols = \"_left\" => \"_right\")\n4×3 DataFrame\n Row │ ID     Name_left  Job_right\n     │ Int64  String?    String?\n─────┼─────────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     3  Joe Blogs  missing\n   4 │     4  missing    Farmer\n\njulia> outerjoin(name, job2, on = [:ID => :identifier], renamecols = uppercase => lowercase)\n4×3 DataFrame\n Row │ ID     NAME       job\n     │ Int64  String?    String?\n─────┼───────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     3  Joe Blogs  missing\n   4 │     4  missing    Farmer\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.rightjoin","page":"Functions","title":"DataAPI.rightjoin","text":"rightjoin(df1, df2; on, makeunique=false, source=nothing,\n          validate=(false, false), renamecols=(identity => identity),\n          matchmissing=:error, order=:undefined)\n\nPerform a right join on two data frame objects and return a DataFrame containing the result. A right join includes all rows from df2.\n\nThe order of rows in the result is undefined and may change in future releases.\n\nIn the returned data frame the type of the columns on which the data frames are joined is determined by the type of these columns in df2. This behavior may change in future releases.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). A left=>right pair of names can be used instead of a name, for the case where a key has different names in df1 and df2 (it is allowed to mix names and name pairs in a vector). Key values are compared using isequal. on is a required argument.\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nsource : Default: nothing. If a Symbol or string, adds indicator column with the given name for whether a row appeared in only df2 (\"right_only\") or in both (\"both\"). If the name is already in use, the column name will be modified if makeunique=true.\nvalidate : whether to check that columns passed as the on argument define unique keys in each input data frame (according to isequal). Can be a tuple or a pair, with the first element indicating whether to run check for df1 and the second element for df2. By default no check is performed.\nrenamecols : a Pair specifying how columns of left and right data frames should be renamed in the resulting data frame. Each element of the pair can be a string or a Symbol can be passed in which case it is appended to the original column name; alternatively a function can be passed in which case it is applied to each column name, which is passed to it as a String. Note that renamecols does not affect on columns, whose names are always taken from the left data frame and left unchanged.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; if equal to :notequal then missings are dropped in df1 on columns.\norder : if :undefined (the default) the order of rows in the result is  undefined and may change in future releases. If :left then the order of  rows from the left data frame is retained (non-matching rows are put at the end).  If :right then the order of rows from the right data frame is retained.\n\nAll columns of the returned data frame will support missing values.\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nMetadata: table-level and column-level :note-style metadata is taken from df2 (including key columns), except for columns added to it from df1, whose column-level :note-style metadata is taken from df1.\n\nSee also: innerjoin, leftjoin, outerjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID=[1, 2, 3], Name=[\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> rightjoin(name, job, on = :ID)\n3×3 DataFrame\n Row │ ID     Name      Job\n     │ Int64  String?   String\n─────┼─────────────────────────\n   1 │     1  John Doe  Lawyer\n   2 │     2  Jane Doe  Doctor\n   3 │     4  missing   Farmer\n\njulia> job2 = DataFrame(identifier=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> rightjoin(name, job2, on = :ID => :identifier, renamecols = \"_left\" => \"_right\")\n3×3 DataFrame\n Row │ ID     Name_left  Job_right\n     │ Int64  String?    String\n─────┼─────────────────────────────\n   1 │     1  John Doe   Lawyer\n   2 │     2  Jane Doe   Doctor\n   3 │     4  missing    Farmer\n\njulia> rightjoin(name, job2, on = [:ID => :identifier], renamecols = uppercase => lowercase)\n3×3 DataFrame\n Row │ ID     NAME      job\n     │ Int64  String?   String\n─────┼─────────────────────────\n   1 │     1  John Doe  Lawyer\n   2 │     2  Jane Doe  Doctor\n   3 │     4  missing   Farmer\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.semijoin","page":"Functions","title":"DataAPI.semijoin","text":"semijoin(df1, df2; on, makeunique=false, validate=(false, false), matchmissing=:error)\n\nPerform a semi join of two data frame objects and return a DataFrame containing the result. A semi join returns the subset of rows of df1 that match with the keys in df2.\n\nThe order of rows in the result is kept from df1.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : The names of the key columns on which to join the data frames. This can be a single name, or a vector of names (for joining on multiple columns). A left=>right pair of names can be used instead of a name, for the case where a key has different names in df1 and df2 (it is allowed to mix names and name pairs in a vector). Key values are compared using isequal. on is a required argument.\nmakeunique : ignored as no columns are added to df1 columns (it is provided for consistency with other functions).\nindicator : Default: nothing. If a Symbol or string, adds categorical indicator  column with the given name for whether a row appeared in only df1 (\"left_only\"),  only df2 (\"right_only\") or in both (\"both\"). If the name is already in use,  the column name will be modified if makeunique=true.\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\nmatchmissing : if equal to :error throw an error if missing is present in on columns; if equal to :equal then missing is allowed and missings are matched; if equal to :notequal then missings are dropped in df2 on columns.\n\nIt is not allowed to join on columns that contain NaN or -0.0 in real or imaginary part of the number. If you need to perform a join on such values use CategoricalArrays.jl and transform a column containing such values into a CategoricalVector.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nMetadata: table-level and column-level :note-style metadata are taken from df1.\n\nSee also: innerjoin, leftjoin, rightjoin,           outerjoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID=[1, 2, 3], Name=[\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼──────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n   3 │     3  Joe Blogs\n\njulia> job = DataFrame(ID=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ ID     Job\n     │ Int64  String\n─────┼───────────────\n   1 │     1  Lawyer\n   2 │     2  Doctor\n   3 │     4  Farmer\n\njulia> semijoin(name, job, on = :ID)\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n\njulia> job2 = DataFrame(identifier=[1, 2, 4], Job=[\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n Row │ identifier  Job\n     │ Int64       String\n─────┼────────────────────\n   1 │          1  Lawyer\n   2 │          2  Doctor\n   3 │          4  Farmer\n\njulia> semijoin(name, job2, on = :ID => :identifier)\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n\njulia> semijoin(name, job2, on = [:ID => :identifier])\n2×2 DataFrame\n Row │ ID     Name\n     │ Int64  String\n─────┼─────────────────\n   1 │     1  John Doe\n   2 │     2  Jane Doe\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Grouping","page":"Functions","title":"Grouping","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"get\ngroupby\ngroupcols\ngroupindices\nkeys\nparent\nproprow\nvaluecols","category":"page"},{"location":"lib/functions/#Base.get","page":"Functions","title":"Base.get","text":"get(gd::GroupedDataFrame, key, default)\n\nGet a group based on the values of the grouping columns.\n\nkey may be a GroupKey, NamedTuple or Tuple of grouping column values (in the same order as the cols argument to groupby). It may also be an AbstractDict, in which case the order of the arguments does not matter.\n\nExamples\n\njulia> df = DataFrame(a=repeat([:foo, :bar, :baz], outer=[2]),\n                      b=repeat([2, 1], outer=[3]),\n                      c=1:6);\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 3 groups based on key: a\nFirst Group (2 rows): a = :foo\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ foo         2      1\n   2 │ foo         1      4\n⋮\nLast Group (2 rows): a = :baz\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ baz         2      3\n   2 │ baz         1      6\n\njulia> get(gd, (a=:bar,), nothing)\n2×3 SubDataFrame\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ bar         1      2\n   2 │ bar         2      5\n\njulia> get(gd, (:baz,), nothing)\n2×3 SubDataFrame\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ baz         2      3\n   2 │ baz         1      6\n\njulia> get(gd, (:qux,), nothing)\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupby","page":"Functions","title":"DataFrames.groupby","text":"groupby(d::AbstractDataFrame, cols;\n        sort::Union{Bool, Nothing, NamedTuple}=nothing,\n        skipmissing::Bool=false)\n\nReturn a GroupedDataFrame representing a view of an AbstractDataFrame split into row groups.\n\nArguments\n\ndf : an AbstractDataFrame to split\ncols : data frame columns to group by. Can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). In particular if the selector picks no columns then a single-group GroupedDataFrame is created. As a special case, if cols is a single column or a vector of columns then it can contain columns wrapped in order that will be used to determine the order of groups if sort is true or a NamedTuple (if sort is false, then passing order is an error; if sort is nothing then it is set to true when order is passed).\nsort : if sort=true sort groups according to the values of the grouping columns cols; if sort=false groups are created in their order of appearance in df; if sort=nothing (the default) then the fastest available grouping algorithm is picked and in consequence the order of groups in the result is undefined and may change in future releases; below a description of the current implementation is provided. Additionally sort can be a NamedTuple having some or all of alg, lt, by, rev, and order fields. In this case the groups are sorted and their order follows the sortperm order.\nskipmissing : whether to skip groups with missing values in one of the grouping columns cols\n\nDetails\n\nAn iterator over a GroupedDataFrame returns a SubDataFrame view for each grouping into df. Within each group, the order of rows in df is preserved.\n\nA GroupedDataFrame also supports indexing by groups, select, transform, and combine (which applies a function to each group and combines the result into a data frame).\n\nGroupedDataFrame also supports the dictionary interface. The keys are GroupKey objects returned by keys(::GroupedDataFrame), which can also be used to get the values of the grouping columns for each group. Tuples and NamedTuples containing the values of the grouping columns (in the same order as the cols argument) are also accepted as indices. Finally, an AbstractDict can be used to index into a grouped data frame where the keys are column names of the data frame. The order of the keys does not matter in this case.\n\nIn the current implementation if sort=nothing groups are ordered following the order of appearance of values in the grouping columns, except when all grouping columns provide non-nothing DataAPI.refpool, in which case the order of groups follows the order of values returned by DataAPI.refpool. As a particular application of this rule if all cols are CategoricalVectors then groups are always sorted. Integer columns with a narrow range also use this this optimization, so to the order of groups when grouping on integer columns is undefined. A column is considered to be an integer column when deciding on the grouping algorithm choice if its eltype is a subtype of Union{Missing, Real}, all its elements are either missing or pass isinteger test, and none of them is equal to -0.0.\n\nSee also\n\ncombine, select, select!, transform, transform!\n\nExamples\n\njulia> df = DataFrame(a=repeat([1, 2, 3, 4], outer=[2]),\n                      b=repeat([2, 1], outer=[4]),\n                      c=1:8);\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 4 groups based on key: a\nFirst Group (2 rows): a = 1\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      2      5\n⋮\nLast Group (2 rows): a = 4\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     4      1      4\n   2 │     4      1      8\n\njulia> gd[1]\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      2      5\n\njulia> last(gd)\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     4      1      4\n   2 │     4      1      8\n\njulia> gd[(a=3,)]\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     3      2      3\n   2 │     3      2      7\n\njulia> gd[Dict(\"a\" => 3)]\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     3      2      3\n   2 │     3      2      7\n\njulia> gd[(3,)]\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     3      2      3\n   2 │     3      2      7\n\njulia> k = first(keys(gd))\nGroupKey: (a = 1,)\n\njulia> gd[k]\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      2      5\n\njulia> for g in gd\n           println(g)\n       end\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      1\n   2 │     1      2      5\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     2      1      2\n   2 │     2      1      6\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     3      2      3\n   2 │     3      2      7\n2×3 SubDataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     4      1      4\n   2 │     4      1      8\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupcols","page":"Functions","title":"DataFrames.groupcols","text":"groupcols(gd::GroupedDataFrame)\n\nReturn a vector of Symbol column names in parent(gd) used for grouping.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupindices","page":"Functions","title":"DataFrames.groupindices","text":"groupindices(gd::GroupedDataFrame)\n\nReturn a vector of group indices for each row of parent(gd).\n\nRows appearing in group gd[i] are attributed index i. Rows not present in any group are attributed missing (this can happen if skipmissing=true was passed when creating gd, or if gd is a subset from a larger GroupedDataFrame).\n\nThe groupindices => target_col_name syntax (or just groupindices without specifying the target column name) is also supported in the transformation mini-language when passing a GroupedDataFrame to transformation functions (combine, select, etc.).\n\nExamples\n\njulia> df = DataFrame(id=[\"a\", \"c\", \"b\", \"b\", \"a\"])\n5×1 DataFrame\n Row │ id\n     │ String\n─────┼────────\n   1 │ a\n   2 │ c\n   3 │ b\n   4 │ b\n   5 │ a\n\njulia> gdf = groupby(df, :id);\n\njulia> combine(gdf, groupindices)\n3×2 DataFrame\n Row │ id      groupindices\n     │ String  Int64\n─────┼──────────────────────\n   1 │ a                  1\n   2 │ c                  2\n   3 │ b                  3\n\njulia> select(gdf, groupindices => :gid)\n5×2 DataFrame\n Row │ id      gid\n     │ String  Int64\n─────┼───────────────\n   1 │ a           1\n   2 │ c           2\n   3 │ b           3\n   4 │ b           3\n   5 │ a           1\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.keys","page":"Functions","title":"Base.keys","text":"keys(gd::GroupedDataFrame)\n\nGet the set of keys for each group of the GroupedDataFrame gd as a GroupKeys object. Each key is a GroupKey, which behaves like a NamedTuple holding the values of the grouping columns for a given group. Unlike the equivalent Tuple, NamedTuple, and AbstractDict, these keys can be used to index into gd efficiently. The ordering of the keys is identical to the ordering of the groups of gd under iteration and integer indexing.\n\nExamples\n\njulia> df = DataFrame(a=repeat([:foo, :bar, :baz], outer=[4]),\n                      b=repeat([2, 1], outer=[6]),\n                      c=1:12);\n\njulia> gd = groupby(df, [:a, :b])\nGroupedDataFrame with 6 groups based on keys: a, b\nFirst Group (2 rows): a = :foo, b = 2\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ foo         2      1\n   2 │ foo         2      7\n⋮\nLast Group (2 rows): a = :baz, b = 1\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ baz         1      6\n   2 │ baz         1     12\n\njulia> keys(gd)\n6-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:\n GroupKey: (a = :foo, b = 2)\n GroupKey: (a = :bar, b = 1)\n GroupKey: (a = :baz, b = 2)\n GroupKey: (a = :foo, b = 1)\n GroupKey: (a = :bar, b = 2)\n GroupKey: (a = :baz, b = 1)\n\njulia> k = keys(gd)[1]\nGroupKey: (a = :foo, b = 2)\n\njulia> keys(k)\n2-element Vector{Symbol}:\n :a\n :b\n\njulia> values(k)  # Same as Tuple(k)\n(:foo, 2)\n\njulia> NamedTuple(k)\n(a = :foo, b = 2)\n\njulia> k.a\n:foo\n\njulia> k[:a]\n:foo\n\njulia> k[1]\n:foo\n\nKeys can be used as indices to retrieve the corresponding group from their GroupedDataFrame:\n\njulia> gd[k]\n2×3 SubDataFrame\n Row │ a       b      c\n     │ Symbol  Int64  Int64\n─────┼──────────────────────\n   1 │ foo         2      1\n   2 │ foo         2      7\n\njulia> gd[keys(gd)[1]] == gd[1]\ntrue\n\n\n\n\n\nkeys(dfc::DataFrameColumns)\n\nGet a vector of column names of dfc as Symbols.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.parent","page":"Functions","title":"Base.parent","text":"parent(gd::GroupedDataFrame)\n\nReturn the parent data frame of gd.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.proprow","page":"Functions","title":"DataFrames.proprow","text":"proprow\n\nCompute the proportion of rows which belong to each group, i.e. its number of rows divided by the total number of rows in a GroupedDataFrame.\n\nThis function can only be used in the transformation mini-language via the proprow => target_col_name syntax (or just proprow without specifying the target column name), when passing a GroupedDataFrame to transformation functions (combine, select, etc.).\n\nExamples\n\njulia> df = DataFrame(id=[\"a\", \"c\", \"b\", \"b\", \"a\", \"b\"])\n6×1 DataFrame\n Row │ id\n     │ String\n─────┼────────\n   1 │ a\n   2 │ c\n   3 │ b\n   4 │ b\n   5 │ a\n   6 │ b\n\njulia> gdf = groupby(df, :id);\n\njulia> combine(gdf, proprow)\n3×2 DataFrame\n Row │ id      proprow\n     │ String  Float64\n─────┼──────────────────\n   1 │ a       0.333333\n   2 │ c       0.166667\n   3 │ b       0.5\n\njulia> select(gdf, proprow => :frac)\n6×2 DataFrame\n Row │ id      frac\n     │ String  Float64\n─────┼──────────────────\n   1 │ a       0.333333\n   2 │ c       0.166667\n   3 │ b       0.5\n   4 │ b       0.5\n   5 │ a       0.333333\n   6 │ b       0.5\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.valuecols","page":"Functions","title":"DataFrames.valuecols","text":"valuecols(gd::GroupedDataFrame)\n\nReturn a vector of Symbol column names in parent(gd) not used for grouping.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Filtering-rows","page":"Functions","title":"Filtering rows","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"allunique\ndeleteat!\nempty\nempty!\nfilter\nfilter!\nkeepat!\nfirst\nlast\nnonunique\nonly\npop!\npopat!\npopfirst!\nresize!\nsubset\nsubset!\nunique\nunique!","category":"page"},{"location":"lib/functions/#Base.allunique","page":"Functions","title":"Base.allunique","text":"allunique(df::AbstractDataFrame, cols=:)\n\nReturn true if none of the rows of df are duplicated. Two rows are duplicates if all their columns contain equal values (according to isequal) for all columns in cols (by default, all columns).\n\nArguments\n\ndf : AbstractDataFrame\ncols : a selector specifying the column(s) or their transformations to compare. Can be any column selector or transformation accepted by select.\n\nSee also unique and nonunique.\n\nExamples\n\njulia> df = DataFrame(i=1:4, x=[1, 2, 1, 2])\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\njulia> allunique(df)\ntrue\n\njulia> allunique(df, :x)\nfalse\n\njulia> allunique(df, :i => ByRow(isodd))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.deleteat!","page":"Functions","title":"Base.deleteat!","text":"deleteat!(df::DataFrame, inds)\n\nDelete rows specified by inds from a DataFrame df in place and return it.\n\nInternally deleteat! is called for all columns so inds must be: a vector of sorted and unique integers, a boolean vector, an integer, or Not wrapping any valid selector.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> deleteat!(df, 2)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     3      6\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.empty","page":"Functions","title":"Base.empty","text":"empty(df::AbstractDataFrame)\n\nCreate a new DataFrame with the same column names and column element types as df but with zero rows.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.empty!","page":"Functions","title":"Base.empty!","text":"empty!(df::DataFrame)\n\nRemove all rows from df, making each of its columns empty.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> empty!(df)\n0×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┴──────────────\n\njulia> df.a, df.b\n(Int64[], Int64[])\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.filter","page":"Functions","title":"Base.filter","text":"filter(fun, df::AbstractDataFrame; view::Bool=false)\nfilter(cols => fun, df::AbstractDataFrame; view::Bool=false)\n\nReturn a data frame containing only rows from df for which fun returns true.\n\nIf cols is not specified then the predicate fun is passed DataFrameRows. Elements of a DataFrameRow may be accessed with dot syntax or column indexing inside fun.\n\nIf cols is specified then the predicate fun is passed elements of the corresponding columns as separate positional arguments, unless cols is an AsTable selector, in which case a NamedTuple of these arguments is passed. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers), and column duplicates are allowed if a vector of Symbols, strings, or integers is passed.\n\nIf view=false a freshly allocated DataFrame is returned. If view=true then a SubDataFrame view into df is returned.\n\nPassing cols leads to a more efficient execution of the operation for large data frames.\n\nnote: Note\nThis method is defined so that DataFrames.jl implements the Julia API for collections, but it is generally recommended to use the subset function instead as it is consistent with other DataFrames.jl functions (as opposed to filter).\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nSee also: filter!\n\nExamples\n\njulia> df = DataFrame(x=[3, 1, 2, 1], y=[\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     2  a\n   4 │     1  b\n\njulia> filter(row -> row.x > 1, df)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n\njulia> filter(row -> row[\"x\"] > 1, df)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n\njulia> filter(:x => x -> x > 1, df)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n\njulia> filter([:x, :y] => (x, y) -> x == 1 || y == \"b\", df)\n3×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     1  b\n\njulia> filter(AsTable(:) => nt -> nt.x == 1 || nt.y == \"b\", df)\n3×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     1  b\n\n\n\n\n\nfilter(fun, gdf::GroupedDataFrame; ungroup::Bool=false)\nfilter(cols => fun, gdf::GroupedDataFrame; ungroup::Bool=false)\n\nReturn only groups in gd for which fun returns true as a GroupedDataFrame if ungroup=false (the default), or as a data frame if ungroup=true.\n\nIf cols is not specified then the predicate fun is called with a SubDataFrame for each group.\n\nIf cols is specified then the predicate fun is called for each group with views of the corresponding columns as separate positional arguments, unless cols is an AsTable selector, in which case a NamedTuple of these arguments is passed. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers), and column duplicates are allowed if a vector of Symbols, strings, or integers is passed.\n\nnote: Note\nThis method is defined so that DataFrames.jl implements the Julia API for collections, but it is generally recommended to use the subset function instead as it is consistent with other DataFrames.jl functions (as opposed to filter).\n\nExamples\n\njulia> df = DataFrame(g=[1, 2], x=['a', 'b']);\n\njulia> gd = groupby(df, :g)\nGroupedDataFrame with 2 groups based on key: g\nFirst Group (1 row): g = 1\n Row │ g      x\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n⋮\nLast Group (1 row): g = 2\n Row │ g      x\n     │ Int64  Char\n─────┼─────────────\n   1 │     2  b\n\njulia> filter(x -> x.x[1] == 'a', gd)\nGroupedDataFrame with 1 group based on key: g\nFirst Group (1 row): g = 1\n Row │ g      x\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n\njulia> filter(:x => x -> x[1] == 'a', gd)\nGroupedDataFrame with 1 group based on key: g\nFirst Group (1 row): g = 1\n Row │ g      x\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n\njulia> filter(:x => x -> x[1] == 'a', gd, ungroup=true)\n1×2 DataFrame\n Row │ g      x\n     │ Int64  Char\n─────┼─────────────\n   1 │     1  a\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.filter!","page":"Functions","title":"Base.filter!","text":"filter!(fun, df::AbstractDataFrame)\nfilter!(cols => fun, df::AbstractDataFrame)\n\nRemove rows from data frame df for which fun returns false.\n\nIf cols is not specified then the predicate fun is passed DataFrameRows. Elements of a DataFrameRow may be accessed with dot syntax or column indexing inside fun.\n\nIf cols is specified then the predicate fun is passed elements of the corresponding columns as separate positional arguments, unless cols is an AsTable selector, in which case a NamedTuple of these arguments is passed. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers), and column duplicates are allowed if a vector of Symbols, strings, or integers is passed.\n\nPassing cols leads to a more efficient execution of the operation for large data frames.\n\nnote: Note\nThis method is defined so that DataFrames.jl implements the Julia API for collections, but it is generally recommended to use the subset! function instead as it is consistent with other DataFrames.jl functions (as opposed to filter!).\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nSee also: filter\n\nExamples\n\njulia> df = DataFrame(x=[3, 1, 2, 1], y=[\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     2  a\n   4 │     1  b\n\njulia> filter!(row -> row.x > 1, df)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n\njulia> filter!(row -> row[\"x\"] > 1, df)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     2  a\n\njulia> filter!(:x => x -> x == 3, df)\n1×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n\njulia> df = DataFrame(x=[3, 1, 2, 1], y=[\"b\", \"c\", \"a\", \"b\"]);\n\njulia> filter!([:x, :y] => (x, y) -> x == 1 || y == \"b\", df)\n3×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     1  b\n\njulia> df = DataFrame(x=[3, 1, 2, 1], y=[\"b\", \"c\", \"a\", \"b\"]);\n\njulia> filter!(AsTable(:) => nt -> nt.x == 1 || nt.y == \"b\", df)\n3×2 DataFrame\n Row │ x      y\n     │ Int64  String\n─────┼───────────────\n   1 │     3  b\n   2 │     1  c\n   3 │     1  b\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.keepat!","page":"Functions","title":"Base.keepat!","text":"keepat!(df::DataFrame, inds)\n\nDelete rows at all indices not specified by inds from a DataFrame df in place and return it.\n\nInternally deleteat! is called for all columns so inds must be: a vector of sorted and unique integers, a boolean vector, an integer, or Not wrapping any valid selector.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> keepat!(df, [1, 3])\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     3      6\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.first","page":"Functions","title":"Base.first","text":"first(df::AbstractDataFrame)\n\nGet the first row of df as a DataFrameRow.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\n\n\n\n\nfirst(df::AbstractDataFrame, n::Integer; view::Bool=false)\n\nGet a data frame with the n first rows of df. Get all rows if n is greater than the number of rows in df. Error if n is negative.\n\nIf view=false a freshly allocated DataFrame is returned. If view=true then a SubDataFrame view into df is returned.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.last","page":"Functions","title":"Base.last","text":"last(df::AbstractDataFrame)\n\nGet the last row of df as a DataFrameRow.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\n\n\n\n\nlast(df::AbstractDataFrame, n::Integer; view::Bool=false)\n\nGet a data frame with the n last rows of df. Get all rows if n is greater than the number of rows in df. Error if n is negative.\n\nIf view=false a freshly allocated DataFrame is returned. If view=true then a SubDataFrame view into df is returned.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.nonunique","page":"Functions","title":"DataFrames.nonunique","text":"nonunique(df::AbstractDataFrame; keep::Symbol=:first)\nnonunique(df::AbstractDataFrame, cols; keep::Symbol=:first)\n\nReturn a Vector{Bool} in which true entries indicate duplicate rows.\n\nDuplicate rows are those for which at least another row contains equal values (according to isequal) for all columns in cols (by default, all columns). If keep=:first (the default), only the first occurrence of a set of duplicate rows is indicated with a false entry. If keep=:last, only the last occurrence of a set of duplicate rows is indicated with a false entry. If keep=:noduplicates, only rows without any duplicates are indicated with a false entry.\n\nArguments\n\ndf : AbstractDataFrame\ncols : a selector specifying the column(s) or their transformations to compare. Can be any column selector or transformation accepted by select that returns at least one column if df has at least one column.\n\nSee also unique and unique!.\n\nExamples\n\njulia> df = DataFrame(i=1:4, x=[1, 2, 1, 2])\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\njulia> df = vcat(df, df)\n8×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n   5 │     1      1\n   6 │     2      2\n   7 │     3      1\n   8 │     4      2\n\njulia> nonunique(df)\n8-element Vector{Bool}:\n 0\n 0\n 0\n 0\n 1\n 1\n 1\n 1\n\njulia> nonunique(df, keep=:last)\n8-element Vector{Bool}:\n 1\n 1\n 1\n 1\n 0\n 0\n 0\n 0\n\njulia> nonunique(df, 2)\n8-element Vector{Bool}:\n 0\n 0\n 1\n 1\n 1\n 1\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.Iterators.only","page":"Functions","title":"Base.Iterators.only","text":"only(df::AbstractDataFrame)\n\nIf df has a single row return it as a DataFrameRow; otherwise throw ArgumentError.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.pop!","page":"Functions","title":"Base.pop!","text":"pop!(df::DataFrame)\n\nRemove the last row from df and return a NamedTuple created from this row.\n\nnote: Note\nUsing this method for very wide data frames may lead to expensive compilation.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> pop!(df)\n(a = 3, b = 6)\n\njulia> df\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.popat!","page":"Functions","title":"Base.popat!","text":"popat!(df::DataFrame, i::Integer)\n\nRemove the i-th row from df and return a NamedTuple created from this row.\n\nnote: Note\nUsing this method for very wide data frames may lead to expensive compilation.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> popat!(df, 2)\n(a = 2, b = 5)\n\njulia> df\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     3      6\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.popfirst!","page":"Functions","title":"Base.popfirst!","text":"popfirst!(df::DataFrame)\n\nRemove the first row from df and return a NamedTuple created from this row.\n\nnote: Note\nUsing this method for very wide data frames may lead to expensive compilation.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> popfirst!(df)\n(a = 1, b = 4)\n\njulia> df\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      5\n   2 │     3      6\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.resize!","page":"Functions","title":"Base.resize!","text":"resize!(df::DataFrame, n::Integer)\n\nResize df to have n rows by calling resize! on all columns of df.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> resize!(df, 2)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.subset","page":"Functions","title":"DataFrames.subset","text":"subset(df::AbstractDataFrame, args...;\n       skipmissing::Bool=false, view::Bool=false, threads::Bool=true)\nsubset(gdf::GroupedDataFrame, args...;\n       skipmissing::Bool=false, view::Bool=false,\n       ungroup::Bool=true, threads::Bool=true)\n\nReturn a copy of data frame df or parent of gdf containing only rows for which all values produced by transformation(s) args for a given row are true. All transformations must produce vectors containing true or false. When the first argument is a GroupedDataFrame, transformations are also allowed to return a single true or false value, which results in including or excluding a whole group.\n\nIf skipmissing=false (the default) args are required to produce results containing only Bool values. If skipmissing=true, additionally missing is allowed and it is treated as false (i.e. rows for which one of the conditions returns missing are skipped).\n\nEach argument passed in args can be any specifier following the rules described for select with the restriction that:\n\nspecifying target column name is not allowed as subset does not create new columns;\nevery passed transformation must return a scalar or a vector (returning AbstractDataFrame, NamedTuple, DataFrameRow or AbstractMatrix is not supported).\n\nIf view=true a SubDataFrame view  is returned instead of a DataFrame.\n\nIf ungroup=false the resulting data frame is re-grouped based on the same grouping columns as gdf and a GroupedDataFrame is returned (preserving the order of groups from gdf).\n\nIf threads=true (the default) transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to false if some transformations require serial execution or are not thread-safe.\n\nIf a GroupedDataFrame is passed then it must include all groups present in the parent data frame, like in select!.\n\nnote: Note\nNote that as the subset function works in exactly the same way as other transformation functions defined in DataFrames.jl this is the preferred way to subset rows of a data frame or grouped data frame. In particular it uses a different set of rules for specifying transformations than filter which is implemented in DataFrames.jl to ensure support for the standard Julia API for collections.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nSee also: subset!, filter, select\n\nExamples\n\njulia> df = DataFrame(id=1:4, x=[true, false, true, false],\n                      y=[true, true, false, false],\n                      z=[true, true, missing, missing], v=[1, 2, 11, 12])\n4×5 DataFrame\n Row │ id     x      y      z        v\n     │ Int64  Bool   Bool   Bool?    Int64\n─────┼─────────────────────────────────────\n   1 │     1   true   true     true      1\n   2 │     2  false   true     true      2\n   3 │     3   true  false  missing     11\n   4 │     4  false  false  missing     12\n\njulia> subset(df, :x)\n2×5 DataFrame\n Row │ id     x     y      z        v\n     │ Int64  Bool  Bool   Bool?    Int64\n─────┼────────────────────────────────────\n   1 │     1  true   true     true      1\n   2 │     3  true  false  missing     11\n\njulia> subset(df, :v => x -> x .> 3)\n2×5 DataFrame\n Row │ id     x      y      z        v\n     │ Int64  Bool   Bool   Bool?    Int64\n─────┼─────────────────────────────────────\n   1 │     3   true  false  missing     11\n   2 │     4  false  false  missing     12\n\njulia> subset(df, :x, :y => ByRow(!))\n1×5 DataFrame\n Row │ id     x     y      z        v\n     │ Int64  Bool  Bool   Bool?    Int64\n─────┼────────────────────────────────────\n   1 │     3  true  false  missing     11\n\njulia> subset(df, :x, :z, skipmissing=true)\n1×5 DataFrame\n Row │ id     x     y     z      v\n     │ Int64  Bool  Bool  Bool?  Int64\n─────┼─────────────────────────────────\n   1 │     1  true  true   true      1\n\njulia> subset(df, :x, :z)\nERROR: ArgumentError: missing was returned in condition number 2 but only true or false are allowed; pass skipmissing=true to skip missing values\n\njulia> subset(groupby(df, :y), :v => x -> x .> minimum(x))\n2×5 DataFrame\n Row │ id     x      y      z        v\n     │ Int64  Bool   Bool   Bool?    Int64\n─────┼─────────────────────────────────────\n   1 │     2  false   true     true      2\n   2 │     4  false  false  missing     12\n\njulia> subset(groupby(df, :y), :v => x -> minimum(x) > 5)\n2×5 DataFrame\n Row │ id     x      y      z        v\n     │ Int64  Bool   Bool   Bool?    Int64\n─────┼─────────────────────────────────────\n   1 │     3   true  false  missing     11\n   2 │     4  false  false  missing     12\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.subset!","page":"Functions","title":"DataFrames.subset!","text":"subset!(df::AbstractDataFrame, args...;\n        skipmissing::Bool=false, threads::Bool=true)\nsubset!(gdf::GroupedDataFrame{DataFrame}, args...;\n        skipmissing::Bool=false, ungroup::Bool=true, threads::Bool=true)\n\nUpdate data frame df or the parent of gdf in place to contain only rows for which all values produced by transformation(s) args for a given row is true. All transformations must produce vectors containing true or false. When the first argument is a GroupedDataFrame, transformations are also allowed to return a single true or false value, which results in including or excluding a whole group.\n\nIf skipmissing=false (the default) args are required to produce results containing only Bool values. If skipmissing=true, additionally missing is allowed and it is treated as false (i.e. rows for which one of the conditions returns missing are skipped).\n\nEach argument passed in args can be any specifier following the rules described for select with the restriction that:\n\nspecifying target column name is not allowed as subset! does not create new columns;\nevery passed transformation must return a scalar or a vector (returning AbstractDataFrame, NamedTuple, DataFrameRow or AbstractMatrix is not supported).\n\nIf ungroup=false the passed GroupedDataFrame gdf is updated (preserving the order of its groups) and returned.\n\nIf threads=true (the default) transformations may be run in separate tasks which can execute in parallel (possibly being applied to multiple rows or groups at the same time). Whether or not tasks are actually spawned and their number are determined automatically. Set to false if some transformations require serial execution or are not thread-safe.\n\nIf GroupedDataFrame is subsetted then it must include all groups present in the parent data frame, like in select!. In this case the passed GroupedDataFrame is updated to have correct groups after its parent is updated.\n\nnote: Note\nNote that as the subset! function works in exactly the same way as other transformation functions defined in DataFrames.jl this is the preferred way to subset rows of a data frame or grouped data frame. In particular it uses a different set of rules for specifying transformations than filter! which is implemented in DataFrames.jl to ensure support for the standard Julia API for collections.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nSee also: subset, filter!, select!\n\nExamples\n\njulia> df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false])\n4×3 DataFrame\n Row │ id     x      y\n     │ Int64  Bool   Bool\n─────┼─────────────────────\n   1 │     1   true   true\n   2 │     2  false   true\n   3 │     3   true  false\n   4 │     4  false  false\n\njulia> subset!(df, :x, :y => ByRow(!));\n\njulia> df\n1×3 DataFrame\n Row │ id     x     y\n     │ Int64  Bool  Bool\n─────┼────────────────────\n   1 │     3  true  false\n\njulia> df = DataFrame(id=1:4, y=[true, true, false, false], v=[1, 2, 11, 12]);\n\njulia> subset!(groupby(df, :y), :v => x -> x .> minimum(x));\n\njulia> df\n2×3 DataFrame\n Row │ id     y      v\n     │ Int64  Bool   Int64\n─────┼─────────────────────\n   1 │     2   true      2\n   2 │     4  false     12\n\njulia> df = DataFrame(id=1:4, x=[true, false, true, false],\n                      z=[true, true, missing, missing], v=1:4)\n4×4 DataFrame\n Row │ id     x      z        v\n     │ Int64  Bool   Bool?    Int64\n─────┼──────────────────────────────\n   1 │     1   true     true      1\n   2 │     2  false     true      2\n   3 │     3   true  missing      3\n   4 │     4  false  missing      4\n\njulia> subset!(df, :x, :z)\nERROR: ArgumentError: missing was returned in condition number 2 but only true or false are allowed; pass skipmissing=true to skip missing values\n\njulia> subset!(df, :x, :z, skipmissing=true);\n\njulia> df\n1×4 DataFrame\n Row │ id     x     z      v\n     │ Int64  Bool  Bool?  Int64\n─────┼───────────────────────────\n   1 │     1  true   true      1\n\njulia> df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false],\n                      z=[true, true, missing, missing], v=[1, 2, 11, 12]);\n\njulia> subset!(groupby(df, :y), :v => x -> x .> minimum(x));\n\njulia> df\n2×5 DataFrame\n Row │ id     x      y      z        v\n     │ Int64  Bool   Bool   Bool?    Int64\n─────┼─────────────────────────────────────\n   1 │     2  false   true     true      2\n   2 │     4  false  false  missing     12\n\njulia> df = DataFrame(id=1:4, x=[true, false, true, false], y=[true, true, false, false],\n                      z=[true, true, missing, missing], v=[1, 2, 11, 12]);\n\njulia> subset!(groupby(df, :y), :v => x -> minimum(x) > 5);\n\njulia> df\n2×5 DataFrame\n Row │ id     x      y      z        v\n     │ Int64  Bool   Bool   Bool?    Int64\n─────┼─────────────────────────────────────\n   1 │     3   true  false  missing     11\n   2 │     4  false  false  missing     12\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.unique","page":"Functions","title":"Base.unique","text":"unique(df::AbstractDataFrame; view::Bool=false, keep::Symbol=:first)\nunique(df::AbstractDataFrame, cols; view::Bool=false, keep::Symbol=:first)\n\nReturn a data frame containing only unique rows in df.\n\nNon-unique (duplicate) rows are those for which at least another row contains equal values (according to isequal) for all columns in cols (by default, all columns). If keep=:first (the default), only the first occurrence of a set of duplicate rows is kept. If keep=:last, only the last occurrence of a set of duplicate rows is kept. If keep=:noduplicates, only rows without any duplicates are kept.\n\nIf view=false a freshly allocated DataFrame is returned, and if view=true then a SubDataFrame view into df is returned.\n\nArguments\n\ndf : the AbstractDataFrame\ncols : a selector specifying the column(s) or their transformations to compare. Can be any column selector or transformation accepted by select that returns at least one column if df has at least one column.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nSee also: unique!, nonunique.\n\nExamples\n\njulia> df = DataFrame(i=1:4, x=[1, 2, 1, 2])\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\njulia> df = vcat(df, df)\n8×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n   5 │     1      1\n   6 │     2      2\n   7 │     3      1\n   8 │     4      2\n\njulia> unique(df)   # doesn't modify df\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\njulia> unique(df, 2)\n2×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n\njulia> unique(df, keep=:noduplicates)\n0×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┴──────────────\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.unique!","page":"Functions","title":"Base.unique!","text":"unique!(df::AbstractDataFrame; keep::Symbol=:first)\nunique!(df::AbstractDataFrame, cols; keep::Symbol=:first)\n\nUpdate df in-place to contain only unique rows.\n\nNon-unique (duplicate) rows are those for which at least another row contains equal values (according to isequal) for all columns in cols (by default, all columns). If keep=:first (the default), only the first occurrence of a set of duplicate rows is kept. If keep=:last, only the last occurrence of a set of duplicate rows is kept. If keep=:noduplicates, only rows without any duplicates are kept.\n\nArguments\n\ndf : the AbstractDataFrame\ncols :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.) specifying the column(s) to compare. Can be any column selector or transformation accepted by select that returns at least one column if df has at least one column.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nSee also: unique!, nonunique.\n\nExamples\n\njulia> df = DataFrame(i=1:4, x=[1, 2, 1, 2])\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\njulia> df = vcat(df, df)\n8×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n   5 │     1      1\n   6 │     2      2\n   7 │     3      1\n   8 │     4      2\n\njulia> unique!(copy(df))  # modifies df\n4×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      1\n   4 │     4      2\n\njulia> unique(df, keep=:noduplicates)\n0×2 DataFrame\n Row │ i      x\n     │ Int64  Int64\n─────┴──────────────\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Working-with-missing-values","page":"Functions","title":"Working with missing values","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"allowmissing\nallowmissing!\ncompletecases\ndisallowmissing\ndisallowmissing!\ndropmissing\ndropmissing!","category":"page"},{"location":"lib/functions/#Missings.allowmissing","page":"Functions","title":"Missings.allowmissing","text":"allowmissing(df::AbstractDataFrame, cols=:)\n\nReturn a copy of data frame df with columns cols converted to element type Union{T, Missing} from T to allow support for missing values.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(a=[1, 2])\n2×1 DataFrame\n Row │ a\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> allowmissing(df)\n2×1 DataFrame\n Row │ a\n     │ Int64?\n─────┼────────\n   1 │      1\n   2 │      2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.allowmissing!","page":"Functions","title":"DataFrames.allowmissing!","text":"allowmissing!(df::DataFrame, cols=:)\n\nConvert columns cols of data frame df from element type T to Union{T, Missing} to support missing values.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.completecases","page":"Functions","title":"DataFrames.completecases","text":"completecases(df::AbstractDataFrame, cols=:)\n\nReturn a Boolean vector with true entries indicating rows without missing values (complete cases) in data frame df.\n\nIf cols is provided, only missing values in the corresponding columns are considered. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers) that returns at least one column if df has at least one column.\n\nSee also: dropmissing and dropmissing!. Use findall(completecases(df)) to get the indices of the rows.\n\nExamples\n\njulia> df = DataFrame(i=1:5,\n                      x=[missing, 4, missing, 2, 1],\n                      y=[missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n Row │ i      x        y\n     │ Int64  Int64?   String?\n─────┼─────────────────────────\n   1 │     1  missing  missing\n   2 │     2        4  missing\n   3 │     3  missing  c\n   4 │     4        2  d\n   5 │     5        1  e\n\njulia> completecases(df)\n5-element BitVector:\n 0\n 0\n 0\n 1\n 1\n\njulia> completecases(df, :x)\n5-element BitVector:\n 0\n 1\n 0\n 1\n 1\n\njulia> completecases(df, [:x, :y])\n5-element BitVector:\n 0\n 0\n 0\n 1\n 1\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Missings.disallowmissing","page":"Functions","title":"Missings.disallowmissing","text":"disallowmissing(df::AbstractDataFrame, cols=:; error::Bool=true)\n\nReturn a copy of data frame df with columns cols converted from element type Union{T, Missing} to T to drop support for missing values.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\nIf error=false then columns containing a missing value will be skipped instead of throwing an error.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(a=Union{Int, Missing}[1, 2])\n2×1 DataFrame\n Row │ a\n     │ Int64?\n─────┼────────\n   1 │      1\n   2 │      2\n\njulia> disallowmissing(df)\n2×1 DataFrame\n Row │ a\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> df = DataFrame(a=[1, missing])\n2×1 DataFrame\n Row │ a\n     │ Int64?\n─────┼─────────\n   1 │       1\n   2 │ missing\n\njulia> disallowmissing(df, error=false)\n2×1 DataFrame\n Row │ a\n     │ Int64?\n─────┼─────────\n   1 │       1\n   2 │ missing\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.disallowmissing!","page":"Functions","title":"DataFrames.disallowmissing!","text":"disallowmissing!(df::DataFrame, cols=:; error::Bool=true)\n\nConvert columns cols of data frame df from element type Union{T, Missing} to T to drop support for missing values.\n\ncols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\nIf error=false then columns containing a missing value will be skipped instead of throwing an error.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.dropmissing","page":"Functions","title":"DataFrames.dropmissing","text":"dropmissing(df::AbstractDataFrame, cols=:; view::Bool=false, disallowmissing::Bool=!view)\n\nReturn a data frame excluding rows with missing values in df.\n\nIf cols is provided, only missing values in the corresponding columns are considered. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf view=false a freshly allocated DataFrame is returned. If view=true then a SubDataFrame view into df is returned. In this case disallowmissing must be false.\n\nIf disallowmissing is true (the default when view is false) then columns specified in cols will be converted so as not to allow for missing values using disallowmissing!.\n\nSee also: completecases and dropmissing!.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nExamples\n\njulia> df = DataFrame(i=1:5,\n                      x=[missing, 4, missing, 2, 1],\n                      y=[missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n Row │ i      x        y\n     │ Int64  Int64?   String?\n─────┼─────────────────────────\n   1 │     1  missing  missing\n   2 │     2        4  missing\n   3 │     3  missing  c\n   4 │     4        2  d\n   5 │     5        1  e\n\njulia> dropmissing(df)\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e\n\njulia> dropmissing(df, disallowmissing=false)\n2×3 DataFrame\n Row │ i      x       y\n     │ Int64  Int64?  String?\n─────┼────────────────────────\n   1 │     4       2  d\n   2 │     5       1  e\n\njulia> dropmissing(df, :x)\n3×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String?\n─────┼───────────────────────\n   1 │     2      4  missing\n   2 │     4      2  d\n   3 │     5      1  e\n\njulia> dropmissing(df, [:x, :y])\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.dropmissing!","page":"Functions","title":"DataFrames.dropmissing!","text":"dropmissing!(df::AbstractDataFrame, cols=:; disallowmissing::Bool=true)\n\nRemove rows with missing values from data frame df and return it.\n\nIf cols is provided, only missing values in the corresponding columns are considered. cols can be any column selector (Symbol, string or integer; :, Cols, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf disallowmissing is true (the default) then the cols columns will get converted using disallowmissing!.\n\nMetadata: this function preserves table-level and column-level :note-style metadata.\n\nSee also: dropmissing and completecases.\n\njulia> df = DataFrame(i=1:5,\n                      x=[missing, 4, missing, 2, 1],\n                      y=[missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n Row │ i      x        y\n     │ Int64  Int64?   String?\n─────┼─────────────────────────\n   1 │     1  missing  missing\n   2 │     2        4  missing\n   3 │     3  missing  c\n   4 │     4        2  d\n   5 │     5        1  e\n\njulia> dropmissing!(copy(df))\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e\n\njulia> dropmissing!(copy(df), disallowmissing=false)\n2×3 DataFrame\n Row │ i      x       y\n     │ Int64  Int64?  String?\n─────┼────────────────────────\n   1 │     4       2  d\n   2 │     5       1  e\n\njulia> dropmissing!(copy(df), :x)\n3×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String?\n─────┼───────────────────────\n   1 │     2      4  missing\n   2 │     4      2  d\n   3 │     5      1  e\n\njulia> dropmissing!(df, [:x, :y])\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Iteration","page":"Functions","title":"Iteration","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"eachcol\neachrow\nvalues\npairs\nIterators.partition","category":"page"},{"location":"lib/functions/#Base.eachcol","page":"Functions","title":"Base.eachcol","text":"eachcol(df::AbstractDataFrame)\n\nReturn a DataFrameColumns object that is a vector-like that allows iterating an AbstractDataFrame column by column.\n\nIndexing into DataFrameColumns objects using integer, Symbol or string returns the corresponding column (without copying). Indexing into DataFrameColumns objects using a multiple column selector returns a subsetted DataFrameColumns object with a new parent containing only the selected columns (without copying).\n\nDataFrameColumns supports most of the AbstractVector API. The key differences are that it is read-only and that the keys function returns a vector of Symbols (and not integers as for normal vectors).\n\nIn particular findnext, findprev, findfirst, findlast, and findall functions are supported, and in findnext and findprev functions it is allowed to pass an integer, string, or Symbol as a reference index.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> eachcol(df)\n4×2 DataFrameColumns\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> collect(eachcol(df))\n2-element Vector{AbstractVector}:\n [1, 2, 3, 4]\n [11, 12, 13, 14]\n\njulia> map(eachcol(df)) do col\n           maximum(col) - minimum(col)\n       end\n2-element Vector{Int64}:\n 3\n 3\n\njulia> sum.(eachcol(df))\n2-element Vector{Int64}:\n 10\n 50\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.eachrow","page":"Functions","title":"Base.eachrow","text":"eachrow(df::AbstractDataFrame)\n\nReturn a DataFrameRows that iterates a data frame row by row, with each row represented as a DataFrameRow.\n\nBecause DataFrameRows have an eltype of Any, use copy(dfr::DataFrameRow) to obtain a named tuple, which supports iteration and property access like a DataFrameRow, but also passes information on the eltypes of the columns of df.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> eachrow(df)\n4×2 DataFrameRows\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     11\n   2 │     2     12\n   3 │     3     13\n   4 │     4     14\n\njulia> copy.(eachrow(df))\n4-element Vector{NamedTuple{(:x, :y), Tuple{Int64, Int64}}}:\n (x = 1, y = 11)\n (x = 2, y = 12)\n (x = 3, y = 13)\n (x = 4, y = 14)\n\njulia> eachrow(view(df, [4, 3], [2, 1]))\n2×2 DataFrameRows\n Row │ y      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │    14      4\n   2 │    13      3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.values","page":"Functions","title":"Base.values","text":"values(dfc::DataFrameColumns)\n\nGet a vector of columns from dfc.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.pairs","page":"Functions","title":"Base.pairs","text":"pairs(dfc::DataFrameColumns)\n\nReturn an iterator of pairs associating the name of each column of dfc with the corresponding column vector, i.e. name => col where name is the column name of the column col.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.Iterators.partition","page":"Functions","title":"Base.Iterators.partition","text":"Iterators.partition(df::AbstractDataFrame, n::Integer)\n\nIterate over df data frame n rows at a time, returning each block as a SubDataFrame.\n\nExamples\n\njulia> collect(Iterators.partition(DataFrame(x=1:5), 2))\n3-element Vector{SubDataFrame{DataFrame, DataFrames.Index, UnitRange{Int64}}}:\n 2×1 SubDataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n 2×1 SubDataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     3\n   2 │     4\n 1×1 SubDataFrame\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     5\n\n\n\n\n\nIterators.partition(dfr::DataFrameRows, n::Integer)\n\nIterate over DataFrameRows dfr n rows at a time, returning each block as a DataFrameRows over a view of rows of parent of dfr.\n\nExamples\n\njulia> collect(Iterators.partition(eachrow(DataFrame(x=1:5)), 2))\n3-element Vector{DataFrames.DataFrameRows{SubDataFrame{DataFrame, DataFrames.Index, UnitRange{Int64}}}}:\n 2×1 DataFrameRows\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n 2×1 DataFrameRows\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     3\n   2 │     4\n 1×1 DataFrameRows\n Row │ x\n     │ Int64\n─────┼───────\n   1 │     5\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Equality","page":"Functions","title":"Equality","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"isapprox","category":"page"},{"location":"lib/functions/#Base.isapprox","page":"Functions","title":"Base.isapprox","text":"isapprox(df1::AbstractDataFrame, df2::AbstractDataFrame;\n         rtol::Real=atol>0 ? 0 : √eps, atol::Real=0,\n         nans::Bool=false, norm::Function=norm)\n\nInexact equality comparison. df1 and df2 must have the same size and column names. Return  true if isapprox with given keyword arguments applied to all pairs of columns stored in df1 and df2 returns true.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Metadata","page":"Functions","title":"Metadata","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"metadata\nmetadatakeys\nmetadata!\ndeletemetadata!\nemptymetadata!\ncolmetadata\ncolmetadatakeys\ncolmetadata!\ndeletecolmetadata!\nemptycolmetadata!","category":"page"},{"location":"lib/functions/#DataAPI.metadata","page":"Functions","title":"DataAPI.metadata","text":"metadata(df::AbstractDataFrame, key::AbstractString, [default]; style::Bool=false)\nmetadata(dfr::DataFrameRow, key::AbstractString, [default]; style::Bool=false)\nmetadata(dfc::DataFrameColumns, key::AbstractString, [default]; style::Bool=false)\nmetadata(dfr::DataFrameRows, key::AbstractString, [default]; style::Bool=false)\n\nReturn table-level metadata value associated with df for key key. If style=true return a tuple of metadata value and metadata style.\n\nSubDataFrame and DataFrameRow expose only :note-style metadata of their parent.\n\nIf default is passed then return it if key does not exist; if style=true return (default, :default).\n\nSee also: metadatakeys, metadata!, deletemetadata!, emptymetadata!, colmetadata, colmetadatakeys, colmetadata!, deletecolmetadata!, emptycolmetadata!.\n\nExamples\n\njulia> df = DataFrame(a=1, b=2);\n\njulia> metadatakeys(df)\n()\n\njulia> metadata!(df, \"name\", \"example\", style=:note);\n\njulia> metadatakeys(df)\nKeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:\n  \"name\"\n\njulia> metadata(df, \"name\")\n\"example\"\n\njulia> metadata(df, \"name\", style=true)\n(\"example\", :note)\n\njulia> deletemetadata!(df, \"name\");\n\njulia> metadatakeys(df)\n()\n\n```\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.metadatakeys","page":"Functions","title":"DataAPI.metadatakeys","text":"metadatakeys(df::AbstractDataFrame)\nmetadatakeys(dfr::DataFrameRow)\nmetadatakeys(dfc::DataFrameColumns)\nmetadatakeys(dfr::DataFrameRows)\n\nReturn an iterator of table-level metadata keys which are set in the object.\n\nValues can be accessed using metadata(df, key).\n\nSubDataFrame and DataFrameRow expose only :note-style metadata keys of their parent.\n\nSee also: metadata, metadata!, deletemetadata!, emptymetadata!, colmetadata, colmetadatakeys, colmetadata!, deletecolmetadata!, emptycolmetadata!.\n\nExamples\n\njulia> df = DataFrame(a=1, b=2);\n\njulia> metadatakeys(df)\n()\n\njulia> metadata!(df, \"name\", \"example\", style=:note);\n\njulia> metadatakeys(df)\nKeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:\n  \"name\"\n\njulia> metadata(df, \"name\")\n\"example\"\n\njulia> metadata(df, \"name\", style=true)\n(\"example\", :note)\n\njulia> deletemetadata!(df, \"name\");\n\njulia> metadatakeys(df)\n()\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.metadata!","page":"Functions","title":"DataAPI.metadata!","text":"metadata!(df::AbstractDataFrame, key::AbstractString, value; style::Symbol=:default)\nmetadata!(dfr::DataFrameRow, key::AbstractString, value; style::Symbol=:default)\nmetadata!(dfc::DataFrameColumns, key::AbstractString, value; style::Symbol=:default)\nmetadata!(dfr::DataFrameRows, key::AbstractString, value; style::Symbol=:default)\n\nSet table-level metadata for object df for key key to have value value and style style (:default by default) and return df.\n\nFor SubDataFrame and DataFrameRow only :note-style is allowed. Trying to set a key-value pair for which the key already exists in the parent data frame with another style throws an error.\n\nSee also: metadata, metadatakeys, deletemetadata!, emptymetadata!, colmetadata, colmetadatakeys, colmetadata!, deletecolmetadata!, emptycolmetadata!.\n\nExamples\n\njulia> df = DataFrame(a=1, b=2);\n\njulia> metadatakeys(df)\n()\n\njulia> metadata!(df, \"name\", \"example\", style=:note);\n\njulia> metadatakeys(df)\nKeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:\n  \"name\"\n\njulia> metadata(df, \"name\")\n\"example\"\n\njulia> metadata(df, \"name\", style=true)\n(\"example\", :note)\n\njulia> deletemetadata!(df, \"name\");\n\njulia> metadatakeys(df)\n()\n\n```\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.deletemetadata!","page":"Functions","title":"DataAPI.deletemetadata!","text":"deletemetadata!(df::AbstractDataFrame, key::AbstractString)\ndeletemetadata!(dfr::DataFrameRow, key::AbstractString)\ndeletemetadata!(dfc::DataFrameColumns, key::AbstractString)\ndeletemetadata!(dfr::DataFrameRows, key::AbstractString)\n\nDelete table-level metadata from object df for key key and return df. If key does not exist, return df without modification.\n\nFor SubDataFrame and DataFrameRow only :note-style metadata from their parent can be deleted (as other styles are not propagated to views).\n\nSee also: metadata, metadatakeys, metadata!, emptymetadata!, colmetadata, colmetadatakeys, colmetadata!, deletecolmetadata!, emptycolmetadata!.\n\nExamples\n\njulia> df = DataFrame(a=1, b=2);\n\njulia> metadatakeys(df)\n()\n\njulia> metadata!(df, \"name\", \"example\", style=:note);\n\njulia> metadatakeys(df)\nKeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:\n  \"name\"\n\njulia> metadata(df, \"name\")\n\"example\"\n\njulia> metadata(df, \"name\", style=true)\n(\"example\", :note)\n\njulia> deletemetadata!(df, \"name\");\n\njulia> metadatakeys(df)\n()\n\n```\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.emptymetadata!","page":"Functions","title":"DataAPI.emptymetadata!","text":"emptymetadata!(df::AbstractDataFrame)\nemptymetadata!(dfr::DataFrameRow)\nemptymetadata!(dfc::DataFrameColumns)\nemptymetadata!(dfr::DataFrameRows)\n\nDelete all table-level metadata from object df.\n\nFor SubDataFrame and DataFrameRow only :note-style metadata from their parent can be deleted (as other styles are not propagated to views).\n\nSee also: metadata, metadatakeys, metadata!, deletemetadata!, colmetadata, colmetadatakeys, colmetadata!, deletecolmetadata!, emptycolmetadata!.\n\nExamples\n\njulia> df = DataFrame(a=1, b=2);\n\njulia> metadatakeys(df)\n()\n\njulia> metadata!(df, \"name\", \"example\", style=:note);\n\njulia> metadatakeys(df)\nKeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:\n  \"name\"\n\njulia> metadata(df, \"name\")\n\"example\"\n\njulia> metadata(df, \"name\", style=true)\n(\"example\", :note)\n\njulia> emptymetadata!(df);\n\njulia> metadatakeys(df)\n()\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.colmetadata","page":"Functions","title":"DataAPI.colmetadata","text":"colmetadata(df::AbstractDataFrame, col::ColumnIndex, key::AbstractString, [default]; style::Bool=false)\ncolmetadata(dfr::DataFrameRow, col::ColumnIndex, key::AbstractString, [default]; style::Bool=false)\ncolmetadata(dfc::DataFrameColumns, col::ColumnIndex, key::AbstractString, [default]; style::Bool=false)\ncolmetadata(dfr::DataFrameRows, col::ColumnIndex, key::AbstractString, [default]; style::Bool=false)\n\nReturn column-level metadata value associated with df for column col and key key.\n\nSubDataFrame and DataFrameRow expose only :note-style metadata of their parent.\n\nIf default is passed then return it if key does not exist for column col; if style=true return (default, :default). If col does not exist in df always throw an error.\n\nSee also: metadata, metadatakeys, metadata!, deletemetadata!, emptymetadata!, colmetadatakeys, colmetadata!, deletecolmetadata!, emptycolmetadata!.\n\nExamples\n\njulia> df = DataFrame(a=1, b=2);\n\njulia> colmetadatakeys(df)\n()\n\njulia> colmetadata!(df, :a, \"name\", \"example\", style=:note);\n\njulia> collect(colmetadatakeys(df))\n1-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:\n :a => [\"name\"]\n\njulia> colmetadatakeys(df, :a)\nKeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:\n  \"name\"\n\njulia> colmetadata(df, :a, \"name\")\n\"example\"\n\njulia> colmetadata(df, :a, \"name\", style=true)\n(\"example\", :note)\n\njulia> deletecolmetadata!(df, :a, \"name\");\n\njulia> colmetadatakeys(df)\n()\n\n```\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.colmetadatakeys","page":"Functions","title":"DataAPI.colmetadatakeys","text":"colmetadatakeys(df::AbstractDataFrame, [col::ColumnIndex])\ncolmetadatakeys(dfr::DataFrameRow, [col::ColumnIndex])\ncolmetadatakeys(dfc::DataFrameColumns, [col::ColumnIndex])\ncolmetadatakeys(dfr::DataFrameRows, [col::ColumnIndex])\n\nIf col is passed return an iterator of column-level metadata keys which are set for column col. If col is not passed return an iterator of col => colmetadatakeys(x, col) pairs for all columns that have metadata, where col are Symbol.\n\nValues can be accessed using colmetadata(df, col, key).\n\nSubDataFrame and DataFrameRow expose only :note-style metadata of their parent.\n\nSee also: metadata, metadatakeys, metadata!, deletemetadata!, emptymetadata!, colmetadata, colmetadata!, deletecolmetadata!, emptycolmetadata!.\n\nExamples\n\njulia> df = DataFrame(a=1, b=2);\n\njulia> colmetadatakeys(df)\n()\n\njulia> colmetadata!(df, :a, \"name\", \"example\", style=:note);\n\njulia> collect(colmetadatakeys(df))\n1-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:\n :a => [\"name\"]\n\njulia> colmetadatakeys(df, :a)\nKeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:\n  \"name\"\n\njulia> colmetadata(df, :a, \"name\")\n\"example\"\n\njulia> colmetadata(df, :a, \"name\", style=true)\n(\"example\", :note)\n\njulia> deletecolmetadata!(df, :a, \"name\");\n\njulia> colmetadatakeys(df)\n()\n\n```\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.colmetadata!","page":"Functions","title":"DataAPI.colmetadata!","text":"colmetadata!(df::AbstractDataFrame, col::ColumnIndex, key::AbstractString, value; style::Symbol=:default)\ncolmetadata!(dfr::DataFrameRow, col::ColumnIndex, key::AbstractString, value; style::Symbol=:default)\ncolmetadata!(dfc::DataFrameColumns, col::ColumnIndex, key::AbstractString, value; style::Symbol=:default)\ncolmetadata!(dfr::DataFrameRows, col::ColumnIndex, key::AbstractString, value; style::Symbol=:default)\n\nSet column-level metadata in df for column col and key key to have value value and style style (:default by default) and return df.\n\nFor SubDataFrame and DataFrameRow only :note style is allowed. Trying to set a key-value pair for which the key already exists in the parent data frame with another style throws an error.\n\nSee also: metadata, metadatakeys, metadata!, deletemetadata!, emptymetadata!, colmetadata, colmetadatakeys, deletecolmetadata!, emptycolmetadata!.\n\nExamples\n\njulia> df = DataFrame(a=1, b=2);\n\njulia> colmetadatakeys(df)\n()\n\njulia> colmetadata!(df, :a, \"name\", \"example\", style=:note);\n\njulia> collect(colmetadatakeys(df))\n1-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:\n :a => [\"name\"]\n\njulia> colmetadatakeys(df, :a)\nKeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:\n  \"name\"\n\njulia> colmetadata(df, :a, \"name\")\n\"example\"\n\njulia> colmetadata(df, :a, \"name\", style=true)\n(\"example\", :note)\n\njulia> deletecolmetadata!(df, :a, \"name\");\n\njulia> colmetadatakeys(df)\n()\n\n```\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.deletecolmetadata!","page":"Functions","title":"DataAPI.deletecolmetadata!","text":"deletecolmetadata!(df::AbstractDataFrame, col::ColumnIndex, key::AbstractString)\ndeletecolmetadata!(dfr::DataFrameRow, col::ColumnIndex, key::AbstractString)\ndeletecolmetadata!(dfc::DataFrameColumns, col::ColumnIndex, key::AbstractString)\ndeletecolmetadata!(dfr::DataFrameRows, col::ColumnIndex, key::AbstractString)\n\nDelete column-level metadata set in df for column col and key key and return df.\n\nFor SubDataFrame and DataFrameRow only :note-style metadata from their parent can be deleted (as other styles are not propagated to views).\n\nSee also: metadata, metadatakeys, metadata!, deletemetadata!, emptymetadata!, colmetadata, colmetadatakeys, colmetadata!, emptycolmetadata!.\n\nExamples\n\njulia> df = DataFrame(a=1, b=2);\n\njulia> colmetadatakeys(df)\n()\n\njulia> colmetadata!(df, :a, \"name\", \"example\", style=:note);\n\njulia> collect(colmetadatakeys(df))\n1-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:\n :a => [\"name\"]\n\njulia> colmetadatakeys(df, :a)\nKeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:\n  \"name\"\n\njulia> colmetadata(df, :a, \"name\")\n\"example\"\n\njulia> colmetadata(df, :a, \"name\", style=true)\n(\"example\", :note)\n\njulia> deletecolmetadata!(df, :a, \"name\");\n\njulia> colmetadatakeys(df)\n()\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.emptycolmetadata!","page":"Functions","title":"DataAPI.emptycolmetadata!","text":"emptycolmetadata!(df::AbstractDataFrame, [col::ColumnIndex])\nemptycolmetadata!(dfr::DataFrameRow, [col::ColumnIndex])\nemptycolmetadata!(dfc::DataFrameColumns, [col::ColumnIndex])\nemptycolmetadata!(dfr::DataFrameRows, [col::ColumnIndex])\n\nDelete column-level metadata set in df for column col and key key and return df.\n\nFor SubDataFrame and DataFrameRow only :note-style metadata from their parent can be deleted (as other styles are not propagated to views).\n\nSee also: metadata, metadatakeys, metadata!, deletemetadata!, emptymetadata!, colmetadata, colmetadatakeys, colmetadata!, deletecolmetadata!.\n\nExamples\n\njulia> df = DataFrame(a=1, b=2);\n\njulia> colmetadata!(df, :a, \"name\", \"example\", style=:note);\n\njulia> collect(colmetadatakeys(df))\n1-element Vector{Pair{Symbol, Base.KeySet{String, Dict{String, Tuple{Any, Any}}}}}:\n :a => [\"name\"]\n\njulia> colmetadatakeys(df, :a)\nKeySet for a Dict{String, Tuple{Any, Any}} with 1 entry. Keys:\n  \"name\"\n\njulia> colmetadata(df, :a, \"name\")\n\"example\"\n\njulia> colmetadata(df, :a, \"name\", style=true)\n(\"example\", :note)\n\njulia> emptycolmetadata!(df, :a);\n\njulia> colmetadatakeys(df)\n()\n\n\n\n\n\n","category":"function"},{"location":"man/split_apply_combine/#The-Split-Apply-Combine-Strategy","page":"Split-apply-combine","title":"The Split-Apply-Combine Strategy","text":"","category":"section"},{"location":"man/split_apply_combine/#Design-of-the-split-apply-combine-support","page":"Split-apply-combine","title":"Design of the split-apply-combine support","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Many data analysis tasks involve three steps:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"splitting a data set into groups,\napplying some functions to each of the groups,\ncombining the results.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Note that any of the steps 1 and 3 of this general procedure can be dropped, in which case we just transform a data frame without grouping it and later combining the result.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"A standardized framework for handling this sort of computation is described in the paper \"The Split-Apply-Combine Strategy for Data Analysis\", written by Hadley Wickham.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The DataFrames package supports the split-apply-combine strategy through the groupby function that creates a GroupedDataFrame, followed by combine, select/select! or transform/transform!.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"All operations described in this section of the manual are supported both for AbstractDataFrame (when split and combine steps are skipped) and GroupedDataFrame. Technically, AbstractDataFrame is just considered as being grouped on no columns (meaning it has a single group, or zero groups if it is empty). The only difference is that in this case the keepkeys and ungroup keyword arguments (described below) are not supported and a data frame is always returned, as there are no split and combine steps in this case.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"In order to perform operations by groups you first need to create a GroupedDataFrame object from your data frame using the groupby function that takes two arguments: (1) a data frame to be grouped, and (2) a set of columns to group by.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Operations can then be applied on each group using one of the following functions:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"combine: does not put restrictions on number of rows returned per group; the returned values are vertically concatenated following order of groups in GroupedDataFrame; it is typically used to compute summary statistics by group; for GroupedDataFrame if grouping columns are kept they are put as first columns in the result;\nselect: return a data frame with the number and order of rows exactly the same as the source data frame, including only new calculated columns; select! is an in-place version of select;\ntransform: return a data frame with the number and order of rows exactly the same as the source data frame, including all columns from the source and new calculated columns; transform! is an in-place version of transform; existing columns in the source data frame are put as first columns in the result;","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"As a special case, if a GroupedDataFrame that has zero groups is passed then the result of the operation is determined by performing a single call to the transformation function with a 0-row argument passed to it. The output of this operation is only used to identify the number and type of produced columns, but the result has zero rows.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"All these functions take a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"standard column selectors (integers, Symbols, strings, vectors of integers, vectors of Symbols, vectors of strings, All, Cols, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be any valid column selector; in this case target column name is automatically generated and it is assumed that function returns a single value or a vector; the generated name is created by concatenating source column name and function name by default (see examples below).\na cols => function => target_cols form additionally explicitly specifying the target column or columns, which must be a single name (as a Symbol or a string), a vector of names or AsTable. Additionally it can be a Function which takes a string or a vector of strings as an argument containing names of columns selected by cols, and returns the target columns names (all accepted types except AsTable are allowed).\na col => target_cols pair, which renames the column col to target_cols, which must be single name (as a Symbol or a string), a vector of names or AsTable.\ncolumn-independent operations function => target_cols or just function for specific functions where the input columns are omitted; without target_cols the new column has the same name as function, otherwise it must be single name (as a Symbol or a string). Supported functions are:\nnrow to efficiently compute the number of rows in each group.\nproprow to efficiently compute the proportion of rows in each group.\neachindex to return a vector holding the number of each row within each group.\ngroupindices to return the group number.\nvectors or matrices containing transformations specified by the Pair syntax described in points 2 to 5\na function which will be called with a SubDataFrame corresponding to each group if a GroupedDataFrame is processed, or with the data frame itself if an AbstractDataFrame is processed; this form should be avoided due to its poor performance unless the number of groups is small or a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Note! If the expression of the form x => y is passed then except for the special convenience form nrow => target_cols it is always interpreted as cols => function. In particular the following expression function => target_cols is not a valid transformation specification.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Note! If cols or target_cols are one of All, Cols, Between, or Not, broadcasting using .=> is supported and is equivalent to broadcasting the result of names(df, cols) or names(df, target_cols). This behaves as if broadcasting happened after replacing the selector with selected column names within the data frame scope.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"All functions have two types of signatures. One of them takes a GroupedDataFrame as the first argument and an arbitrary number of transformations described above as following arguments. The second type of signature is when a Function or a Type is passed as the first argument and a GroupedDataFrame as the second argument (similar to map).","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"As a special rule, with the cols => function and cols => function => target_cols syntaxes, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"What is allowed for function to return is determined by the target_cols value:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"If both cols and target_cols are omitted (so only a function is passed), then returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow or a DataFrameRow will produce multiple columns in the result. Returning any other value produces a single column.\nIf target_cols is a Symbol or a string then the function is assumed to return a single column. In this case returning a data frame, a matrix, a NamedTuple, a Tables.AbstractRow, or a DataFrameRow raises an error.\nIf target_cols is a vector of Symbols or strings or AsTable it is assumed that function returns multiple columns. If function returns one of AbstractDataFrame, NamedTuple, DataFrameRow, Tables.AbstractRow, AbstractMatrix then rules described in point 1 above apply. If function returns an AbstractVector then each element of this vector must support the keys function, which must return a collection of Symbols, strings or integers; the return value of keys must be identical for all elements. Then as many columns are created as there are elements in the return value of the keys function. If target_cols is AsTable then their names are set to be equal to the key names except if keys returns integers, in which case they are prefixed by x (so the column names are e.g. x1, x2, ...). If target_cols is a vector of Symbols or strings then column names produced using the rules above are ignored and replaced by target_cols (the number of columns must be the same as the length of target_cols in this case). If fun returns a value of any other type then it is assumed that it is a table conforming to the Tables.jl API and the Tables.columntable function is called on it to get the resulting columns and their names. The names are retained when target_cols is AsTable and are replaced if target_cols is a vector of Symbols or strings.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"In all of these cases, function can return either a single row or multiple rows. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then treated as a single row.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"select/select! and transform/transform! always return a data frame with the same number and order of rows as the source (even if GroupedDataFrame had its groups reordered), except when selection results in zero columns in the resulting data frame (in which case the result has zero rows).","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"For combine, rows in the returned object appear in the order of groups in the GroupedDataFrame. The functions can return an arbitrary number of rows for each group, but the kind of returned object and the number and names of columns must be the same for all groups, except when a DataFrame() or NamedTuple() is returned, in which case a given group is skipped.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be repeated to match the length of columns specified by returned vectors.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"By default (threads=true) a separate task is spawned for each specified transformation; each transformation then spawns as many tasks as Julia threads, and splits processing of groups across them (however, currently transformations with optimized implementations like sum and transformations that return multiple rows use a single task for all groups). This allows for parallel operation when Julia was started with more than one thread. Passed transformation functions must therefore not modify global variables (i.e. they must be pure), use locks to control parallel accesses, or threads=false must be passed to disable multithreading.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"To apply function to each row instead of whole columns, it can be wrapped in a ByRow struct. cols can be any column indexing syntax, in which case function will be passed one argument for each of the columns specified by cols or a NamedTuple of them if specified columns are wrapped in AsTable. If ByRow is used it is allowed for cols to select an empty set of columns, in which case function is called for each row without any arguments and an empty NamedTuple is passed if empty set of columns is wrapped in AsTable.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The following keyword arguments are supported by the transformation functions (not all keyword arguments are supported in all cases; in general they are allowed in situations when they are meaningful, see the documentation of the specific functions for details):","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"keepkeys : whether grouping columns should be kept in the returned data frame.\nungroup : whether the return value of the operation should be a data frame or a GroupedDataFrame.\ncopycols : whether columns of the source data frame should be copied if no transformation is applied to them.\nrenamecols : whether in the cols => function form automatically generated column names should include the name of transformation functions or not.\nthreads : whether transformations may be run in separate tasks which can execute in parallel","category":"page"},{"location":"man/split_apply_combine/#Examples-of-the-split-apply-combine-operations","page":"Split-apply-combine","title":"Examples of the split-apply-combine operations","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"We show several examples of these functions applied to the iris dataset below:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> using DataFrames, CSV, Statistics\n\njulia> path = joinpath(pkgdir(DataFrames), \"docs\", \"src\", \"assets\", \"iris.csv\");\n\njulia> iris = CSV.read(path, DataFrame)\n150×5 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n 144 │         6.8         3.2          5.9         2.3  Iris-virginica\n 145 │         6.7         3.3          5.7         2.5  Iris-virginica\n 146 │         6.7         3.0          5.2         2.3  Iris-virginica\n 147 │         6.3         2.5          5.0         1.9  Iris-virginica\n 148 │         6.5         3.0          5.2         2.0  Iris-virginica\n 149 │         6.2         3.4          5.4         2.3  Iris-virginica\n 150 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                        135 rows omitted\n\njulia> iris_gdf = groupby(iris, :Species)\nGroupedDataFrame with 3 groups based on key: Species\nFirst Group (50 rows): Species = \"Iris-setosa\"\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼───────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮            ⋮\n  49 │         5.3         3.7          1.5         0.2  Iris-setosa\n  50 │         5.0         3.3          1.4         0.2  Iris-setosa\n                                                      46 rows omitted\n⋮\nLast Group (50 rows): Species = \"Iris-virginica\"\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         6.3         3.3          6.0         2.5  Iris-virginica\n   2 │         5.8         2.7          5.1         1.9  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n  50 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                         47 rows omitted\n\njulia> combine(iris_gdf, :PetalLength => mean)\n3×2 DataFrame\n Row │ Species          PetalLength_mean\n     │ String15         Float64\n─────┼───────────────────────────────────\n   1 │ Iris-setosa                 1.464\n   2 │ Iris-versicolor             4.26\n   3 │ Iris-virginica              5.552\n\njulia> combine(iris_gdf, nrow, proprow, groupindices)\n3×4 DataFrame\n Row │ Species          nrow   proprow   groupindices\n     │ String15         Int64  Float64   Int64\n─────┼────────────────────────────────────────────────\n   1 │ Iris-setosa         50  0.333333             1\n   2 │ Iris-versicolor     50  0.333333             2\n   3 │ Iris-virginica      50  0.333333             3\n\njulia> combine(iris_gdf, nrow, :PetalLength => mean => :mean)\n3×3 DataFrame\n Row │ Species          nrow   mean\n     │ String15         Int64  Float64\n─────┼─────────────────────────────────\n   1 │ Iris-setosa         50    1.464\n   2 │ Iris-versicolor     50    4.26\n   3 │ Iris-virginica      50    5.552\n\njulia> combine(iris_gdf,\n               [:PetalLength, :SepalLength] =>\n               ((p, s) -> (a=mean(p)/mean(s), b=sum(p))) =>\n               AsTable) # multiple columns are passed as arguments\n3×3 DataFrame\n Row │ Species          a         b\n     │ String15         Float64   Float64\n─────┼────────────────────────────────────\n   1 │ Iris-setosa      0.292449     73.2\n   2 │ Iris-versicolor  0.717655    213.0\n   3 │ Iris-virginica   0.842744    277.6\n\njulia> combine(iris_gdf,\n               AsTable([:PetalLength, :SepalLength]) =>\n               x -> std(x.PetalLength) / std(x.SepalLength)) # passing a NamedTuple\n3×2 DataFrame\n Row │ Species          PetalLength_SepalLength_function\n     │ String15         Float64\n─────┼───────────────────────────────────────────────────\n   1 │ Iris-setosa                              0.492245\n   2 │ Iris-versicolor                          0.910378\n   3 │ Iris-virginica                           0.867923\n\njulia> combine(x -> std(x.PetalLength) / std(x.SepalLength), iris_gdf) # passing a SubDataFrame\n3×2 DataFrame\n Row │ Species          x1\n     │ String15         Float64\n─────┼───────────────────────────\n   1 │ Iris-setosa      0.492245\n   2 │ Iris-versicolor  0.910378\n   3 │ Iris-virginica   0.867923\n\njulia> combine(iris_gdf, 1:2 => cor, nrow)\n3×3 DataFrame\n Row │ Species          SepalLength_SepalWidth_cor  nrow\n     │ String15         Float64                     Int64\n─────┼────────────────────────────────────────────────────\n   1 │ Iris-setosa                        0.74678      50\n   2 │ Iris-versicolor                    0.525911     50\n   3 │ Iris-virginica                     0.457228     50\n\njulia> combine(iris_gdf, :PetalLength => (x -> [extrema(x)]) => [:min, :max])\n3×3 DataFrame\n Row │ Species          min      max\n     │ String15         Float64  Float64\n─────┼───────────────────────────────────\n   1 │ Iris-setosa          1.0      1.9\n   2 │ Iris-versicolor      3.0      5.1\n   3 │ Iris-virginica       4.5      6.9","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"To get row number for each observation within each group use the eachindex function:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(iris_gdf, eachindex)\n150×2 DataFrame\n Row │ Species         eachindex\n     │ String15        Int64\n─────┼───────────────────────────\n   1 │ Iris-setosa             1\n   2 │ Iris-setosa             2\n   3 │ Iris-setosa             3\n  ⋮  │       ⋮             ⋮\n 148 │ Iris-virginica         48\n 149 │ Iris-virginica         49\n 150 │ Iris-virginica         50\n                 144 rows omitted","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Contrary to combine, the select and transform functions always return a data frame with the same number and order of rows as the source. In the example below the return values in columns :SepalLength_SepalWidth_cor and :nrow are broadcasted to match the number of elements in each group:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> select(iris_gdf, 1:2 => cor)\n150×2 DataFrame\n Row │ Species         SepalLength_SepalWidth_cor\n     │ String          Float64\n─────┼────────────────────────────────────────────\n   1 │ Iris-setosa                       0.74678\n   2 │ Iris-setosa                       0.74678\n   3 │ Iris-setosa                       0.74678\n   4 │ Iris-setosa                       0.74678\n  ⋮  │       ⋮                     ⋮\n 148 │ Iris-virginica                    0.457228\n 149 │ Iris-virginica                    0.457228\n 150 │ Iris-virginica                    0.457228\n                                  143 rows omitted\n\njulia> transform(iris_gdf, :Species => x -> chop.(x, head=5, tail=0))\n150×6 DataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species         Species_function\n     │ Float64      Float64     Float64      Float64     String          SubString…\n─────┼────────────────────────────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa     setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa     setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa     setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa     setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮                ⋮\n 148 │         6.5         3.0          5.2         2.0  Iris-virginica  virginica\n 149 │         6.2         3.4          5.4         2.3  Iris-virginica  virginica\n 150 │         5.9         3.0          5.1         1.8  Iris-virginica  virginica\n                                                                          143 rows omitted","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"All functions also support the do block form. However, as noted above, this form is slow and should therefore be avoided when performance matters.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(iris_gdf) do df\n           (m = mean(df.PetalLength), s² = var(df.PetalLength))\n       end\n3×3 DataFrame\n Row │ Species          m        s²\n     │ String15         Float64  Float64\n─────┼─────────────────────────────────────\n   1 │ Iris-setosa        1.464  0.0301061\n   2 │ Iris-versicolor    4.26   0.220816\n   3 │ Iris-virginica     5.552  0.304588","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"To apply a function to each non-grouping column of a GroupedDataFrame you can write:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(iris_gdf, valuecols(iris_gdf) .=> mean)\n3×5 DataFrame\n Row │ Species          SepalLength_mean  SepalWidth_mean  PetalLength_mean  P ⋯\n     │ String15         Float64           Float64          Float64           F ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ Iris-setosa                 5.006            3.418             1.464    ⋯\n   2 │ Iris-versicolor             5.936            2.77              4.26\n   3 │ Iris-virginica              6.588            2.974             5.552\n                                                                1 column omitted","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Note that GroupedDataFrame is a view: therefore grouping columns of its parent data frame must not be mutated, and rows must not be added nor removed from it. If the number or rows of the parent changes then an error is thrown when a child GroupedDataFrame is used:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> df = DataFrame(id=1:2)\n2×1 DataFrame\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> gd = groupby(df, :id)\nGroupedDataFrame with 2 groups based on key: id\nFirst Group (1 row): id = 1\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n⋮\nLast Group (1 row): id = 2\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     2\n\njulia> push!(df, [3])\n3×1 DataFrame\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> gd[1]\nERROR: AssertionError: The current number of rows in the parent data frame is 3 and it does not match the number of rows it contained when GroupedDataFrame was created which was 2. The number of rows in the parent data frame has likely been changed unintentionally (e.g. using subset!, filter!, deleteat!, push!, or append! functions).","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Sometimes it is useful to append rows to the source data frame of a GroupedDataFrame, without affecting the rows used for grouping. In such a scenario you can create the grouped data frame using a view of the parent data frame to avoid the error:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> df = DataFrame(id=1:2)\n2×1 DataFrame\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n\njulia> gd = groupby(view(df, :, :), :id)\nGroupedDataFrame with 2 groups based on key: id\nFirst Group (1 row): id = 1\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n⋮\nLast Group (1 row): id = 2\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     2\n\njulia> push!(df, [3])\n3×1 DataFrame\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n\njulia> gd[1]\n1×1 SubDataFrame\n Row │ id\n     │ Int64\n─────┼───────\n   1 │     1","category":"page"},{"location":"man/split_apply_combine/#Using-GroupedDataFrame-as-an-iterable-and-indexable-object","page":"Split-apply-combine","title":"Using GroupedDataFrame as an iterable and indexable object","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"If you only want to split the data set into subsets, use the groupby function. You can then iterate SubDataFrames that constitute the identified groups:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> for subdf in iris_gdf\n           println(size(subdf, 1))\n       end\n50\n50\n50","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"To also get the values of the grouping columns along with each group, use the pairs function:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> for (key, subdf) in pairs(iris_gdf)\n           println(\"Number of data points for $(key.Species): $(nrow(subdf))\")\n       end\nNumber of data points for Iris-setosa: 50\nNumber of data points for Iris-versicolor: 50\nNumber of data points for Iris-virginica: 50","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The value of key in the example above where we iterated pairs(iris_gdf) is a DataFrames.GroupKey object, which can be used in a similar fashion to a NamedTuple.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Grouping a data frame using the groupby function can be seen as adding a lookup key to it. Such lookups can be performed efficiently by indexing the resulting GroupedDataFrame with DataFrames.GroupKey (as it was presented above) a Tuple, a NamedTuple, or a dictionary. Here are some more examples of such indexing.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> iris_gdf[(Species=\"Iris-virginica\",)]  # a NamedTuple\n50×5 SubDataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         6.3         3.3          6.0         2.5  Iris-virginica\n   2 │         5.8         2.7          5.1         1.9  Iris-virginica\n   3 │         7.1         3.0          5.9         2.1  Iris-virginica\n   4 │         6.3         2.9          5.6         1.8  Iris-virginica\n   5 │         6.5         3.0          5.8         2.2  Iris-virginica\n   6 │         7.6         3.0          6.6         2.1  Iris-virginica\n   7 │         4.9         2.5          4.5         1.7  Iris-virginica\n   8 │         7.3         2.9          6.3         1.8  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n  44 │         6.8         3.2          5.9         2.3  Iris-virginica\n  45 │         6.7         3.3          5.7         2.5  Iris-virginica\n  46 │         6.7         3.0          5.2         2.3  Iris-virginica\n  47 │         6.3         2.5          5.0         1.9  Iris-virginica\n  48 │         6.5         3.0          5.2         2.0  Iris-virginica\n  49 │         6.2         3.4          5.4         2.3  Iris-virginica\n  50 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                         35 rows omitted\n\njulia> iris_gdf[[(\"Iris-virginica\",), (\"Iris-setosa\",)]] # a vector of Tuples\nGroupedDataFrame with 2 groups based on key: Species\nFirst Group (50 rows): Species = \"Iris-virginica\"\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         6.3         3.3          6.0         2.5  Iris-virginica\n   2 │         5.8         2.7          5.1         1.9  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n  49 │         6.2         3.4          5.4         2.3  Iris-virginica\n  50 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                         46 rows omitted\n⋮\nLast Group (50 rows): Species = \"Iris-setosa\"\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼───────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮            ⋮\n  50 │         5.0         3.3          1.4         0.2  Iris-setosa\n                                                      47 rows omitted\n\njulia> key = keys(iris_gdf) |> last # last key in iris_gdf\nGroupKey: (Species = String15(\"Iris-virginica\"),)\n\njulia> iris_gdf[key]\n50×5 SubDataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         6.3         3.3          6.0         2.5  Iris-virginica\n   2 │         5.8         2.7          5.1         1.9  Iris-virginica\n   3 │         7.1         3.0          5.9         2.1  Iris-virginica\n   4 │         6.3         2.9          5.6         1.8  Iris-virginica\n   5 │         6.5         3.0          5.8         2.2  Iris-virginica\n   6 │         7.6         3.0          6.6         2.1  Iris-virginica\n   7 │         4.9         2.5          4.5         1.7  Iris-virginica\n   8 │         7.3         2.9          6.3         1.8  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n  44 │         6.8         3.2          5.9         2.3  Iris-virginica\n  45 │         6.7         3.3          5.7         2.5  Iris-virginica\n  46 │         6.7         3.0          5.2         2.3  Iris-virginica\n  47 │         6.3         2.5          5.0         1.9  Iris-virginica\n  48 │         6.5         3.0          5.2         2.0  Iris-virginica\n  49 │         6.2         3.4          5.4         2.3  Iris-virginica\n  50 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                         35 rows omitted\n\njulia> iris_gdf[Dict(\"Species\" => \"Iris-setosa\")] # a dictionary\n50×5 SubDataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼───────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮            ⋮\n  44 │         5.0         3.5          1.6         0.6  Iris-setosa\n  45 │         5.1         3.8          1.9         0.4  Iris-setosa\n  46 │         4.8         3.0          1.4         0.3  Iris-setosa\n  47 │         5.1         3.8          1.6         0.2  Iris-setosa\n  48 │         4.6         3.2          1.4         0.2  Iris-setosa\n  49 │         5.3         3.7          1.5         0.2  Iris-setosa\n  50 │         5.0         3.3          1.4         0.2  Iris-setosa\n                                                      35 rows omitted","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Note that although GroupedDataFrame is iterable and indexable it is not an AbstractVector. For this reason currently it was decided that it does not support map nor broadcasting (to allow for making a decision in the future what result type they should produce). To apply a function to all groups of a data frame and get a vector of results either use a comprehension or collect GroupedDataFrame into a vector first. Here are examples of both approaches:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> sdf_vec = collect(iris_gdf)\n3-element Vector{Any}:\n 50×5 SubDataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼───────────────────────────────────────────────────────────────\n   1 │         5.1         3.5          1.4         0.2  Iris-setosa\n   2 │         4.9         3.0          1.4         0.2  Iris-setosa\n   3 │         4.7         3.2          1.3         0.2  Iris-setosa\n   4 │         4.6         3.1          1.5         0.2  Iris-setosa\n   5 │         5.0         3.6          1.4         0.2  Iris-setosa\n   6 │         5.4         3.9          1.7         0.4  Iris-setosa\n   7 │         4.6         3.4          1.4         0.3  Iris-setosa\n   8 │         5.0         3.4          1.5         0.2  Iris-setosa\n  ⋮  │      ⋮           ⋮            ⋮           ⋮            ⋮\n  44 │         5.0         3.5          1.6         0.6  Iris-setosa\n  45 │         5.1         3.8          1.9         0.4  Iris-setosa\n  46 │         4.8         3.0          1.4         0.3  Iris-setosa\n  47 │         5.1         3.8          1.6         0.2  Iris-setosa\n  48 │         4.6         3.2          1.4         0.2  Iris-setosa\n  49 │         5.3         3.7          1.5         0.2  Iris-setosa\n  50 │         5.0         3.3          1.4         0.2  Iris-setosa\n                                                      35 rows omitted\n 50×5 SubDataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼───────────────────────────────────────────────────────────────────\n   1 │         7.0         3.2          4.7         1.4  Iris-versicolor\n   2 │         6.4         3.2          4.5         1.5  Iris-versicolor\n   3 │         6.9         3.1          4.9         1.5  Iris-versicolor\n   4 │         5.5         2.3          4.0         1.3  Iris-versicolor\n   5 │         6.5         2.8          4.6         1.5  Iris-versicolor\n   6 │         5.7         2.8          4.5         1.3  Iris-versicolor\n   7 │         6.3         3.3          4.7         1.6  Iris-versicolor\n   8 │         4.9         2.4          3.3         1.0  Iris-versicolor\n  ⋮  │      ⋮           ⋮            ⋮           ⋮              ⋮\n  44 │         5.0         2.3          3.3         1.0  Iris-versicolor\n  45 │         5.6         2.7          4.2         1.3  Iris-versicolor\n  46 │         5.7         3.0          4.2         1.2  Iris-versicolor\n  47 │         5.7         2.9          4.2         1.3  Iris-versicolor\n  48 │         6.2         2.9          4.3         1.3  Iris-versicolor\n  49 │         5.1         2.5          3.0         1.1  Iris-versicolor\n  50 │         5.7         2.8          4.1         1.3  Iris-versicolor\n                                                          35 rows omitted\n 50×5 SubDataFrame\n Row │ SepalLength  SepalWidth  PetalLength  PetalWidth  Species\n     │ Float64      Float64     Float64      Float64     String15\n─────┼──────────────────────────────────────────────────────────────────\n   1 │         6.3         3.3          6.0         2.5  Iris-virginica\n   2 │         5.8         2.7          5.1         1.9  Iris-virginica\n   3 │         7.1         3.0          5.9         2.1  Iris-virginica\n   4 │         6.3         2.9          5.6         1.8  Iris-virginica\n   5 │         6.5         3.0          5.8         2.2  Iris-virginica\n   6 │         7.6         3.0          6.6         2.1  Iris-virginica\n   7 │         4.9         2.5          4.5         1.7  Iris-virginica\n   8 │         7.3         2.9          6.3         1.8  Iris-virginica\n  ⋮  │      ⋮           ⋮            ⋮           ⋮             ⋮\n  44 │         6.8         3.2          5.9         2.3  Iris-virginica\n  45 │         6.7         3.3          5.7         2.5  Iris-virginica\n  46 │         6.7         3.0          5.2         2.3  Iris-virginica\n  47 │         6.3         2.5          5.0         1.9  Iris-virginica\n  48 │         6.5         3.0          5.2         2.0  Iris-virginica\n  49 │         6.2         3.4          5.4         2.3  Iris-virginica\n  50 │         5.9         3.0          5.1         1.8  Iris-virginica\n                                                         35 rows omitted\n\njulia> map(nrow, sdf_vec)\n3-element Vector{Int64}:\n 50\n 50\n 50\n\njulia> nrow.(sdf_vec)\n3-element Vector{Int64}:\n 50\n 50\n 50","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Since GroupedDataFrame is iterable, you can achieve the same result with a comprehension:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> [nrow(sdf) for sdf in iris_gdf]\n3-element Vector{Int64}:\n 50\n 50\n 50","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Note that using the split-apply-combine strategy with the operation specification syntax in combine, select or transform will usually be faster for large GroupedDataFrame objects than iterating them, with the difference that they produce a data frame. An operation corresponding to the example above is:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(iris_gdf, nrow)\n3×2 DataFrame\n Row │ Species          nrow\n     │ String15         Int64\n─────┼────────────────────────\n   1 │ Iris-setosa         50\n   2 │ Iris-versicolor     50\n   3 │ Iris-virginica      50","category":"page"},{"location":"man/split_apply_combine/#Simulating-the-SQL-where-clause","page":"Split-apply-combine","title":"Simulating the SQL where clause","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"You can conveniently work on subsets of a data frame by using SubDataFrames. Operations performed on such objects can either create a new data frame or be performed in-place. Here are some examples:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> df = DataFrame(a=1:5)\n5×1 DataFrame\n Row │ a\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │     2\n   3 │     3\n   4 │     4\n   5 │     5\n\njulia> sdf = @view df[2:3, :]\n2×1 SubDataFrame\n Row │ a\n     │ Int64\n─────┼───────\n   1 │     2\n   2 │     3\n\njulia> transform(sdf, :a => ByRow(string)) # create a new data frame\n2×2 DataFrame\n Row │ a      a_string\n     │ Int64  String\n─────┼─────────────────\n   1 │     2  2\n   2 │     3  3\n\njulia> transform!(sdf, :a => ByRow(string)) # update the source df in-place\n2×2 SubDataFrame\n Row │ a      a_string\n     │ Int64  String?\n─────┼─────────────────\n   1 │     2  2\n   2 │     3  3\n\njulia> df # new column was created filled with missing in filtered-out rows\n5×2 DataFrame\n Row │ a      a_string\n     │ Int64  String?\n─────┼─────────────────\n   1 │     1  missing\n   2 │     2  2\n   3 │     3  3\n   4 │     4  missing\n   5 │     5  missing\n\njulia> select!(sdf, :a => -, renamecols=false) # update the source df in-place\n2×1 SubDataFrame\n Row │ a\n     │ Int64\n─────┼───────\n   1 │    -2\n   2 │    -3\n\njulia> df # the column replaced an existing column; previously stored values are re-used in filtered-out rows\n5×1 DataFrame\n Row │ a\n     │ Int64\n─────┼───────\n   1 │     1\n   2 │    -2\n   3 │    -3\n   4 │     4\n   5 │     5","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Similar operations can be performed on GroupedDataFrame as well:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> df = DataFrame(a=[1, 1, 1, 2, 2, 3], b=1:6)\n6×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     1      2\n   3 │     1      3\n   4 │     2      4\n   5 │     2      5\n   6 │     3      6\n\njulia> sdf = @view df[2:4, :]\n3×2 SubDataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     1      3\n   3 │     2      4\n\njulia> gsdf = groupby(sdf, :a)\nGroupedDataFrame with 2 groups based on key: a\nFirst Group (2 rows): a = 1\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     1      3\n⋮\nLast Group (1 row): a = 2\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      4\n\njulia> transform(gsdf, nrow) # create a new data frame\n3×3 DataFrame\n Row │ a      b      nrow\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      2\n   2 │     1      3      2\n   3 │     2      4      1\n\njulia> transform!(gsdf, nrow, :b => :b_copy)\n3×4 SubDataFrame\n Row │ a      b      nrow    b_copy\n     │ Int64  Int64  Int64?  Int64?\n─────┼──────────────────────────────\n   1 │     1      2       2       2\n   2 │     1      3       2       3\n   3 │     2      4       1       4\n\njulia> df\n6×4 DataFrame\n Row │ a      b      nrow     b_copy\n     │ Int64  Int64  Int64?   Int64?\n─────┼────────────────────────────────\n   1 │     1      1  missing  missing\n   2 │     1      2        2        2\n   3 │     1      3        2        3\n   4 │     2      4        1        4\n   5 │     2      5  missing  missing\n   6 │     3      6  missing  missing\n\njulia> select!(gsdf, :b_copy, :b => sum, renamecols=false)\n3×3 SubDataFrame\n Row │ a      b_copy  b\n     │ Int64  Int64?  Int64\n─────┼──────────────────────\n   1 │     1       2      5\n   2 │     1       3      5\n   3 │     2       4      4\n\njulia> df\n6×3 DataFrame\n Row │ a      b_copy   b\n     │ Int64  Int64?   Int64\n─────┼───────────────────────\n   1 │     1  missing      1\n   2 │     1        2      5\n   3 │     1        3      5\n   4 │     2        4      4\n   5 │     2  missing      5\n   6 │     3  missing      6","category":"page"},{"location":"man/split_apply_combine/#Column-independent-operations","page":"Split-apply-combine","title":"Column-independent operations","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The operation specification language used with combine, select and transform supports the following column-independent operations:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"getting the number of rows in a group (nrow);\ngetting the proportion of rows in a group (proprow);\ngetting the group number (groupindices);\ngetting a vector of indices within groups (eachindex).","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"These operations are column-independent, because they do not require specifying the input column name in the operation specification syntax.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"These four exceptions to the standard operation specification syntax were introduced for user convenience as these operations are often needed in practice.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Below each of them is explained by example.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"First create a data frame we will work with:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> df = DataFrame(customer_id=[\"a\", \"b\", \"b\", \"b\", \"c\", \"c\"],\n                      transaction_id=[12, 15, 19, 17, 13, 11],\n                      volume=[2, 3, 1, 4, 5, 9])\n6×3 DataFrame\n Row │ customer_id  transaction_id  volume\n     │ String       Int64           Int64\n─────┼─────────────────────────────────────\n   1 │ a                        12       2\n   2 │ b                        15       3\n   3 │ b                        19       1\n   4 │ b                        17       4\n   5 │ c                        13       5\n   6 │ c                        11       9\n\njulia> gdf = groupby(df, :customer_id, sort=true);\n\njulia> show(gdf, allgroups=true)\nGroupedDataFrame with 3 groups based on key: customer_id\nGroup 1 (1 row): customer_id = \"a\"\n Row │ customer_id  transaction_id  volume\n     │ String       Int64           Int64\n─────┼─────────────────────────────────────\n   1 │ a                        12       2\nGroup 2 (3 rows): customer_id = \"b\"\n Row │ customer_id  transaction_id  volume\n     │ String       Int64           Int64\n─────┼─────────────────────────────────────\n   1 │ b                        15       3\n   2 │ b                        19       1\n   3 │ b                        17       4\nGroup 3 (2 rows): customer_id = \"c\"\n Row │ customer_id  transaction_id  volume\n     │ String       Int64           Int64\n─────┼─────────────────────────────────────\n   1 │ c                        13       5\n   2 │ c                        11       9","category":"page"},{"location":"man/split_apply_combine/#Getting-the-number-of-rows","page":"Split-apply-combine","title":"Getting the number of rows","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"You can get the number of rows per group in a GroupedDataFrame by just writing nrow, in which case the generated column name with the number of rows is :nrow:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(gdf, nrow)\n3×2 DataFrame\n Row │ customer_id  nrow\n     │ String       Int64\n─────┼────────────────────\n   1 │ a                1\n   2 │ b                3\n   3 │ c                2","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Additionally you are allowed to pass target column name:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(gdf, nrow => \"transaction_count\")\n3×2 DataFrame\n Row │ customer_id  transaction_count\n     │ String       Int64\n─────┼────────────────────────────────\n   1 │ a                            1\n   2 │ b                            3\n   3 │ c                            2","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Note that in both cases we did not pass source column name as it is not needed to determine the number of rows per group. This is the reason why column-independent operations are exceptions to standard operation specification syntax.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The nrow expression also works in the operation specification syntax applied to a data frame. Here is an example:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(df, nrow => \"transaction_count\")\n1×1 DataFrame\n Row │ transaction_count\n     │ Int64\n─────┼───────────────────\n   1 │                 6","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Finally, recall that nrow is also a regular function that returns a number of rows in a data frame:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> nrow(df)\n6","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"This dual use of nrow does not lead to ambiguities, and is meant to make it easier to remember this exception.","category":"page"},{"location":"man/split_apply_combine/#Getting-the-proportion-of-rows","page":"Split-apply-combine","title":"Getting the proportion of rows","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"If you want to get a proportion of rows per group in a GroupedDataFrame you can use the proprow and proprow => [target column name] column-independent operations. Here are some examples:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(gdf, proprow)\n3×2 DataFrame\n Row │ customer_id  proprow\n     │ String       Float64\n─────┼───────────────────────\n   1 │ a            0.166667\n   2 │ b            0.5\n   3 │ c            0.333333\n\njulia> combine(gdf, proprow => \"transaction_fraction\")\n3×2 DataFrame\n Row │ customer_id  transaction_fraction\n     │ String       Float64\n─────┼───────────────────────────────────\n   1 │ a                        0.166667\n   2 │ b                        0.5\n   3 │ c                        0.333333","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"As opposed to nrow, proprow cannot be used outside of the operation specification syntax and is only allowed when processing a GroupedDataFrame.","category":"page"},{"location":"man/split_apply_combine/#Getting-the-group-number","page":"Split-apply-combine","title":"Getting the group number","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Another common operation is getting group number. Use the groupindices and groupindices => [target column name] column-independent operations to get it:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(gdf, groupindices)\n3×2 DataFrame\n Row │ customer_id  groupindices\n     │ String       Int64\n─────┼───────────────────────────\n   1 │ a                       1\n   2 │ b                       2\n   3 │ c                       3\n\njulia> transform(gdf, groupindices)\n6×4 DataFrame\n Row │ customer_id  transaction_id  volume  groupindices\n     │ String       Int64           Int64   Int64\n─────┼───────────────────────────────────────────────────\n   1 │ a                        12       2             1\n   2 │ b                        15       3             2\n   3 │ b                        19       1             2\n   4 │ b                        17       4             2\n   5 │ c                        13       5             3\n   6 │ c                        11       9             3\n\njulia> combine(gdf, groupindices => \"group_number\")\n3×2 DataFrame\n Row │ customer_id  group_number\n     │ String       Int64\n─────┼───────────────────────────\n   1 │ a                       1\n   2 │ b                       2\n   3 │ c                       3","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Outside of the operation specification syntax, groupindices is also a regular function which returns group indices for each row in the parent data frame of the passed GroupedDataFrame:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> groupindices(gdf)\n6-element Vector{Union{Missing, Int64}}:\n 1\n 2\n 2\n 2\n 3\n 3","category":"page"},{"location":"man/split_apply_combine/#Getting-a-vector-of-indices-within-groups","page":"Split-apply-combine","title":"Getting a vector of indices within groups","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The last column-independent operation supported by the operation specification syntax is getting the index of each row within each group:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(gdf, eachindex)\n6×2 DataFrame\n Row │ customer_id  eachindex\n     │ String       Int64\n─────┼────────────────────────\n   1 │ a                    1\n   2 │ b                    1\n   3 │ b                    2\n   4 │ b                    3\n   5 │ c                    1\n   6 │ c                    2\n\njulia> select(gdf, eachindex, groupindices)\n6×3 DataFrame\n Row │ customer_id  eachindex  groupindices\n     │ String       Int64      Int64\n─────┼──────────────────────────────────────\n   1 │ a                    1             1\n   2 │ b                    1             2\n   3 │ b                    2             2\n   4 │ b                    3             2\n   5 │ c                    1             3\n   6 │ c                    2             3\n\njulia> combine(gdf, eachindex => \"transaction_number\")\n6×2 DataFrame\n Row │ customer_id  transaction_number\n     │ String       Int64\n─────┼─────────────────────────────────\n   1 │ a                             1\n   2 │ b                             1\n   3 │ b                             2\n   4 │ b                             3\n   5 │ c                             1\n   6 │ c                             2","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Note that this operation also makes sense in a data frame context, where all rows are considered to be in the same group:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> transform(df, eachindex)\n6×4 DataFrame\n Row │ customer_id  transaction_id  volume  eachindex\n     │ String       Int64           Int64   Int64\n─────┼────────────────────────────────────────────────\n   1 │ a                        12       2          1\n   2 │ b                        15       3          2\n   3 │ b                        19       1          3\n   4 │ b                        17       4          4\n   5 │ c                        13       5          5\n   6 │ c                        11       9          6","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Finally recall that eachindex is a standard function for getting all indices in an array. This similarity of functionality was the reason why this name was picked:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> collect(eachindex(df.customer_id))\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"This, for example, means that in the following example the two created columns have the same contents:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(gdf, eachindex, :customer_id => eachindex)\n6×3 DataFrame\n Row │ customer_id  eachindex  customer_id_eachindex\n     │ String       Int64      Int64\n─────┼───────────────────────────────────────────────\n   1 │ a                    1                      1\n   2 │ b                    1                      1\n   3 │ b                    2                      2\n   4 │ b                    3                      3\n   5 │ c                    1                      1\n   6 │ c                    2                      2","category":"page"},{"location":"man/split_apply_combine/#Column-independent-operations-versus-functions","page":"Split-apply-combine","title":"Column-independent operations versus functions","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"When discussing column-independent operations it is important to remember that operation specification syntax allows you to pass a function (without source and target column names), in which case such a function gets passed a SubDataFrame that represents a group in a GroupedDataFrame. Here is an example comparing a column-independent operation and a function:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(gdf, eachindex, sdf -> axes(sdf, 1))\n6×3 DataFrame\n Row │ customer_id  eachindex  x1\n     │ String       Int64      Int64\n─────┼───────────────────────────────\n   1 │ a                    1      1\n   2 │ b                    1      1\n   3 │ b                    2      2\n   4 │ b                    3      3\n   5 │ c                    1      1\n   6 │ c                    2      2","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Notice that the column-independent operation eachindex produces the same result as using the anonymous function sdf -> axes(sdf, 1) that takes a SubDataFrame as its first argument and returns indices along its first axes. Importantly if it wasn't defined as a column-independent operation the eachindex function would fail when being passed as you can see here:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(gdf, sdf -> eachindex(sdf))\nERROR: MethodError: no method matching keys(::SubDataFrame{DataFrame, DataFrames.Index, Vector{Int64}})","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The reason for this error is that the eachindex function does not allow passing a SubDataFrame as its argument.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The same applies to proprow and groupindices: they would not work with a SubDataFrame as stand-alone functions.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"The nrow column-independent operation is a different case, as the nrow function accepts SubDataFrame as an argument:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> combine(gdf, nrow, sdf -> nrow(sdf))\n3×3 DataFrame\n Row │ customer_id  nrow   x1\n     │ String       Int64  Int64\n─────┼───────────────────────────\n   1 │ a                1      1\n   2 │ b                3      3\n   3 │ c                2      2","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Notice that columns :nrow and :x1 have identical contents, but the difference is that they do not have the same names. nrow is a column-independent operation generating the :nrow column name by default with number of rows per group. On the other hand, the sdf -> nrow(sdf) anonymous function does gets a SubDataFrame as its argument and returns its number of rows. The :x1 column name is the default auto-generated column name when processing anonymous functions.","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Passing a function taking a SubDataFrame is a flexible functionality allowing you to perform complex operations on your data. However, you should bear in mind two aspects:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"Using the full operation specification syntax (where source and target column names are passed) or column-independent operations will lead to faster execution of your code (as the Julia compiler is able to better optimize execution of such operations) in comparison to passing a function taking a SubDataFrame.\nAlthough writing nrow, proprow, groupindices, and eachindex looks like just passing a function they internally do not take a SubDataFrame as their argument. As we explained in this section, proprow, groupindices, and eachindex would not work with SubDataFrame as their argument, and nrow would work, but would produce a different column name. Instead, these four operations are special column-independent operations that are exceptions to the standard operation specification syntax rules. They were added for user convenience.","category":"page"},{"location":"man/split_apply_combine/#Specifying-group-order-in-groupby","page":"Split-apply-combine","title":"Specifying group order in groupby","text":"","category":"section"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"By default order of groups produced by groupby is undefined. If you want the order of groups to follow the order of first appearance in the source data frame of a grouping key then pass the sort=false keyword argument to groupby:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> push!(df, [\"a\", 100, 100]) # push row with large integer values to disable default sorting\n7×3 DataFrame\n Row │ customer_id  transaction_id  volume\n     │ String       Int64           Int64\n─────┼─────────────────────────────────────\n   1 │ a                        12       2\n   2 │ b                        15       3\n   3 │ b                        19       1\n   4 │ b                        17       4\n   5 │ c                        13       5\n   6 │ c                        11       9\n   7 │ a                       100     100\n\njulia> keys(groupby(df, :volume))\n7-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:\n GroupKey: (volume = 2,)\n GroupKey: (volume = 3,)\n GroupKey: (volume = 1,)\n GroupKey: (volume = 4,)\n GroupKey: (volume = 5,)\n GroupKey: (volume = 9,)\n GroupKey: (volume = 100,)","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"If you want to have them sorted in ascending order pass sort=true:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> keys(groupby(df, :volume, sort=true))\n7-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:\n GroupKey: (volume = 1,)\n GroupKey: (volume = 2,)\n GroupKey: (volume = 3,)\n GroupKey: (volume = 4,)\n GroupKey: (volume = 5,)\n GroupKey: (volume = 9,)\n GroupKey: (volume = 100,)","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"You can also use the order wrapper when passing a column name to group by or pass a named tuple as sort keyword argument containing one or more of alg, lt, by, rev, and order fields that will be treated just like in sortperm:","category":"page"},{"location":"man/split_apply_combine/","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> keys(groupby(df, [:customer_id, order(:volume, rev=true)]))\n6-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:\n GroupKey: (customer_id = \"a\", volume = 2)\n GroupKey: (customer_id = \"b\", volume = 4)\n GroupKey: (customer_id = \"b\", volume = 3)\n GroupKey: (customer_id = \"b\", volume = 1)\n GroupKey: (customer_id = \"c\", volume = 9)\n GroupKey: (customer_id = \"c\", volume = 5)\n\njulia> keys(groupby(df, :customer_id, sort=(rev=true,)))\n3-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:\n GroupKey: (customer_id = \"c\",)\n GroupKey: (customer_id = \"b\",)\n GroupKey: (customer_id = \"a\",)","category":"page"},{"location":"man/getting_started/#入门指南","page":"Getting Started","title":"入门指南","text":"","category":"section"},{"location":"man/getting_started/#安装","page":"Getting Started","title":"安装","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"DataFrames包通过Julia包系统提供，可以使用以下命令进行安装：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"DataFrames\")","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"在本教程的其余部分，我们假设你已经安装了DataFrames包，并且已经输入了using DataFrames，将所有相关的变量引入到你当前的命名空间。","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\n默认情况下，DataFrames.jl在Jupyter Notebook中显示数据帧时，行和列的数量分别限制为25和100。你可以通过改变ENV[\"DATAFRAMES_COLUMNS\"]和ENV[\"DATAFRAMES_ROWS\"]变量的值来覆盖这种行为，以保持输出的最大列数和行数。如果这些数字等于或小于0，将打印所有的列或行。或者，你可能想要在每个Julia会话中，通过某个Jupyter内核文件设置数据帧的最大打印行数为100，最大打印列数为1000（数字100和1000只是例子，可以进行调整）。在这种情况下，向这个Jupyter内核文件的\"env\"变量中添加一个\"DATAFRAME_COLUMNS\": \"1000\", \"DATAFRAMES_ROWS\": \"100\"条目。关于Jupyter内核的位置和规范的信息，请查看这里。PrettyTables.jl包在Jupyter notebook中渲染DataFrame。用户可以通过向show函数传递关键字参数kwargs...来自定义输出：show(stdout, MIME(\"text/html\"), df; kwargs...)，其中df是DataFrame。此处可以使用PrettyTables.jl在HTML后端支持的任何参数。因此，例如，如果用户想要在Jupyter中将所有小于0的数字的颜色改为红色，他们可以在using PrettyTables后执行：show(stdout, MIME(\"text/html\"), df; highlighters = hl_lt(0, HtmlDecoration(color = \"red\")))。关于可用选项的更多信息，请查看PrettyTables.jl文档。","category":"page"},{"location":"man/getting_started/#DataFrame-类型","page":"Getting Started","title":"DataFrame 类型","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"DataFrame类型的对象表示一个数据表，作为一系列向量，每个向量对应一列或变量。构造DataFrame的最简单方式是使用关键字参数或对传递列向量：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using DataFrames\n\njulia> DataFrame(a=1:4, b=[\"M\", \"F\", \"F\", \"M\"]) # 关键字参数构造器\n4×2 DataFrame\n Row │ a      b\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  F\n   3 │     3  F\n   4 │     4  M","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"以下是其他常用的构造数据帧的方法：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> DataFrame((a=[1, 2], b=[3, 4])) # 从命名元组的向量构造Tables.jl表\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> DataFrame([(a=1, b=0), (a=2, b=0)]) # 从命名元组的向量构造Tables.jl表\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame(\"a\" => 1:2, \"b\" => 0) # Pair构造器\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([:a => 1:2, :b => 0]) # Pairs向量构造器\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame(Dict(:a => 1:2, :b => 0)) # 字典构造器\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([[1, 2], [0, 0]], [:a, :b]) # 向量的向量构造器\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([1 0; 2 0], :auto) # 矩阵构造器\n2×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"列可以直接（即，不复制）用df.col，df.\"col\"，df[!, :col]或df[!, \"col\"]提取（这个规则适用于从数据帧获取数据，而不是向数据帧写入数据）。后两种语法更灵活，因为它们允许传递一个保存列名的变量，而不仅仅是一个字面名。注意，列名可以是符号（写成:col，:var\"col\"或Symbol(\"col\")）或字符串（写成\"col\"）。在df.\"col\"和:var\"col\"的形式中，使用`进行字符串插值不起作用。列也可以通过指定它们的位置的整数索引来提取。","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"由于df[!, :col]不会复制，改变这种语法返回的列向量的元素将影响存储在原始df中的值。要获取列的副本，使用df[:, :col]：改变这种语法返回的向量不会改变df。","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(A=1:4, B=[\"M\", \"F\", \"F\", \"M\"])\n4×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  F\n   3 │     3  F\n   4 │     4  M\n\njulia> df.A\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> df.\"A\"\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> df.A === df[!, :A]\ntrue\n\njulia> df.A === df[:, :A]\nfalse\n\njulia> df.A == df[:, :A]\ntrue\n\njulia> df.A === df[!, \"A\"]\ntrue\n\njulia> df.A === df[:, \"A\"]\nfalse\n\njulia> df.A == df[:, \"A\"]\ntrue\n\njulia> df.A === df[!, 1]\ntrue\n\njulia> df.A === df[:, 1]\nfalse\n\njulia> df.A == df[:, 1]\ntrue\n\njulia> firstcolumn = :A\n:A\n\njulia> df[!, firstcolumn] === df.A\ntrue\n\njulia> df[:, firstcolumn] === df.A\nfalse\n\njulia> df[:, firstcolumn] == df.A\ntrue","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"列名可以使用names函数获取为字符串：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> names(df)\n2-element Vector{String}:\n \"A\"\n \"B\"","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"你也可以通过传递一个列选择器条件作为第二个参数来过滤列名。在names文档字符串中，你可以找到关于所有可用条件的详细列表。这里我们给出一些选定的例子：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> names(df, r\"A\") # 正则表达式选择器\n1-element Vector{String}:\n \"A\"\n\njulia> names(df, Int) # 使用列元素类型的选择器\n1-element Vector{String}:\n \"A\"\n\njulia> names(df, Not(:B)) # 保留除:B以外的所有列的选择器\n1-element Vector{String}:\n \"A\"","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"要以Symbol形式获取列名，使用propertynames函数：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> propertynames(df)\n2-element Vector{Symbol}:\n :A\n :B","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nDataFrames.jl允许使用Symbol（如:A）和字符串（如\"A\"）进行所有列索引操作，以便于使用。然而，使用Symbol稍微快一些，通常应该被优先选择，除非通过字符串操作生成它们。","category":"page"},{"location":"man/getting_started/#按列构造","page":"Getting Started","title":"按列构造","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"也可以从一个空的DataFrame开始，一列一列地添加：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame()\n0×0 DataFrame\n\njulia> df.A = 1:8\n1:8\n\njulia> df[:, :B] = [\"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\", \"F\"]\n8-element Vector{String}:\n \"M\"\n \"F\"\n \"F\"\n \"M\"\n \"F\"\n \"M\"\n \"M\"\n \"F\"\n\njulia> df[!, :C] .= 0\n8-element Vector{Int64}:\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n\njulia> df\n8×3 DataFrame\n Row │ A      B       C\n     │ Int64  String  Int64\n─────┼──────────────────────\n   1 │     1  M           0\n   2 │     2  F           0\n   3 │     3  F           0\n   4 │     4  M           0\n   5 │     5  F           0\n   6 │     6  M           0\n   7 │     7  M           0\n   8 │     8  F           0","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"我们以这种方式构建的DataFrame有8行和3列。这可以使用size函数进行检查：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> size(df, 1)\n8\n\njulia> size(df, 2)\n3\n\njulia> size(df)\n(8, 3)","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"在上述例子中，注意到表达式df[!, :C] .= 0通过广播一个标量来创建了数据框中的新列。","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"在设置数据框的列时，df[!, :C]和df.C的语法是等价的，它们会替换（或创建）df中的:C列。这与使用df[:, :C]设置数据框中的列不同，后者如果列已经存在的话，会就地更新列的内容。","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"这里有一个例子展示这种差异。让我们尝试将:B列改为二元变量。","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> df[:, :B] = df.B .== \"F\"\nERROR: MethodError: Cannot `convert` an object of type Bool to an object of type String\n\njulia> df[:, :B] .= df.B .== \"F\"\nERROR: MethodError: Cannot `convert` an object of type Bool to an object of type String","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"上述操作没有成功，因为当你使用:作为行选择器时，:B列是就地更新的，它只支持存储字符串。","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"另一方面，下面的操作可以：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> df.B = df.B .== \"F\"\n8-element BitVector:\n 0\n 1\n 1\n 0\n 1\n 0\n 0\n 1\n\njulia> df\n8×3 DataFrame\n Row │ A      B      C\n     │ Int64  Bool   Int64\n─────┼─────────────────────\n   1 │     1  false      0\n   2 │     2   true      0\n   3 │     3   true      0\n   4 │     4  false      0\n   5 │     5   true      0\n   6 │     6  false      0\n   7 │     7  false      0\n   8 │     8   true      0","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"如你所见，因为我们在赋值的右侧使用了df.B，所以:B列被替换了。如果我们使用df[!, :B]或者我们使用广播赋值.=，将会达到同样的效果。","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"在手册的Indexing部分，你可以找到所有关于所有可用索引选项的详细信息。","category":"page"},{"location":"man/getting_started/#逐行构建","page":"Getting Started","title":"逐行构建","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"也可以逐行填充DataFrame。让我们构建一个空的数据框，有两列（注意第一列只能包含整数，第二列只能包含字符串）：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(A=Int[], B=String[])\n0×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┴───────────────","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"然后可以添加元组或向量作为行，其中元素的顺序与列的顺序匹配。要在数据框的末尾添加新行，使用push!：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> push!(df, (1, \"M\"))\n1×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n\njulia> push!(df, [2, \"N\"])\n2×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  N","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"行也可以作为Dict添加，其中字典的键匹配列的名称：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> push!(df, Dict(:B => \"F\", :A => 3))\n3×2 DataFrame\n Row │ A      B\n     │ Int64  String\n─────┼───────────────\n   1 │     1  M\n   2 │     2  N\n   3 │     3  F","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"请注意，逐行构建DataFrame的性能明显低于一次性构建，或者按列构建。对于许多用例，这可能无关紧要，但对于非常大的DataFrame，这可能是一个考虑因素。","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"如果你想在数据框的开始处添加行，使用pushfirst!，要在任意位置插入行，使用insert!。","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"你也可以使用append!和prepend!函数将整个表添加到数据框中。","category":"page"},{"location":"man/getting_started/#从另一种表类型构建","page":"Getting Started","title":"从另一种表类型构建","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"DataFrames支持Tables.jl接口，用于与表格数据交互。这意味着DataFrame可以作为任何期望Tables.jl接口输入的包的\"源\"（文件格式包，数据操作包等）。DataFrame也可以是任何Tables.jl接口输入的接收器。一些示例用途是：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"df = DataFrame(a=[1, 2, 3], b=[:a, :b, :c])\n\n# 把 DataFrame 写入 CSV 文件\nCSV.write(\"dataframe.csv\", df)\n\n# 把 DataFrame 存储在 SQLite 数据库表中\nSQLite.load!(df, db, \"dataframe_table\")\n\n# 通过 Query.jl 包转换 DataFrame\ndf = df |> @map({a=_.a + 1, _.b}) |> DataFrame","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"支持Tables.jl接口的特定常见集合的一个例子是NamedTuple的向量：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> v = [(a=1, b=2), (a=3, b=4)]\n2-element Vector{NamedTuple{(:a, :b), Tuple{Int64, Int64}}}:\n (a = 1, b = 2)\n (a = 3, b = 4)\n\njulia> df = DataFrame(v)\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     3      4","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"你也可以很容易地把数据框转换回NamedTuple的向量：","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using Tables\n\njulia> Tables.rowtable(df)\n2-element Vector{NamedTuple{(:a, :b), Tuple{Int64, Int64}}}:\n (a = 1, b = 2)\n (a = 3, b = 4)","category":"page"},{"location":"man/missing/#缺失数据","page":"Missing Data","title":"缺失数据","text":"","category":"section"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"在Julia中，数据的缺失值使用特殊对象missing来表示，它是Missing类型的唯一实例。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> missing\nmissing\n\njulia> typeof(missing)\nMissing","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"Missing类型允许用户创建包含缺失值的向量和DataFrame列。这里我们创建一个包含缺失值的向量，返回的向量的元素类型是Union{Missing, Int64}。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> x = [1, 2, missing]\n3-element Vector{Union{Missing, Int64}}:\n 1\n 2\n  missing\n\njulia> eltype(x)\nUnion{Missing, Int64}\n\njulia> Union{Missing, Int}\nUnion{Missing, Int64}\n\njulia> eltype(x) == Union{Missing, Int}\ntrue","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"执行操作时可以使用skipmissing来排除missing值，它返回一个内存高效的迭代器。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> skipmissing(x)\nskipmissing(Union{Missing, Int64}[1, 2, missing])","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"skipmissing的输出可以直接作为函数的参数传入。例如，我们可以找到所有非缺失值的sum，或者将非缺失值collect到一个新的无缺失值向量中。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> sum(skipmissing(x))\n3\n\njulia> collect(skipmissing(x))\n2-element Vector{Int64}:\n 1\n 2","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"函数coalesce可以用来将缺失值替换为另一个值（注意点，表示应用到x的所有条目）：","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> coalesce.(x, 0)\n3-element Vector{Int64}:\n 1\n 2\n 0","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"函数dropmissing和dropmissing!可以用来从数据框中删除包含missing值的行，并分别创建一个新的DataFrame或就地修改原始数据。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> using DataFrames\n\njulia> df = DataFrame(i=1:5,\n                      x=[missing, 4, missing, 2, 1],\n                      y=[missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n Row │ i      x        y\n     │ Int64  Int64?   String?\n─────┼─────────────────────────\n   1 │     1  missing  missing\n   2 │     2        4  missing\n   3 │     3  missing  c\n   4 │     4        2  d\n   5 │     5        1  e\n\njulia> dropmissing(df)\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"可以指定在哪些列中搜索包含missing值的行以进行删除。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> dropmissing(df, :x)\n3×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String?\n─────┼───────────────────────\n   1 │     2      4  missing\n   2 │     4      2  d\n   3 │     5      1  e","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"默认情况下，dropmissing和dropmissing!函数在选定用于行删除的列中保持Union{T, Missing}元素类型。要删除Missing部分（如果存在），请将disallowmissing关键字参数设置为true（它将成为未来的默认行为）。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> dropmissing(df, disallowmissing=true)\n2×3 DataFrame\n Row │ i      x      y\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     4      2  d\n   2 │     5      1  e","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"有时，允许或不允许数据框的某些列支持缺失值是有用的。这些操作由allowmissing、allowmissing!、disallowmissing和disallowmissing!函数支持。这是一个例子：","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> df = DataFrame(x=1:3, y=4:6)\n3×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      4\n   2 │     2      5\n   3 │     3      6\n\njulia> allowmissing!(df)\n3×2 DataFrame\n Row │ x       y\n     │ Int64?  Int64?\n─────┼────────────────\n   1 │      1       4\n   2 │      2       5\n   3 │      3       6","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"现在，df允许其所有列中存在缺失值。我们可以利用这个事实，并将df中的一些值设置为missing，例如：","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> df[1, 1] = missing\nmissing\n\njulia> df\n3×2 DataFrame\n Row │ x        y\n     │ Int64?   Int64?\n─────┼─────────────────\n   1 │ missing       4\n   2 │       2       5\n   3 │       3       6","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"请注意，可以将列选择器作为第二个位置参数传递给allowmissing和allowmissing!，以限制只更改我们数据框中的某些列。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"现在，让我们执行相反的操作，不允许在df中有缺失值。我们知道列:y不包含缺失值，所以我们可以使用disallowmissing函数，将列选择器作为第二个位置参数传入：","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> disallowmissing(df, :y)\n3×2 DataFrame\n Row │ x        y\n     │ Int64?   Int64\n─────┼────────────────\n   1 │ missing      4\n   2 │       2      5\n   3 │       3      6","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"这个操作创建了一个新的DataFrame。如果我们想就地更新df，应该使用disallowmissing!函数。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"如果我们尝试使用disallowmissing(df)在整个数据框中不允许缺失值，我们会得到一个错误。然而，通常在所有实际上不包含它们的列中不允许缺失值，但保持有一些missing值的列不变，而无需明确列出它们，这是很有用的。这可以通过传递error=false关键字参数来实现：","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> disallowmissing(df, error=false)\n3×2 DataFrame\n Row │ x        y\n     │ Int64?   Int64\n─────┼────────────────\n   1 │ missing      4\n   2 │       2      5\n   3 │       3      6","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"Missings.jl包提供了一些方便的函数来处理缺失值。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"最常用的一个是passmissing。它是一个高阶函数，接受一些函数f作为其参数，并返回一个新函数，如果其位置参数中有任何missing，则返回missing，否则将函数f应用于这些参数。这个功能与那些不支持将missing值作为参数传递的函数结合使用是有用的。例如，尝试uppercase(missing)会产生一个错误，而以下的操作是可以的：","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> passmissing(uppercase)(\"a\")\n\"A\"\n\njulia> passmissing(uppercase)(missing)\nmissing","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"函数Missings.replace返回一个迭代器，它用另一个值替换missing元素：","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> using Missings\n\njulia> Missings.replace(x, 1)\nMissings.EachReplaceMissing{Vector{Union{Missing, Int64}}, Int64}(Union{Missing, Int64}[1, 2, missing], 1)\n\njulia> collect(Missings.replace(x, 1))\n3-element Vector{Int64}:\n 1\n 2\n 1\n\njulia> collect(Missings.replace(x, 1)) == coalesce.(x, 1)\ntrue","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"函数nonmissingtype返回Union{T, Missing}中的元素类型T。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> eltype(x)\nUnion{Missing, Int64}\n\njulia> nonmissingtype(eltype(x))\nInt64","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"missings函数构建支持缺失值的Vector和Array，使用可选的第一个参数来指定元素类型。","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"julia> missings(1)\n1-element Vector{Missing}:\n missing\n\njulia> missings(3)\n3-element Vector{Missing}:\n missing\n missing\n missing\n\njulia> missings(1, 3)\n1×3 Matrix{Missing}:\n missing  missing  missing\n\njulia> missings(Int, 1, 3)\n1×3 Matrix{Union{Missing, Int64}}:\n missing  missing  missing","category":"page"},{"location":"man/missing/","page":"Missing Data","title":"Missing Data","text":"请参阅Julia手册以获取更多关于缺失值的信息。","category":"page"},{"location":"#DataFrames.jl","page":"Introduction","title":"DataFrames.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"欢迎阅读DataFrames.jl的文档！","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"本资源旨在教授你如何使用DataFrames.jl包进行表格数据操作所需的一切知识。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"你可以查看以下资源来了解DataFrames.jl的更多应用，尤其是与其他包的结合使用（这些资源会与DataFrames.jl的发布版本保持同步更新）：","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"在Journal of Statistical Software发表的文章DataFrames.jl: Flexible and Fast Tabular Data in Julia\nData Wrangling with DataFrames.jl Cheat Sheet\n使用Jupyter Notebooks的DataFrames教程\nJulia Academy DataFrames.jl教程\nJuliaCon 2019、 JuliaCon 2020、 JuliaCon 2021、 JuliaCon 2022、 PyData Global 2020以及 ODSC Europe 2021的教程\nDataFrames.jl展示","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"如果你更喜欢通过书籍学习DataFrames.jl，可以考虑阅读：","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia for Data Analysis\nJulia Data Science","category":"page"},{"location":"#什么是DataFrames.jl？","page":"Introduction","title":"什么是DataFrames.jl？","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFrames.jl提供了一套用于在Julia中处理表格数据的工具。其设计和功能与Python的pandas和R的data.frame、data.table以及dplyr相似，使其成为一个极好的通用数据科学工具。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFrames.jl在Julia数据生态系统中起着核心作用，并且与许多不同的库紧密集成。DataFrames.jl并不是Julia中处理表格数据的唯一工具——如下所述，对于某些特定用例，还有一些其他的优秀库——但是它通过熟悉的接口提供了出色的数据整理功能。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"要更详细地了解这个工具链，请查看本手册中的教程。新用户可以从使用DataFrames.jl的第一步部分开始。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"你可能会发现DataFramesMeta.jl包或者本手册中讨论的数据操作框架部分的其他便利包在编写更高级的数据转换时很有帮助，尤其是如果你没有太多的编程经验。这些包提供了类似于R中dplyr的便利语法。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"如果你在使用DataFrames.jl时使用元数据，你可能会发现TableMetadataTools.jl包很有用。此包定义了几个便利函数，用于执行典型的元数据操作。","category":"page"},{"location":"#DataFrames.jl和Julia数据生态系统","page":"Introduction","title":"DataFrames.jl和Julia数据生态系统","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"对于新用户来说，Julia数据生态系统可能是一个难以导航的领域，部分原因是Julia生态系统比其他一些语言更倾向于将功能分布在不同的库中。由于许多来到DataFrames.jl的人刚开始探索Julia数据生态系统，以下是一些提供不同数据科学工具的良好支持的库，以及每个库的特点，以及它们与DataFrames.jl的集成程度的一些注解。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"统计\nStatsKit.jl：一个便利的元包，加载一套用于统计的基本包，包括本节下面提到的那些包和DataFrames.jl本身。\nStatistics：Julia标准库提供了广泛的统计功能，但要访问这些函数，你必须调用using Statistics。\nLinearAlgebra：与Statistics一样，许多线性代数特性（分解、求逆等）都存在于你必须加载才能使用的库中。\nSparseArrays也在标准库中，但必须加载才能使用。\nFreqTables.jl：创建频率表/交叉制表。与DataFrames.jl紧密集成。\nHypothesisTests.jl：一系列假设检验工具。\nGLM.jl：用于估计线性和广义线性模型的工具。与DataFrames.jl紧密集成。\nStatsModels.jl：用于将异质的DataFrame转换为用于线性代数库或不直接支持DataFrame的机器学习应用的同质矩阵。会做如将分类变量转换为指标/一键热编码，创建交互项等事情。\nMultivariateStats.jl：线性回归、岭回归、PCA、组分分析工具。与DataFrames.jl的集成不够紧密，但可以很容易地与StatsModels一起使用。\n机器学习\nMLJ.jl：如果你更多的是一个应用用户，那么有一个单独的包可以从所有这些不同的库中抽取，并提供一个类似scikit-learn的API：MLJ.jl。MLJ.jl为大量的机器学习算法提供了一个公共接口。\nScikitLearn.jl：围绕Python的完整scikit-learn机器学习库的Julia包装器。与DataFrames.jl的集成不够紧密，但可以通过StatsModels.jl进行结合。\nAutoMLPipeline：一个包，使得使用简单表达式创建复杂的ML管道结构变得非常简单。它利用Julia的内置宏编程特性，符号处理，操纵管道表达式，并使得发现机器学习回归和分类的最优结构变得容易。\n深度学习：KNet.jl和Flux.jl。\n绘图\nPlots.jl：强大的、现代的绘图库，语法类似于Python的matplotlib或R的plot。StatsPlots.jl为Plots.jl提供了许多标准统计图的配方。\nGadfly.jl：高级绘图库，具有类似于R的ggplot的\"图形语法\"语法。\nAlgebraOfGraphics.jl：一个基于Makie.jl的\"图形语法\"库。\nVegaLite.jl：高级绘图库，使用不同的\"图形语法\"语法，并强调交互式图形。\n数据整理：\nImpute.jl：处理向量、矩阵和表中缺失数据的各种方法。\nDataFramesMeta.jl：为DataFrames.jl提供一系列便利函数，增强了select和transform，提供了类似于R中dplyr提供的用户体验。\nDataFrameMacros.jl：提供了类似于DataFramesMeta.jl的常见DataFrames.jl函数的宏版本，具有方便的语法，用于一次操作多个列。\nQuery.jl：Query.jl为数据整理提供了一个单一的框架，可用于多种库，包括DataFrames.jl、其他表格数据库（下面会有更多信息），甚至非表格数据。提供了许多类似于R中dplyr或LINQ的便利函数。\n在本手册的数据操作框架部分，你可以找到这些包的更多信息。\n更多！\nGraphs.jl：一个纯Julia的，高性能的网络分析库。可以使用GraphDataFrameBridge.jl包将DataFrame中的边列表轻松转换为图。\nIO：\nDataFrames.jl可以很好地处理各种格式，包括：\nCSV文件（使用CSV.jl），\nApache Arrow（使用Arrow.jl）\n读取Stata、SAS和SPSS文件（使用ReadStatTables.jl；另外Queryverse用户可以选择StatFiles.jl），\nParquet文件 (使用Parquet2.jl)，\n读取R数据文件(.rda, .RData) (使用RData.jl)。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"虽然并非所有这些库都与DataFrames.jl紧密集成，但由于DataFrame本质上是对齐的Julia向量的集合，所以很容易(a)从非DataFrames集成的库中提取一个向量，或者(b)使用Matrix构造函数或StatsModels.jl将你的表格转换为同质类型的矩阵。","category":"page"},{"location":"#其他Julia表格库","page":"Introduction","title":"其他Julia表格库","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFrames.jl是一个用于数据操作和整理的很好的通用工具，但并不是所有应用的理想选择。对于有更专业需求的用户，可以考虑使用：","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"TypedTables.jl：类型稳定的异质表格。当你的表格结构相对稳定并且没有数千个列时，用于提高性能。\nJuliaDB.jl：对于处理无法放入内存的数据的用户，我们建议使用JuliaDB.jl，它为大型数据集提供了更好的性能，并可以处理超出内存的数据操作（Python用户可以将JuliaDB.jl视为Julia版本的dask）。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"请注意，Julia生态系统中的大多数表格数据库（包括DataFrames.jl）都支持一个公共接口（在Tables.jl包中定义）。因此，一些库能够处理各种表格数据结构，使得随着你的需求变化，从一个表格库轻松切换到另一个表格库成为可能。例如，Query.jl的用户可以使用同一段代码来操作DataFrame、Table（由TypedTables.jl定义）或JuliaDB表。","category":"page"},{"location":"#有问题吗？","page":"Introduction","title":"有问题吗？","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"如果有你期望DataFrames能做到的事情，但你不知道如何做，请在Discourse的Domains/Data中提出问题。此外，你可能还想在JuliaAcademy听一下对DataFrames.jl的介绍。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"请通过开启一个问题来报告错误。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"你可以在整个文档中跟随源链接，直接跳到GitHub上的源文件，以改进文档和函数功能的pull请求。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"在提交你的第一个PR之前，请查看DataFrames的贡献指南！","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"可以在发布页面找到关于特定版本的信息。","category":"page"},{"location":"#包手册","page":"Introduction","title":"包手册","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"man/basics.md\",\n         \"man/getting_started.md\",\n         \"man/joins.md\",\n         \"man/split_apply_combine.md\",\n         \"man/reshaping_and_pivoting.md\",\n         \"man/sorting.md\",\n         \"man/categorical.md\",\n         \"man/missing.md\",\n         \"man/comparisons.md\",\n         \"man/querying_frameworks.md\"]\nDepth = 2","category":"page"},{"location":"#API","page":"Introduction","title":"API","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"只有导出的（即在加载DataFrames.jl包并使用 using DataFrames 后，无需使用 DataFrames. 限定符即可使用）类型和函数被视为DataFrames.jl包的公共API的一部分。通常，所有这些对象都在此手册中有文档记录（如果有缺少的文档，请在这里报告问题）。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\n在可能的情况下，DataFrames.jl避免对公共和记录的API进行破坏性更改。下列更改不被视为破坏性更改：由操作计算的特定浮点值可能随时更改；用户应仅依赖近似的准确性；\n在使用Base Julia提供的默认随机数生成器的函数中，计算出的特定随机数可能会在Julia版本之间更改；\n如果更改的功能被分类为错误；\n如果更改的行为未被记录；两个主要情况是：\n在实现中，某些函数接受的参数范围比记录处理的范围更广 - 更改处理未记录参数的方式不被视为破坏性；\n函数返回的值的类型发生了更改，但仍然遵循文档中指定的契约；例如，如果一个函数记录为返回一个向量，那么将其类型从 Vector 更改为 PooledVector 不被视为破坏性；\n错误行为：抛出异常的代码可以更改抛出的异常类型或停止抛出异常；\n显示的更改（如何打印对象）；\n更改Base Julia的全局对象的状态，这些对象的状态通常被视为不稳定（例如，全局随机数生成器的状态）。所有公共API的部分的类型和函数在进行对它们的破坏性更改或移除它们之前，都保证会经历一个弃用期。标准做法是，当DataFrames.jl的一个主要版本发布时（例如，在1.x版本中弃用的功能将在2.0版本中进行更改）。在罕见的情况下，可能会在一个小版本中引入破坏性更改。在这种情况下，更改的行为仍然会经历一个小版本的弃用期。可能允许进行这种破坏性更改的情况是（如果可能，仍将避免这种破坏性更改）：受影响的功能以前在文档中明确标识为可能会更改（例如，在DataFrames.jl 1.4版本发布中，:note-style元数据的传播规则就被记录为这样）；\n更改处于被分类为错误的边缘（在罕见的情况下，即使某个函数的行为被记录，其对某些参数组合的后果也可能被决定为无意的和不希望的）；\n更改是为了调整DataFrames.jl的功能以适应Base Julia的更改。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"请注意，虽然Julia允许您访问DataFrames.jl的内部函数或类型，但这些可能在DataFrames.jl的版本之间无预警地更改。特别是，直接访问DataFrames.jl包的公共API部分的类型的字段是不安全的，例如使用 getfield 函数。当考虑允许对定义类型的字段进行某些操作时，应该使用适当的导出函数代替。","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"lib/types.md\", \"lib/functions.md\", \"lib/indexing.md\"]\nDepth = 2","category":"page"},{"location":"#索引","page":"Introduction","title":"索引","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"lib/types.md\", \"lib/functions.md\"]","category":"page"},{"location":"assets/README/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"In this folder we store the following data sets:","category":"page"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"german_credit.csv\niris.csv","category":"page"},{"location":"assets/README/#German-Credit-data-set","page":"Introduction","title":"German Credit data set","text":"","category":"section"},{"location":"assets/README/#License:","page":"Introduction","title":"License:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://opendatacommons.org/licenses/dbcl/1-0/","category":"page"},{"location":"assets/README/#Source:","page":"Introduction","title":"Source:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://archive.ics.uci.edu/ml/datasets/statlog+(german+credit+data) Professor Dr. Hans Hofmann Institut für Statistik und Ökonometrie Universität Hamburg FB Wirtschaftswissenschaften Von-Melle-Park 5 2000 Hamburg 13","category":"page"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"The original data is from UCI, and the file stored here is from Kaggle","category":"page"},{"location":"assets/README/#Iris-data-set","page":"Introduction","title":"Iris data set","text":"","category":"section"},{"location":"assets/README/#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://creativecommons.org/publicdomain/zero/1.0/","category":"page"},{"location":"assets/README/#Source:-2","page":"Introduction","title":"Source:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://archive.ics.uci.edu/ml/datasets/Iris Creator: R.A. Fisher","category":"page"}]
}
